\documentclass[]{article}
\usepackage{vmlmacros}
\usepackage{syntax}
\usepackage{relsize}
\usepackage{palatino}
\usepackage{amsmath}
\usepackage{booktabs}
\setcounter{secnumdepth}{1}

\DeclareMathOperator{\dom}{dom}


% Docket: move relevant macros to macros file. 
\newcommand{\bracketed}[1]{\{#1\}}

% \setlength{\grammarparsep}{20pt plus 1pt minus 1pt} % increase separation between rules
\setlength{\grammarindent}{10em} % increase separation between LHS/RHS

\newcommand\nr[1]{\leavevmode\emph{NR: #1}}
\newcommand\rab[1]{\leavevmode\emph{rab: #1}}
\newcommand\vfilbreak[1][1in]{\vskip 0pt plus #1\penalty-200 \vskip 0pt plus -#1}

\setlength{\parindent}{0cm}
\title{Syntax and Semantics of $V^{-}$}
\author{Roger Burtonpatel}
\date{October 22, 2023}
\begin{document}

\maketitle

\section{Syntax}

\nr{I recommend macros for optional and sequence, not literal brackets.} \\
\rab{Despite my best efforts, such a macro does not work in grammar mode.} \\
We present a grammar of $V^{-}$: 

\bigskip

% Integers \hspace{1cm} $k$ \\
% Variables \hspace{.45cm} $x, y, z, f, g$ \\
% Programs \hspace{1cm} $p ::= \bf{one} \{ e \}$, where \ppl{fvs} $e = \emptyset$ \\
% Expressions $e ::= v \; \vert \; eq \ppl{;} \; e$ 
% Values \hspace{1cm} $v ::= x \;\vert\; hnf$ 
% Head Values \hspace{1cm} $hnf ::= k \;\vert\; op \;\vert\; \lambda x.\;e$ 

\begin{grammar}
    <program> ::= \{{<def>}\}
    
    <def> ::= \tt{val} <name> <exp>
        \alt <exp>
    
        
        
        <exp> ::= <integer-literal>
        \alt <name>
        \alt <guarded-if>
        \alt <lambda>
        \alt <value-constructor-name> \{<exp>\}
        \alt <exp> <exp>
        \alt <exp> $\choice$ <exp>
        
        
        <lambda> ::= $\lambda$\{<name>\}\tt{.} <exp>
        
        <guarded-if> ::= \tt{if}  [<guarded-exp> \{ [] <guarded-exp> \}] \tt{fi}
        
        
        <guarded-exp> ::= $\boldsymbol{\rightarrow}$<exp>
        \alt  \tt{E} \{<name>\}\tt{.} <guarded-exp>
        \alt  <exp>\tt{;} <guarded-exp>
        \alt   <name> \tt{=} <exp>\tt{;} <guarded-exp>
        \alt   <exp> \tt{=} <exp>\tt{;} <guarded-exp>
        \alt   <guarded-exp> $\choice$ <guarded-exp> 
        \alt   \tt{one}(\{<guarded-exp>\})
        \alt   \tt{all}(\{<guarded-exp>\})
        
        <name> ::= any token that is not an \textit{int-lit}, does not contain 
        whitespace,
        % a \texttt{'}, bracket, or parenthesis, 
        and is not a <value-constructor-name> or a reserved word.

        <value-constructor-name> ::= \cons | \tt{[]} | any token that begins
        with a capital letter or a colon
    
        <integer-literal> ::= token composed only of digits, possibly prefixed with a \texttt{+} or \texttt{-}.
    
    \end{grammar}

% A $\star$ indicates syntactic sugar. 

% The desugaring of a multi-name \tt{E}
% is:


% $$\tt{E} \; lv_1 \tt{.} \; \dots \; \langle guarded\rm{-}exp \rangle \;
% \triangleq \; \tt{E} \; lv_1 \tt{.} \; \tt{E} \tt{.} \; \dots \; \langle
    % guarded\rm{-}exp \rangle  $$
        
\section{Refinement ordering on environments}

\begin{align*}
\rho \subseteq \rho' \text{ when }&\dom\rho  \subseteq \dom \rho'\\
\text{ and } &\forall x \in \dom \rho: \rho(x) \subseteq \rho'(x)
\end{align*}



\vfilbreak



\section{Forms of Judgement for $V^{-}$:}
\begin{tabular}{ll}
\toprule
    \multicolumn2{l}{\emph{Metavariables}} \\
\midrule
    $v, \; v'$& value \\
    $eq$& equation \\ 
    $\vtempstuck$& a temporarily-stuck equation \\
    $\vfail$& failure \\
    $\rho, \; \rhohat$& environment: $name \rightarrow \mathcal{V}_{\bot}$ \\
    $\mathcal{T}$& Context of all temporarily stuck equations (a sequence) \\ 
    $e$& An expression \\ 
    $ge$& A guarded expression \\
\bottomrule
\end{tabular}    

\bigskip

\begin{tabular}{ll}
    \toprule
        \multicolumn2{l}{\emph{Sequences}} \\
    \midrule
        $\emptyseq$& the empty sequence \\
        $S_1 \cdot S_2 $&  Concatenate sequence $S_1$ and sequence $S_2$ \\
        $x \cdot S_2 $& Cons $x$ onto sequence $S_2$ \\
    \bottomrule
    \end{tabular}    
    
    \medskip
    
    \subsection{Equations}
    
    An \emph{equation} is added to the context of equations temporarily stuck
    equations or produces \vreject. 


    \mkjudgementcmd{EquationSuccess}{\vtuple{\rho, eq}}{\rhohat REMOVE THIS}
    \mkjudgementcmd{EquationTempStuck}{\vtuple{\rho, eq}}{\vtempstuck}
    \mkjudgementcmd{EquationReject}{\vtuple{\rho, eq}}{\vreject}

    % \showvjudgement{EquationSuccess}{\EquationSuccess}
    \showvjudgement{EquationTempStuck}{\EquationTempStuck}
    \showvjudgement{EquationReject}{\EquationReject}
    
    
    \newcommand{\EvalSucc}[1][v] {{\vtuple{\rho, e}}%
    \Downarrow #1} 
    \mkevaljudgementcmd{EvalFail}{\vtuple{\rho, e}}{\emptyseq}
    \newcommand{\EvalGeSucc}[1][\rho] {{\vtuple{#1, \vtempstucks, ge}}%
                                        \Downarrow v} 
    \mkevaljudgementcmd{EvalGeFail}{\vtuple{\rho, \vtempstucks, ge}}{\emptyseq} 
    \mkjudgementcmd{CtxToRho}{\vtuple{\rho, \vtempstuck \cdot%
    \vtempstucks}}{\vtuple{\rhohat, \vtempstucks}}


% Success only refines the environment; that~is, when
% ${\vtuple{\rho, e}} \rightarrowtail{} {\rho'}$, we~expect $\rho \subseteq \rho'$.


\subsection{Expressions}

    An expression either evaluates to produce a sequence of values or fails. 
    Failure is indicated by the empty sequence $\emptyseq$. 


    \showvjudgement{EvalSucc}{\EvalSucc}
    \showvjudgement{EvalFail}{\EvalFail}
    \showvjudgement{EvalGeSucc}{\EvalGeSucc}
    \showvjudgement{EvalGeFail}{\EvalGeFail}

\subsection{Temporarily stuck equations}


    \showvjudgement{CtxToRho}{\CtxToRho}

\bigskip






\section{Sequences}

The trivial sequence is \emptyseq. Sequences can be concatenated with infix 
$\cdot$. In an appropriate context, a value like $x$ stands for 
the singleton sequence containing $x$. 

\begin{align*}
    \emptyseq \cdot \ys &\equiv \ys \\
    \ys \cdot \emptyseq &\equiv \ys \\
    (\xs \cdot \ys) \cdot \zs &\equiv \xs \cdot (\ys \cdot \zs)
\end{align*}

\section{Rules (Big-step Operational Semantics) for $V^{-}$:}
    
\mkevaljudgementcmd{GeEqCtxEval}{\vtuple{\rho, \vtempstucks \cdot eq \cdot \vtempstucks, ge}}{v}

\newcommand\GeCtxStuckRule[1][Left]{%
\inferrule*[#1=\textsc{ (Ge-Ctx-Stuck) }]
    {\inferrule*{}{\EquationTempStuck} 
    \and
    \inferrule*{}{\CtxToRho}
    \and 
    \inferrule*{}{\EvalGeSucc[\rhohat]}
    }
    {\GeEqCtxEval}
}

\mpar{\GeCtxStuckRule}

% \begin{mathpar}
%     \inferrule*[Left=\textsc{ (Ge-Ctx-Stuck) }]
%     {\inferrule*{\EquationTempStuck}{\CtxToRho}
%     \and 
%     \inferrule*{}{\EvalGeSucc}
%     }
%     {\GeEqCtxEval}
% \end{mathpar}

% Which of the above two do you prefer? 

\nr{The notation below has multiple horizontal lines.  That makes it a
derivation, not a rule.  I'm having trouble figuring out what's being
said here.}



\mkevaljudgementcmd{GeCtxEqEval}{\vtuple{\rho, \vtempstucks, eq; ge}}{v}

\newcommand\GeEqStuckRule{%
\inferrule*[Left=\textsc{ (Ge-Eq-Succ) }]
{\GeCtxStuckRule[Right]}
{\GeCtxEqEval}
}

\mpar{\GeEqStuckRule}

\nr{If you're trying to pluck an equation out of a list of things, try
``$\vtempstucks \cdot \eq \cdot \vtempstucks'$.''}

% Gotta fix the stacking. 

\newcommand\GeCtxSuccRule[1][Left]{%
\inferrule*[#1=\textsc{ (Ge-Ctx-Succ) }]
    {\inferrule*{}{\EquationSuccess} 
    \and 
    \inferrule*{}{\EvalGeSucc[\rhohat]}
    }
    {\GeEqCtxEval}
}

\mpar{\GeCtxSuccRule}


\newcommand\GeEqSuccRule{%
\inferrule*[Left=\textsc{ (Ge-Eq-Succ) }]
    {\inferrule*{}{\GeCtxSuccRule[Right]} 
    }
    {\GeCtxEqEval}
}

\mpar{\GeEqSuccRule}


\mkevaljudgementcmd{GeEqCtxEvalFail}{\vtuple{\rho, eq \cdot \vtempstucks, ge}}{\vfail}
\mkevaljudgementcmd{GeCtxEqEvalFail}{\vtuple{\rho, \vtempstucks, eq; ge}}{\vfail}

\newcommand\GeCtxFailRule[1][Left]{%
\inferrule*[#1=\textsc{ (Ge-Ctx-Fail) }]
    {\inferrule*{}{\EquationReject} 
    }
    {\GeEqCtxEvalFail}
}

    \mpar{\GeCtxFailRule}

\newcommand\GeEqFailRule{%
\inferrule*[Left=\textsc{ (Ge-Eq-Fail) }]
    {\inferrule*{}{\GeCtxFailRule[Right]} 
    }
    {\GeCtxEqEvalFail}
}

\mpar{\GeEqFailRule}

\mkevaljudgementcmd{GeExpSucc}{\vtuple{\rho, \vtempstucks, e; ge}}{v}
\mkevaljudgementcmd{GeExpFail}{\vtuple{\rho, \vtempstucks, e; ge}}{\vfail}

\newcommand\GeExpFailRule{%
\inferrule*[Left=\textsc{ (Ge-Exp-Fail) }]
    {\EvalSucc[\vfail]}
    {\GeExpFail}
}

\mpar{\GeExpFailRule}

\newcommand\GeExpSuccRule{%
\inferrule*[Left=\textsc{ (Ge-Eq-Succ) }]
    {\EvalSucc[v']
    \and 
    \EvalGeSucc}
    {\GeExpSucc}
}

\mpar{\GeExpSuccRule}




% \begin{mathpar}
% \inferrule*[Left=\textsc{Ge-Ctx-Stuck}]
%     {\inferrule*[Left=\textsc{FormalVar}]
%       {\texttt{x} \in dom \rho}
%       {\evalr{\textsc{var}(\texttt{x})} \Downarrow \evalr{1}}
%      \and 1 \neq 0 \and
%      \inferrule*[Right=\textsc{Literal}]
%        {\EvalGeSucc}
%        {\evalr{\textsc{lit}(\texttt{2})} \Downarrow \evalr{2}} 
%     }
%     {\GeCtxStuck}
% \end{mathpar}

% \begin{mathpar}
%   \inferrule*[Left=\textsc{IfTrue}]
%     {\inferrule*[Left=\textsc{FormalVar}]
%       {\texttt{x} \in dom \rho}
%       {\evalr{\textsc{var}(\texttt{x})} \Downarrow \evalr{1}}
%      \and 1 \neq 0 \and
%      \inferrule*[Right=\textsc{Literal}]
%        {\ }
%        {\evalr{\textsc{lit}(\texttt{2})} \Downarrow \evalr{2}} 
%     }
%     {\evalr{\textsc{if}(\textsc{var}(\texttt{x}), 
%                         \textsc{lit}(\texttt{2}),
%                         \textsc{lit}(\texttt{3}))}
%      \Downarrow \evalr{2} 
%     }
%   \end{mathpar}

% A series of equations is either is solved to produce a value or gets stuck. 
% A single sub-equation of the form x = e , where eq is an equation or an
% expression, either is solved to produce an environment or gets stuck. 

% An equation x = e can only be solved if e contains no unbound logical variables. 

% \it{In progress}
% $$
% (\tt{if} \; \tt{fi}) \triangleq (\tt{wrong})
% $$

\end{document}
