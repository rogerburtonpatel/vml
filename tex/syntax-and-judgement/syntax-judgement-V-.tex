\documentclass[]{article}
\usepackage{vmlmacros}
\usepackage{syntax}
\usepackage{relsize}
\usepackage{palatino}

% \setlength{\grammarparsep}{20pt plus 1pt minus 1pt} % increase separation between rules
\setlength{\grammarindent}{10em} % increase separation between LHS/RHS

\newcommand{\solve}{\tt{<->}}

\setlength{\parindent}{0cm}
\title{A Syntax of $V^{-}$}
\author{Roger Burtonpatel}
\date{October 22, 2023}
\begin{document}

\maketitle

We present a grammar of $V^{-}$: 

\bigskip


% Integers \hspace{1cm} $k$ \\
% Variables \hspace{.45cm} $x, y, z, f, g$ \\
% Programs \hspace{1cm} $p ::= \bf{one} \{ e \}$, where \ppl{fvs} $e = \emptyset$ \\
% Expressions $e ::= v \; \vert \; eq \ppl{;} \; e$ 
% Values \hspace{1cm} $v ::= x \;\vert\; hnf$ 
% Head Values \hspace{1cm} $hnf ::= k \;\vert\; op \;\vert\; \lambda x.\;e$ 

\begin{grammar}
    <program> ::= \{<def>\}
    
    <def> ::= val <name> <exp>
        \alt <exp>
    
    <name> ::= any token that is not an \textit{int-lit}, does not contain 
    whitespace,
    % a \texttt{'}, bracket, or parenthesis, 
    and is not a <value-constructor-name> or a reserved word.
    <value-constructor-name> ::= \tt{cons} | 
    <exp> ::= <integer-literal>
        \alt <name>
        \alt <name>
        \alt <guarded-if>
        \alt <lambda>

    <integer-literal> ::= token composed only of digits, possibly prefixed with a \texttt{+} or \texttt{-}.

    <lambda> ::= $\lambda$\{<name>\}\tt{.} <exp>

    <guarded-if> ::= \tt{if}  [<guarded-exp> \{ [] <guarded-exp> \}] \tt{fi}


    <guarded-exp> ::= <exp>
    \alt  \tt{E} \{<logical-var>\}\tt{.} <guarded-exp>
    \alt  <exp>\tt{;} <guarded-exp>
    \alt   <logical-var> \tt{=} <exp>\tt{;} <guarded-exp>
    \alt   <exp> \tt{=} <exp>\tt{;} <guarded-exp>
    \alt   <guarded-exp> | <guarded-exp>
    \alt   \tt{one}(\{<guarded-exp>\})
    \alt   \tt{all}(\{<guarded-exp>\})

    <logical-var> ::= a fresh name (cannot be \tt{lam}- or \tt{E}-bound in
    this scope).

\end{grammar}

Add patterns, value constructors (application), choice, one, all. 

% A $\star$ indicates syntactic sugar. 

% The desugaring of a multi-name \tt{E}
% is:


% $$\tt{E} \; lv_1 \tt{.} \; \dots \; \langle guarded\rm{-}exp \rangle \;
% \triangleq \; \tt{E} \; lv_1 \tt{.} \; \tt{E} \tt{.} \; \dots \; \langle
    % guarded\rm{-}exp \rangle  $$
    
    
    \section{Forms of Judgement for $V^{-}$:}
    
    \it{Metavariables:} \\
    $v, \; v': $ value \\
    $eq: $ equation \\ 
    $\vtempstuck:$ a temporarily-stuck equation \\
    $\vfail:$ failure \\
    $\rho, \; \rhohat:$ environment: $name \rightarrow \mathcal{V}_{\bot}$ \\
    $\mathcal{T}: $ Context of all temporarily stuck equations \\ 
    $e:$ An expression \\ 
    $ge:$ A guarded expression \\
    
    \it{Forms of judgement on equations:} 

    \mkjudgementcmd{EquationSuccess}{\vtuple{\rho, eq}}{\rhohat}
    \mkjudgementcmd{EquationTempStuck}{\vtuple{\rho, eq}}{\vtempstuck}
    \mkjudgementcmd{EquationFail}{\vtuple{\rho, eq}}{\vfail}
    \newcommand{\EvalSucc}[1][v] {{\vtuple{\rho, e}}%
    \Downarrow #1} 
    \mkevaljudgementcmd{EvalFail}{\vtuple{\rho, e}}{\vfail}
    \newcommand{\EvalGeSucc}[1][\rho] {{\vtuple{#1, \vtempstucks, ge}}%
                                        \Downarrow v} 
    \mkevaljudgementcmd{EvalGeFail}{\vtuple{\rho, \vtempstucks, ge}}{\vfail} 
    \mkjudgementcmd{CtxToRho}{\vtuple{\rho, \vtempstuck;%
    \vtempstucks}}{\vtuple{\rhohat, \vtempstucks}}

    \showvjudgement{EquationSuccess}{\EquationSuccess}
    \showvjudgement{EquationTempStuck}{\EquationTempStuck}
    \showvjudgement{EquationFail}{\EquationFail}

    \it{Forms of judgement on expressions:}


    \showvjudgement{EvalSucc}{\EvalSucc}
    \showvjudgement{EvalFail}{\EvalFail}
    \showvjudgement{EvalGeSucc}{\EvalGeSucc}
    \showvjudgement{EvalGeFail}{\EvalGeFail}

    \it{Other forms:}

    \showvjudgement{CtxToRho}{\CtxToRho}

    In english: 
    
    An equation is either solved to produce bindings that extend an environemnt,
    gets temporarily stuck, or fails. 

    An expression either evaluates to produce a value or fails. 

    \bigskip
    
    Other important guidelines (where do we put these?):
    
$$\rho \subseteq \rho'$$
$$ \rm{when dom } \rho \subseteq \rm{dom } \rho'$$
$$ \rm{and } \forall x \in \rm{dom } \rho: \rho(x) \subseteq \rho'(x)$$

\bigskip

When ${\vtuple{\rho, e}} \rightarrowtail{} {\rho'}$, then $\rho \subseteq \rho'$.

\bigskip

\section{Rules (Big-step Operational Semantics) for $V^{-}$:}

    
\mkevaljudgementcmd{GeEqCtxEval}{\vtuple{\rho, eq; \vtempstucks, ge}}{v}

\newcommand\GeCtxStuckRule[1][Left]{%
\inferrule*[#1=\textsc{ (Ge-Ctx-Stuck) }]
    {\inferrule*{}{\EquationTempStuck} 
    \and
    \inferrule*{}{\CtxToRho}
    \and 
    \inferrule*{}{\EvalGeSucc}
    }
    {\GeEqCtxEval}
}

\mpar{\GeCtxStuckRule}

% \begin{mathpar}
%     \inferrule*[Left=\textsc{ (Ge-Ctx-Stuck) }]
%     {\inferrule*{\EquationTempStuck}{\CtxToRho}
%     \and 
%     \inferrule*{}{\EvalGeSucc}
%     }
%     {\GeEqCtxEval}
% \end{mathpar}

% Which of the above two do you prefer? 

\mkevaljudgementcmd{GeCtxEqEval}{\vtuple{\rho, \vtempstucks, eq; ge}}{v}

\newcommand\GeEqStuckRule{%
\inferrule*[Left=\textsc{ (Ge-Eq-Succ) }]
{\GeCtxStuckRule[Right]}
{\GeCtxEqEval}
}

\mpar{\GeEqStuckRule}

% Gotta fix the stacking. 

\newcommand\GeCtxSuccRule{%
\inferrule*[Left=\textsc{ (Ge-Ctx-Succ) }]
    {\inferrule*{}{\EquationSuccess} 
    \and 
    \inferrule*{}{\EvalGeSucc[\rhohat]}
    }
    {\GeEqCtxEval}
}

\mpar{\GeCtxSuccRule}


\newcommand\GeEqSuccRule{%
\inferrule*[Left=\textsc{ (Ge-Eq-Succ) }]
    {\inferrule*{}{\GeCtxSuccRule[Right]} 
    }
    {\GeCtxEqEval}
}

\mpar{\GeEqSuccRule}


\mkevaljudgementcmd{GeEqCtxEvalFail}{\vtuple{\rho, eq; \vtempstucks, ge}}{\vfail}
\mkevaljudgementcmd{GeCtxEqEvalFail}{\vtuple{\rho, \vtempstucks, eq; ge}}{\vfail}

\newcommand\GeCtxFailRule[1][Left]{%
\inferrule*[#1=\textsc{ (Ge-Ctx-Fail) }]
    {\inferrule*{}{\EquationFail} 
    }
    {\GeEqCtxEvalFail}
}

    \mpar{\GeCtxFailRule}

\newcommand\GeEqFailRule{%
\inferrule*[Left=\textsc{ (Ge-Eq-Fail) }]
    {\inferrule*{}{\GeCtxFailRule[Right]} 
    }
    {\GeCtxEqEvalFail}
}

\mpar{\GeEqFailRule}

\mkevaljudgementcmd{GeExpSucc}{\vtuple{\rho, \vtempstucks, e; ge}}{v}
\mkevaljudgementcmd{GeExpFail}{\vtuple{\rho, \vtempstucks, e; ge}}{\vfail}

\newcommand\GeExpFailRule{%
\inferrule*[Left=\textsc{ (Ge-Exp-Fail) }]
    {\EvalSucc[\vfail]}
    {\GeExpFail}
}

\mpar{\GeExpFailRule}

\newcommand\GeExpSuccRule{%
\inferrule*[Left=\textsc{ (Ge-Eq-Succ) }]
    {\EvalSucc[v']
    \and 
    \EvalGeSucc}
    {\GeExpSucc}
}

\mpar{\GeExpSuccRule}




% \begin{mathpar}
% \inferrule*[Left=\textsc{Ge-Ctx-Stuck}]
%     {\inferrule*[Left=\textsc{FormalVar}]
%       {\texttt{x} \in dom \rho}
%       {\evalr{\textsc{var}(\texttt{x})} \Downarrow \evalr{1}}
%      \and 1 \neq 0 \and
%      \inferrule*[Right=\textsc{Literal}]
%        {\EvalGeSucc}
%        {\evalr{\textsc{lit}(\texttt{2})} \Downarrow \evalr{2}} 
%     }
%     {\GeCtxStuck}
% \end{mathpar}

% \begin{mathpar}
%   \inferrule*[Left=\textsc{IfTrue}]
%     {\inferrule*[Left=\textsc{FormalVar}]
%       {\texttt{x} \in dom \rho}
%       {\evalr{\textsc{var}(\texttt{x})} \Downarrow \evalr{1}}
%      \and 1 \neq 0 \and
%      \inferrule*[Right=\textsc{Literal}]
%        {\ }
%        {\evalr{\textsc{lit}(\texttt{2})} \Downarrow \evalr{2}} 
%     }
%     {\evalr{\textsc{if}(\textsc{var}(\texttt{x}), 
%                         \textsc{lit}(\texttt{2}),
%                         \textsc{lit}(\texttt{3}))}
%      \Downarrow \evalr{2} 
%     }
%   \end{mathpar}

% A series of equations is either is solved to produce a value or gets stuck. 
% A single sub-equation of the form x = e , where eq is an equation or an
% expression, either is solved to produce an environment or gets stuck. 

% An equation x = e can only be solved if e contains no unbound logical variables. 

% \it{In progress}
% $$
% (\tt{if} \; \tt{fi}) \triangleq (\tt{wrong})
% $$

\end{document}