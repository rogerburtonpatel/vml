\documentclass[]{article}
\usepackage{vmlmacros}
\usepackage{syntax}
\usepackage{relsize}
\usepackage{palatino}
\usepackage{amsmath}
\usepackage{booktabs}
\setcounter{secnumdepth}{1}

\DeclareMathOperator{\dom}{dom}


% Docket: move relevant macros to macros file. 
\newcommand{\bracketed}[1]{\{#1\}}

% \setlength{\grammarparsep}{20pt plus 1pt minus 1pt} % increase separation between rules
\setlength{\grammarindent}{10em} % increase separation between LHS/RHS

\newcommand\nr[1]{\leavevmode\emph{NR: #1}}
\newcommand\rab[1]{\leavevmode\emph{rab: #1}}
\newcommand\vfilbreak[1][1in]{\vskip 0pt plus #1\penalty-200 \vskip 0pt plus -#1}

\setlength{\parindent}{0cm}
\title{Syntax and Semantics of $V^{-}$}
\author{Roger Burtonpatel}
\date{October 22, 2023}
\begin{document}

\maketitle

\section{Syntax}

\nr{I recommend macros for optional and sequence, not literal brackets.} \\
\rab{Despite my best efforts, such a macro does not work in grammar mode.} \\
We present a grammar of $V^{-}$: 

\bigskip

% Integers \hspace{1cm} $k$ \\
% Variables \hspace{.45cm} $x, y, z, f, g$ \\
% Programs \hspace{1cm} $p ::= \bf{one} \{ e \}$, where \ppl{fvs} $e = \emptyset$ \\
% Expressions $e ::= v \; \vert \; eq \ppl{;} \; e$ 
% Values \hspace{1cm} $v ::= x \;\vert\; hnf$ 
% Head Values \hspace{1cm} $hnf ::= k \;\vert\; op \;\vert\; \lambda x.\;e$ 

\begin{grammar}
    <program> ::= \{{<def>}\}
    
    <def> ::= \tt{val} <name> <exp>
        \alt <exp>
    
        
        
        <exp> ::= <integer-literal>
        \alt <name>
        \alt <guarded-if>
        \alt <lambda>
        \alt <value-constructor-name> \{<exp>\}
        \alt <exp> <exp>
        \alt <exp> $\choice$ <exp>
        
        
        <lambda> ::= $\lambda$\{<name>\}\tt{.} <exp>
        
        <guarded-if> ::= \tt{if}  [<guarded-exp> \{ [] <guarded-exp> \}] \tt{fi}
        
        
        <guarded-exp> ::= $\boldsymbol{\rightarrow}$<exp>
        \alt  \tt{E} \{<name>\}\tt{.} <guarded-exp>
        \alt  <exp>\tt{;} <guarded-exp>
        \alt   <name> \tt{=} <exp>\tt{;} <guarded-exp>
        \alt   <exp> \tt{=} <exp>\tt{;} <guarded-exp>
        \alt   <guarded-exp> $\choice$ <guarded-exp> 
        \alt   \tt{one}(\{<guarded-exp>\})
        \alt   \tt{all}(\{<guarded-exp>\})
        
        <name> ::= any token that is not an \textit{int-lit}, does not contain 
        whitespace,
        % a \texttt{'}, bracket, or parenthesis, 
        and is not a <value-constructor-name> or a reserved word.

        <value-constructor-name> ::= \cons | \tt{[]} | any token that begins
        with a capital letter or a colon
    
        <integer-literal> ::= token composed only of digits, possibly prefixed with a \texttt{+} or \texttt{-}.
    
    \end{grammar}

% A $\star$ indicates syntactic sugar. 

% The desugaring of a multi-name \tt{E}
% is:


% $$\tt{E} \; lv_1 \tt{.} \; \dots \; \langle guarded\rm{-}exp \rangle \;
% \triangleq \; \tt{E} \; lv_1 \tt{.} \; \tt{E} \tt{.} \; \dots \; \langle
    % guarded\rm{-}exp \rangle  $$
        
\section{Refinement ordering on environments}

\begin{align*}
\rho \subseteq \rho' \text{ when }&\dom\rho  \subseteq \dom \rho'\\
\text{ and } &\forall x \in \dom \rho: \rho(x) \subseteq \rho'(x)
\end{align*}



\vfilbreak



\section{Forms of Judgement for $V^{-}$:}
\begin{tabular}{ll}
\toprule
    \multicolumn2{l}{\emph{Metavariables}} \\
\midrule
    % $v, \; v'$& value \\
    $\vbar$& a (possibly empty) sequence of values. \\
    $eq$& equation \\ 
    % $\tempstuck$& a temporarily-stuck equation \\
    $\reject$& equation rejection \\
    $\result$& $\vbar \mid$ reject : a result of a sequence of values or
    rejection\\
    $\rho$& environment: $name \rightarrow \mathcal{V}_{\bot}$ \\
    $\rho\{ x \mapsto y \} $& environment extended with name $x$ mapping to $y$ \\
    $\mathcal{T}$& Context of all temporarily stuck equations (a sequence) \\ 
    $e$& An expression \\ 
    $g$& A guarded expression \\
\bottomrule
\end{tabular}    

\bigskip

\begin{tabular}{ll}
    \toprule
        \multicolumn2{l}{\emph{Sequences}} \\
    \midrule
        $\emptyseq$& the empty sequence \\
        $S_1 \cdot S_2 $&  Concatenate sequence $S_1$ and sequence $S_2$ \\
        $x \cdot S_2 $& Cons $x$ onto sequence $S_2$ \\
    \bottomrule
    \end{tabular}    
    
    \medskip
    
    \mkjudgementcmd{EquationSuccess}{\vtuple{\rho, eq}}{\rhohat REMOVE THIS}
    \mkjudgementcmd{EquationTempStuck}{\vtuple{\rho, eq}}{\tempstuck}
    \mkjudgementcmd{EquationReject}{\vtuple{\rho, eq}}{reject}

    % \showvjudgement{EquationSuccess}{\EquationSuccess}
    % \showvjudgement{EquationTempStuck}{\EquationTempStuck}
    % \showvjudgement{EquationReject}{\EquationReject}
    
    
    
    
    % Success only refines the environment; that~is, when
    % ${\vtuple{\rho, e}} \rightarrowtail{} {\rho'}$, we~expect $\rho \subseteq \rho'$.
    
    
\subsection{Expressions}

    
    \mkevaljudgementcmd{EvalE}{\vctx[]}{\vbar}
    \mkevaljudgementcmd{EvalGe}{\vctx[Expr=g]}{\result}
    An expression evaluates to produce possibly-empty sequence of values.

    A guarded expression evaluates to produce a \bf{result}. A result is either
    a possibly-empty sequence of values or reject. 

    \[\it{r} \; \rm{::=} \; \vbar \;|\; \fail \]

    \showvjudgement{Eval-Expr}{\EvalE}
    \showvjudgement{Eval-Guarded-Expr}{\EvalGe}

\bigskip


\section{Sequences}

The trivial sequence is \emptyseq. Sequences can be concatenated with infix 
$\cdot$. In an appropriate context, a value like $x$ stands for 
the singleton sequence containing $x$. 

\begin{align*}
    \emptyseq \cdot \ys &\equiv \ys \\
    \ys \cdot \emptyseq &\equiv \ys \\
    (\xs \cdot \ys) \cdot \zs &\equiv \xs \cdot (\ys \cdot \zs)
\end{align*}

\section{Rules (Big-step Operational Semantics) for $V^{-}$:}
    
\subsection{Evaluating Guarded Expressions}

\[
\inferrule*[Left=\textsc{ (Eval-ArrowExpr) }]
    {\veval{e}{\vbar}}
    {\vgctx[Tempstucks=\emptyseq, Expr=\arrowe] 
    \Downarrow \vbar}
\]

\[
\inferrule*[Left=\textsc{ (Eval-Exists) }]
    {\vgctx[Rho=\rho\{x \mapsto \bot \}] \Downarrow \result}
    {\vgctx[Expr=\exists x.\; g] 
    \Downarrow \result}
\]

\[
\inferrule*[Left=\textsc{ (G-Eval-With-Ctx) }]
    {\ }
    {\vgctx[Tempstucks=\TeqT] 
    \Downarrow \result}
\]

\[
\inferrule*[Left=\textsc{ (G-Move-To-Ctx) }]
    {\inferrule*{\vgctx[Tempstucks=eq \cdot \tempstucks] 
                 \Downarrow \result}{}
    }
    {\vctx[Expr=eq; \; g] \Downarrow \result}
\]

\subsection{Evaluating General Expressions}


\[
\inferrule*[Left=\textsc{ (If-Fi-Fail) }]
    {\ }
    {\veval{\iffi{\ }}{\emptyseq}}
\]

\[
\inferrule*[Left=\textsc{ (If-Fi-Success) }]
    {\vgctx[Tempstucks=\emptyseq] \Downarrow \vbar}
    {\veval{\iffi{g \; \square \; \dots}}{\vbar}}
\]

\[
\inferrule*[Left=\textsc{ (If-Fi-Reject) }]
    {\inferrule*[] {}
    {\vgctx[Tempstucks=\emptyseq] \Downarrow \reject}
    \and 
    \veval{\iffi{\dots}}{\vbar}}
    {\veval{\iffi{g \; \square \; \dots }}{\vbar}}
\]


% % \begin{mathpar}
% %     \inferrule*[Left=\textsc{ (G-Ctx-Stuck) }]
% %     {\inferrule*{\EquationTempStuck}{\CtxToRho}
% %     \and 
% %     \inferrule*{}{\EvalGeSucc}
% %     }
% %     {\GeEqCtxEval}
% % \end{mathpar}

% % Which of the above two do you prefer? 

% \nr{The notation below has multiple horizontal lines.  That makes it a
% derivation, not a rule.  I'm having trouble figuring out what's being
% said here.}



% \mkevaljudgementcmd{GeCtxEqEval}{\vtuple{\rho, \tempstucks, eq; g}}{v}

% \newcommand\GeEqStuckRule{%
% \inferrule*[Left=\textsc{ (G-Eq-Succ) }]
% {\GeCtxStuckRule[Right]}
% {\GeCtxEqEval}
% }

% \mpar{\GeEqStuckRule}

% \nr{If you're trying to pluck an equation out of a list of things, try
% ``$\tempstucks \cdot \eq \cdot \tempstucks'$.''}

% % Gotta fix the stacking. 

% \newcommand\GeCtxSuccRule[1][Left]{%
% \inferrule*[#1=\textsc{ (G-Ctx-Succ) }]
%     {\inferrule*{}{\EquationSuccess} 
%     \and 
%     \inferrule*{}{\EvalGeSucc[\rhohat]}
%     }
%     {\GeEqCtxEval}
% }

% \mpar{\GeCtxSuccRule}


% \newcommand\GeEqSuccRule{%
% \inferrule*[Left=\textsc{ (G-Eq-Succ) }]
%     {\inferrule*{}{\GeCtxSuccRule[Right]} 
%     }
%     {\GeCtxEqEval}
% }

% \mpar{\GeEqSuccRule}


% \mkevaljudgementcmd{GeEqCtxEvalFail}{\vtuple{\rho, eq \cdot \tempstucks, g}}{\fail}
% \mkevaljudgementcmd{GeCtxEqEvalFail}{\vtuple{\rho, \tempstucks, eq; g}}{\fail}

% \newcommand\GeCtxFailRule[1][Left]{%
% \inferrule*[#1=\textsc{ (G-Ctx-Fail) }]
%     {\inferrule*{}{\EquationReject} 
%     }
%     {\GeEqCtxEvalFail}
% }

%     \mpar{\GeCtxFailRule}

% \newcommand\GeEqFailRule{%
% \inferrule*[Left=\textsc{ (G-Eq-Fail) }]
%     {\inferrule*{}{\GeCtxFailRule[Right]} 
%     }
%     {\GeCtxEqEvalFail}
% }

% \mpar{\GeEqFailRule}

% \mkevaljudgementcmd{GeExpSucc}{\vtuple{\rho, \tempstucks, e; g}}{v}
% \mkevaljudgementcmd{GeExpFail}{\vtuple{\rho, \tempstucks, e; g}}{\fail}

% \newcommand\GeExpFailRule{%
% \inferrule*[Left=\textsc{ (G-Exp-Fail) }]
%     {\EvalSucc[\fail]}
%     {\GeExpFail}
% }

% \mpar{\GeExpFailRule}

% \newcommand\GeExpSuccRule{%
% \inferrule*[Left=\textsc{ (G-Eq-Succ) }]
%     {\EvalSucc[v']
%     \and 
%     \EvalGeSucc}
%     {\GeExpSucc}
% }

% \mpar{\GeExpSuccRule}




% % \begin{mathpar}
% % \inferrule*[Left=\textsc{G-Ctx-Stuck}]
% %     {\inferrule*[Left=\textsc{FormalVar}]
% %       {\texttt{x} \in dom \rho}
% %       {\evalr{\textsc{var}(\texttt{x})} \Downarrow \evalr{1}}
% %      \and 1 \neq 0 \and
% %      \inferrule*[Right=\textsc{Literal}]
% %        {\EvalGeSucc}
% %        {\evalr{\textsc{lit}(\texttt{2})} \Downarrow \evalr{2}} 
% %     }
% %     {\GeCtxStuck}
% % \end{mathpar}

% % \begin{mathpar}
% %   \inferrule*[Left=\textsc{IfTrue}]
% %     {\inferrule*[Left=\textsc{FormalVar}]
% %       {\texttt{x} \in dom \rho}
% %       {\evalr{\textsc{var}(\texttt{x})} \Downarrow \evalr{1}}
% %      \and 1 \neq 0 \and
% %      \inferrule*[Right=\textsc{Literal}]
% %        {\ }
% %        {\evalr{\textsc{lit}(\texttt{2})} \Downarrow \evalr{2}} 
% %     }
% %     {\evalr{\textsc{if}(\textsc{var}(\texttt{x}), 
% %                         \textsc{lit}(\texttt{2}),
% %                         \textsc{lit}(\texttt{3}))}
% %      \Downarrow \evalr{2} 
% %     }
% %   \end{mathpar}

% % A series of equations is either is solved to produce a value or gets stuck. 
% % A single sub-equation of the form x = e , where eq is an equation or an
% % expression, either is solved to produce an environment or gets stuck. 

% % An equation x = e can only be solved if e contains no unbound logical variables. 

% % \it{In progress}
% % $$
% % (\tt{if} \; \tt{fi}) \triangleq (\tt{wrong})
% % $$

\end{document}
