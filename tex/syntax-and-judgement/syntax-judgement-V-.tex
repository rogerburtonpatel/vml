\documentclass[]{article}
\usepackage{vmlmacros}
\usepackage{syntax}
\usepackage{relsize}

% \setlength{\grammarparsep}{20pt plus 1pt minus 1pt} % increase separation between rules
\setlength{\grammarindent}{10em} % increase separation between LHS/RHS

\newcommand{\solve}{\tt{<->}}

\setlength{\parindent}{0cm}
\title{A Syntax of $V^{-}$}
\author{Roger Burtonpatel}
\date{October 22, 2023}
\begin{document}

\maketitle

We present a grammar of $V^{-}$: 

\bigskip


\begin{grammar}
    <program> ::= \{<def>\}
    
    <def> ::= val <name> <exp>
        \alt <exp>
    
    <name> ::= any token that is not an \textit{int-lit}, does not contain 
    whitespace,
    % a \texttt{'}, bracket, or parenthesis, 
    and is not a <value-constructor-name> or a reserved word.
    <value-constructor-name> ::= \tt{cons} | 
    <exp> ::= <integer-literal>
        \alt <name>
        \alt <name>
        \alt <guarded-if>
        \alt <lambda>

    <integer-literal> ::= token composed only of digits, possibly prefixed with a \texttt{+} or \texttt{-}.

    <lambda> ::= $\lambda$\{<name>\}\tt{.} <exp>

    <guarded-if> ::= \tt{if}  [<guarded-exp> \{ [] <guarded-exp> \}] \tt{fi}


    <guarded-exp> ::= <exp>
    \alt  \tt{E} \{<logical-var>\}\tt{.} <guarded-exp>
    \alt  <exp>\tt{;} <guarded-exp>
    \alt   <logical-var> \tt{=} <exp>\tt{;} <guarded-exp>
    \alt   <exp> \tt{=} <exp>\tt{;} <guarded-exp>
    \alt   <guarded-exp> | <guarded-exp>

    <logical-var> ::= a fresh name (cannot be \tt{lam}- or \tt{E}-bound in
    this scope).

\end{grammar}

Add patterns, value constructors (application), choice, one, all. 

% A $\star$ indicates syntactic sugar. 

% The desugaring of a multi-name \tt{E}
% is:


% $$\tt{E} \; lv_1 \tt{.} \; \dots \; \langle guarded\rm{-}exp \rangle \;
% \triangleq \; \tt{E} \; lv_1 \tt{.} \; \tt{E} \tt{.} \; \dots \; \langle
    % guarded\rm{-}exp \rangle  $$
    
    
    \section{Forms of Judgement for $V^{-}$:}
    
    $$\rho: name \rightarrow \mathcal{V}_{\bot}$$
    
    \begin{mathpar}
        \inferrule*[Left=\textsc{EquationSuccess}]{}
        {\vjudgement{\vjtuple{\rho, eq}}{\rhohat}}
    \end{mathpar}
    
    \begin{mathpar}
        \inferrule*[Left=\textsc{EquationTempStuck}]{}
        {\vjudgement{\vjtuple{\rho, eq}}{\vtempstuck}}
    \end{mathpar}
    
    \begin{mathpar}
        \inferrule*[Left=\textsc{EquationFail}]{}
        {\vjudgement{\vjtuple{\rho, eq}}{\vfail}}
    \end{mathpar}
    
    % $$\vjudgement[eq] \goesto{} \vtempstuck$$ 
    
    % $$\vjudgement[eq] \goesto{} \vfail $$
    In english: 
    
    An equation is either solved to produce bindings that extend an environemnt,
    gets temporarily stuck, or fails. 

    \bigskip
    
    Other important guidelines (where do we put these?):
    
    $$\rho \subseteq \rho'$$
$$ \rm{when dom } \rho \subseteq \rm{dom } \rho'$$
$$ \rm{and } \forall x \in \rm{dom } \rho: \rho(x) \subseteq \rho'(x)$$

\bigskip

When $\vjudgement{\vjtuple{\rho, e}}{\rho'}$, then $\rho \subseteq \rho'$.

\bigskip

\section{Rules for $V^{-}$:}

% \begin{mathpar}
%   \inferrule*[Left=\textsc{IfTrue}]
%     {\inferrule*[Left=\textsc{FormalVar}]
%       {\texttt{x} \in dom \rho}
%       {\evalr{\textsc{var}(\texttt{x})} \Downarrow \evalr{1}}
%      \and 1 \neq 0 \and
%      \inferrule*[Right=\textsc{Literal}]
%        {\ }
%        {\evalr{\textsc{lit}(\texttt{2})} \Downarrow \evalr{2}} 
%     }
%     {\evalr{\textsc{if}(\textsc{var}(\texttt{x}), 
%                         \textsc{lit}(\texttt{2}),
%                         \textsc{lit}(\texttt{3}))}
%      \Downarrow \evalr{2} 
%     }
%   \end{mathpar}

% A series of equations is either is solved to produce a value or gets stuck. 
% A single sub-equation of the form x = e , where eq is an equation or an
% expression, either is solved to produce an environment or gets stuck. 

% An equation x = e can only be solved if e contains no unbound logical variables. 

% \it{In progress}
% $$
% (\tt{if} \; \tt{fi}) \triangleq (\tt{wrong})
% $$

% \bigskip

% \section{Side conditions with \tt{when}}

% The \tt{when} keyword may optionally appear on the rightmost side of a \tt{case}
% branch in \it{P}, within a set of parentheses also containing an expression.
% If the scrutinee matches the pattern, the expression is evaluated. If it 
% evaluates to produce a truthy value, the match succeeds and the right-hand
% side expression is evaluated with the new $\rho'$ produced by the pattern.

% \medskip

% \bf{General concrete syntax of \tt{when}: }

% \begin{verbatim}
%     (case scrutinee
%         [pattern rhs-exp (when condition)])
% \end{verbatim}


% Example: 
% \begin{verbatim}
%     (case v
%         ['() 0]
%         [(cons x xs) (+ 1 (count-evens xs)) (when (= 0 (mod 2 x)))])
% \end{verbatim}

% % \bf{A question about types:}
% % \medskip

% % I had a blurb like this: 

% \medskip

% Note: the \tt{exp} in a \tt{when} is not limited to be a boolean expression, 
% and there is no static type system to assert that it will evaluate to a boolean.
% As in the rest of \it{P}, when an expression evaluates to \tt{\#f}, it
% is considered falsey; otherwise, it is considered truthy. 

% \medskip

% % As I was writing this, I realized uML \it{does}, obviously, have a type system
% % to do exactly this. At the same time, I remember you saying we won't have static
% % types in our languages- which do you want to go off of? 

% \section{Or-patterns with \tt{oneof}}

% \medskip

% ---------


% The \tt{oneof} keyword may optionally appear on the leftmost side of a \tt{case}
% branch in \it{P}, within a set of parentheses also containing the set of 
% patterns for that branch. The set of patterns $S$ is defined as such: if $S$ 
% contains a pattern $p$ and the scrutinee matches $p$, that branch is evaluated
% if the pattern-matching algorithm reaches it. 
% When the match succeeds and the right-hand
% side expression is evaluated with the new $\rho'$ produced by a pattern, only 
% that pattern's fresh variables are introduced into $\rho'$. 

% \medskip

% General concrete syntax of \tt{oneof}: 


% \begin{verbatim}
%     (case scrutinee
%         [(oneof pattern-1 pattern-2 ... pattern-k) rhs-exp])
% \end{verbatim}


% Example: 
% \begin{verbatim}
%     (case light
%         [RED 'stop]
%         [(oneof GREEN YELLOW) 'keep-on-goin])
% \end{verbatim}



% \medskip

% Typed languages with or-patterns, like OCaml, often have the restriction that
% logical variables introduced within a section of an or-pattern must represesent
% values of the same type within all parts of the or-pattern. Because $P$ has no
% static type system, we don't make this assertion: whichever pattern in the
% or-pattern matches will introduce its variables and bindings into the $\rho'$
% with which the right-hand side is evaluated. 

% Example: 
% \begin{verbatim}
%     (case (list2 1 #f)
%         ['() 0]
%         [(oneof (cons 4 x) (cons x 3) (cons x #f)) x]) ;; returns #f
% \end{verbatim}

% \bf{A question about or-patterns and types: }


% The ocaml description of or-patterns is as follows: 

% \medskip

% The pattern $pattern_1 \mid pattern_2$ represents the logical “or” of the two
% patterns $pattern_1$ and $pattern_2$. A value matches $pattern_1 \mid pattern_2$
% if it matches $pattern_1$ or $pattern_2$. The two sub-patterns $pattern_1$ and
% $pattern_2$ must bind exactly the same identifiers to values having the same
% types. Matching is performed from left to right. More precisely, in case some
% value v matches $pattern_1 \mid pattern_2$, the bindings performed are those of
% $pattern_1$ when v matches $pattern_1$. Otherwise, value v matches $pattern_2$
% whose bindings are performed.

% \medskip

% \bf{This is a restriction at the level of the type system.
% Again, do we want strict static types in $P$?}


\end{document}