\documentclass[]{article}
\usepackage{vmlmacros}
\usepackage{syntax}
\usepackage{relsize}
\usepackage{palatino}
\usepackage{amsmath}
\usepackage{booktabs}
\setcounter{secnumdepth}{1}

\DeclareMathOperator{\dom}{dom}


% \setlength{\grammarparsep}{20pt plus 1pt minus 1pt} % increase separation between rules
\setlength{\grammarindent}{10em} % increase separation between LHS/RHS

\newcommand{\solve}{\tt{<->}}

\newcommand\gt{\mathrel{>}}
\newcommand\lt{\mathrel{<}}
\newcommand\nr[1]{\leavevmode\emph{NR: #1}}
\newcommand\vfilbreak[1][1in]{\vskip 0pt plus #1\penalty-200 \vskip 0pt plus -#1}

\newcommand\eq{\ensuremath{\mathit{eq}}}  % equation
\newcommand\emptyseq{\ensuremath{\varepsilon}}

\setlength{\parindent}{0cm}
\title{Syntax and Semantics of $V^{-}$}
\author{Roger Burtonpatel}
\date{October 22, 2023}
\begin{document}

\maketitle

\section{Syntax}

\nr{I recommend macros for optional and sequence, not literal brackets.}

We present a grammar of $V^{-}$: 

\bigskip


% Integers \hspace{1cm} $k$ \\
% Variables \hspace{.45cm} $x, y, z, f, g$ \\
% Programs \hspace{1cm} $p ::= \bf{one} \{ e \}$, where \ppl{fvs} $e = \emptyset$ \\
% Expressions $e ::= v \; \vert \; eq \ppl{;} \; e$ 
% Values \hspace{1cm} $v ::= x \;\vert\; hnf$ 
% Head Values \hspace{1cm} $hnf ::= k \;\vert\; op \;\vert\; \lambda x.\;e$ 

\begin{grammar}
    <program> ::= \{<def>\}
    
    <def> ::= \texttt{val} <name> <exp>
        \alt <exp>
    
    <name> ::= any token that is not an \textit{int-lit}, does not contain 
    whitespace,
    % a \texttt{'}, bracket, or parenthesis, 
    and is not a <value-constructor-name> or a reserved word.

    <value-constructor-name> ::= \tt{cons} | any token that begins
    with a capital letter or a colon

    <exp> ::= <integer-literal>
        \alt <name>
        \alt <guarded-if>
        \alt <lambda>

    <integer-literal> ::= token composed only of digits, possibly prefixed with a \texttt{+} or \texttt{-}.

    <lambda> ::= $\lambda$\{<name>\}\tt{.} <exp>

    <guarded-if> ::= \tt{if}  [<guarded-exp> \{ [] <guarded-exp> \}] \tt{fi}


    <guarded-exp> ::= $\boldsymbol{\rightarrow}$<exp>
    \alt  \tt{E} \{<logical-var>\}\tt{.} <guarded-exp>
    \alt  <exp>\tt{;} <guarded-exp>
    \alt   <logical-var> \tt{=} <exp>\tt{;} <guarded-exp>
    \alt   <exp> \tt{=} <exp>\tt{;} <guarded-exp>
    \alt   <guarded-exp> | <guarded-exp> 
    \alt   \tt{one}(\{<guarded-exp>\})
    \alt   \tt{all}(\{<guarded-exp>\})

    <logical-var> ::= a fresh name (cannot be \tt{lam}- or \tt{E}-bound in
    this scope).

\end{grammar}

\nr{I'm skeptical about some of the forms of guarded expression:}
\begin{itemize}
\item 
Choice doesn't look flexible enough, e.g., to express this:
\begin{align*}
\exists x . (x \lt 0 | x \gt 0) \rightarrow 17
\end{align*}
\item
Unconvinced about \texttt{one} and \texttt{all} here.
Let's see some examples.
\end{itemize}

Add patterns, value constructors (application), choice, one, all. 

% A $\star$ indicates syntactic sugar. 

% The desugaring of a multi-name \tt{E}
% is:


% $$\tt{E} \; lv_1 \tt{.} \; \dots \; \langle guarded\rm{-}exp \rangle \;
% \triangleq \; \tt{E} \; lv_1 \tt{.} \; \tt{E} \tt{.} \; \dots \; \langle
    % guarded\rm{-}exp \rangle  $$
    
    
\section{Refinement ordering on environments}

\begin{align*}
\rho \subseteq \rho' \text{ when }&\dom\rho  \subseteq \dom \rho'\\
\text{ and } &\forall x \in \dom \rho: \rho(x) \subseteq \rho'(x)
\end{align*}



\vfilbreak



    \section{Forms of Judgement for $V^{-}$:}
    
\begin{tabular}{ll}
\toprule
    \multicolumn2{l}{\emph{Metavariables}} \\
\midrule
    $v, \; v'$& value \\
    $eq$& equation \\ 
    $\vtempstuck$& a temporarily-stuck equation \nr{Needs to record \emph{what} is stuck} \\
    $\vfail$& failure \\
    $\rho, \; \rhohat$& environment: $name \rightarrow \mathcal{V}_{\bot}$ \\
    $\mathcal{T}$& Context of all temporarily stuck equations \\ 
    $e$& An expression \\ 
    $ge$& A guarded expression \\
\bottomrule
\end{tabular}    

\medskip

\subsection{Equations}

    An \emph{equation} is either solved to produce bindings that extend an environemnt,
    gets temporarily stuck, or fails. 

    \mkjudgementcmd{EquationSuccess}{\vtuple{\rho, eq}}{\rhohat}
    \mkjudgementcmd{EquationTempStuck}{\vtuple{\rho, eq}}{\vtempstuck}
    \mkjudgementcmd{EquationFail}{\vtuple{\rho, eq}}{\vfail}
    \newcommand{\EvalSucc}[1][v] {{\vtuple{\rho, e}}%
    \Downarrow #1} 
    \mkevaljudgementcmd{EvalFail}{\vtuple{\rho, e}}{\vfail}
    \newcommand{\EvalGeSucc}[1][\rho] {{\vtuple{#1, \vtempstucks, ge}}%
                                        \Downarrow v} 
    \mkevaljudgementcmd{EvalGeFail}{\vtuple{\rho, \vtempstucks, ge}}{\vfail} 
    \mkjudgementcmd{CtxToRho}{\vtuple{\rho, \vtempstuck;%
    \vtempstucks}}{\vtuple{\rhohat, \vtempstucks}}

    \showvjudgement{EquationSuccess}{\EquationSuccess}
    \showvjudgement{EquationTempStuck}{\EquationTempStuck}
    \showvjudgement{EquationFail}{\EquationFail}

Success only refines the environment; that~is, when
${\vtuple{\rho, e}} \rightarrowtail{} {\rho'}$, we~expect $\rho \subseteq \rho'$.




\subsection{Expressions}

    An expression either evaluates to produce a value or fails. 
\nr{Don't we want a \emph{sequence} of values in the success case?
And if we have a sequence, do we need \vfail?   Or will the empty
sequence suffice?}


    \showvjudgement{EvalSucc}{\EvalSucc}
    \showvjudgement{EvalFail}{\EvalFail}
    \showvjudgement{EvalGeSucc}{\EvalGeSucc}
    \showvjudgement{EvalGeFail}{\EvalGeFail}

\subsection{Temporarily stuck equations}


    \showvjudgement{CtxToRho}{\CtxToRho}

\nr{I don't buy it.  The token \vtempstuck\ won't be enough to enable
a rule to compute $\rhohat$.}



\bigskip






\section{Lists}

Ideas:
\begin{itemize} 
\item
Use $\cdot$ as an infix, associative concatenation operator.
\item
Extend it to single values in the customary way.
\item
Write the empty sequence as \emptyseq.
\end{itemize}
\nr{Could it be worth writing laws here?}


\section{Rules (Big-step Operational Semantics) for $V^{-}$:}


\nr{Semicolon for list concatenation is not going to work here.  I
suggest concatenating with a small dot, as in ``$\eq \cdot
\vtempstucks$.''
As~the notation stands, it makes my brain hurt.  I'm~not going to try
to follow~it.
}
    
\mkevaljudgementcmd{GeEqCtxEval}{\vtuple{\rho, eq; \vtempstucks, ge}}{v}

\newcommand\GeCtxStuckRule[1][Left]{%
\inferrule*[#1=\textsc{ (Ge-Ctx-Stuck) }]
    {\inferrule*{}{\EquationTempStuck} 
    \and
    \inferrule*{}{\CtxToRho}
    \and 
    \inferrule*{}{\EvalGeSucc}
    }
    {\GeEqCtxEval}
}

\mpar{\GeCtxStuckRule}

% \begin{mathpar}
%     \inferrule*[Left=\textsc{ (Ge-Ctx-Stuck) }]
%     {\inferrule*{\EquationTempStuck}{\CtxToRho}
%     \and 
%     \inferrule*{}{\EvalGeSucc}
%     }
%     {\GeEqCtxEval}
% \end{mathpar}

% Which of the above two do you prefer? 

\nr{The notation below has multiple horizontal lines.  That makes it a
derivation, not a rule.  I'm having trouble figuring out what's being
said here.}



\mkevaljudgementcmd{GeCtxEqEval}{\vtuple{\rho, \vtempstucks, eq; ge}}{v}

\newcommand\GeEqStuckRule{%
\inferrule*[Left=\textsc{ (Ge-Eq-Succ) }]
{\GeCtxStuckRule[Right]}
{\GeCtxEqEval}
}

\mpar{\GeEqStuckRule}

\nr{If you're trying to pluck an equation out of a list of things, try
``$\vtempstucks \cdot \eq \cdot \vtempstucks'$.''}

% Gotta fix the stacking. 

\newcommand\GeCtxSuccRule{%
\inferrule*[Left=\textsc{ (Ge-Ctx-Succ) }]
    {\inferrule*{}{\EquationSuccess} 
    \and 
    \inferrule*{}{\EvalGeSucc[\rhohat]}
    }
    {\GeEqCtxEval}
}

\mpar{\GeCtxSuccRule}


\newcommand\GeEqSuccRule{%
\inferrule*[Left=\textsc{ (Ge-Eq-Succ) }]
    {\inferrule*{}{\GeCtxSuccRule[Right]} 
    }
    {\GeCtxEqEval}
}

\mpar{\GeEqSuccRule}


\mkevaljudgementcmd{GeEqCtxEvalFail}{\vtuple{\rho, eq; \vtempstucks, ge}}{\vfail}
\mkevaljudgementcmd{GeCtxEqEvalFail}{\vtuple{\rho, \vtempstucks, eq; ge}}{\vfail}

\newcommand\GeCtxFailRule[1][Left]{%
\inferrule*[#1=\textsc{ (Ge-Ctx-Fail) }]
    {\inferrule*{}{\EquationFail} 
    }
    {\GeEqCtxEvalFail}
}

    \mpar{\GeCtxFailRule}

\newcommand\GeEqFailRule{%
\inferrule*[Left=\textsc{ (Ge-Eq-Fail) }]
    {\inferrule*{}{\GeCtxFailRule[Right]} 
    }
    {\GeCtxEqEvalFail}
}

\mpar{\GeEqFailRule}

\mkevaljudgementcmd{GeExpSucc}{\vtuple{\rho, \vtempstucks, e; ge}}{v}
\mkevaljudgementcmd{GeExpFail}{\vtuple{\rho, \vtempstucks, e; ge}}{\vfail}

\newcommand\GeExpFailRule{%
\inferrule*[Left=\textsc{ (Ge-Exp-Fail) }]
    {\EvalSucc[\vfail]}
    {\GeExpFail}
}

\mpar{\GeExpFailRule}

\newcommand\GeExpSuccRule{%
\inferrule*[Left=\textsc{ (Ge-Eq-Succ) }]
    {\EvalSucc[v']
    \and 
    \EvalGeSucc}
    {\GeExpSucc}
}

\mpar{\GeExpSuccRule}




% \begin{mathpar}
% \inferrule*[Left=\textsc{Ge-Ctx-Stuck}]
%     {\inferrule*[Left=\textsc{FormalVar}]
%       {\texttt{x} \in dom \rho}
%       {\evalr{\textsc{var}(\texttt{x})} \Downarrow \evalr{1}}
%      \and 1 \neq 0 \and
%      \inferrule*[Right=\textsc{Literal}]
%        {\EvalGeSucc}
%        {\evalr{\textsc{lit}(\texttt{2})} \Downarrow \evalr{2}} 
%     }
%     {\GeCtxStuck}
% \end{mathpar}

% \begin{mathpar}
%   \inferrule*[Left=\textsc{IfTrue}]
%     {\inferrule*[Left=\textsc{FormalVar}]
%       {\texttt{x} \in dom \rho}
%       {\evalr{\textsc{var}(\texttt{x})} \Downarrow \evalr{1}}
%      \and 1 \neq 0 \and
%      \inferrule*[Right=\textsc{Literal}]
%        {\ }
%        {\evalr{\textsc{lit}(\texttt{2})} \Downarrow \evalr{2}} 
%     }
%     {\evalr{\textsc{if}(\textsc{var}(\texttt{x}), 
%                         \textsc{lit}(\texttt{2}),
%                         \textsc{lit}(\texttt{3}))}
%      \Downarrow \evalr{2} 
%     }
%   \end{mathpar}

% A series of equations is either is solved to produce a value or gets stuck. 
% A single sub-equation of the form x = e , where eq is an equation or an
% expression, either is solved to produce an environment or gets stuck. 

% An equation x = e can only be solved if e contains no unbound logical variables. 

% \it{In progress}
% $$
% (\tt{if} \; \tt{fi}) \triangleq (\tt{wrong})
% $$

\end{document}
