\documentclass[]{article}
\usepackage{vmlmacros}
\usepackage{syntax}
\usepackage{relsize}
% \usepackage{palatino} % I don't love this, to be honest. 
\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{simplebnf}
\setcounter{secnumdepth}{1}

\DeclareMathOperator{\dom}{dom}


% \setlength{\grammarparsep}{20pt plus 1pt minus 1pt} % increase separation between rules
\setlength{\grammarindent}{10em} % increase separation between LHS/RHS
\setlength{\parindent}{0cm}
\title{Syntax and Semantics of \PPlus}
\author{Roger Burtonpatel}
\date{February 18th, 2024}
\begin{document}

\maketitle

\section{Syntax}

\subsection{\PPlus~ Abstract Syntax}

\bigskip

\begin{center}
    \begin{bnf}
    $P$ : \textsf{Programs} ::=
    $\bracketed{d}$ : definition
    ;;
    $d$ : \textsf{Definitions} ::=
    | $\mathit{val} \; x \; \tt{=} \; \expr$ : bind name to expression
    ;;
    $\expr$ : Expressions ::= 
    | $x, y, z$ : names
    | $K\bracketed{\expr}$ : value constructor application 
    | $\lambda x. \; \expr$ : lambda declaration  
    | $\expr[1] \; \expr[2]$ : function application 
    | $\mathit{case} \; \expr \; \bracketed{p \; \rightarrow \; \expr}$ : case expression 
    ;;
    $p$ : \textsf{Patterns} ::= $p_{1}\pbar p_{2}$ : or-pattern
    | $p, p'$ : pattern guard 
    | $p \; \leftarrow \; \expr$ : pattern from explicit expression  
    | $x$ : name 
    | $K \; \bracketed{p}$ : value constructor application 
    | $\mathit{when}\; \expr$
    ;;
    $\v$ : Values ::= $K\bracketed{\v}$ : value constructor application 
    | $\lambda x. \; \expr$ : lambda value 
    ;;
    $K$ : \textsf{Value Constructors} ::=
    | $\mathit{true} \;\vert\; \mathit{false}$ : booleans
    | $\mathit{\#}x$ : name beginning with \tt{\#}
    | $\mathit{p-Z}x$ : name beggining with capital letter
    % | $[\tt{-}\vert\tt{+}](\tt{0}-\tt{9})+$ : signed integer literal 
    \end{bnf}
\end{center}


a \it{name} is any token that is not an integer literal, 
does not contain whitespace, a bracket, or parenthesis, 
and is not a value constructor name or a reserved word.

\vfilbreak

\subsection{\PPlus~ Concrete Syntax}

\bigskip

\begin{center}
    \begin{bnf}
    $P$ : \textsf{Programs} ::=
    $\bracketed{d}$ : definition
    ;;
    $d$ : \textsf{Definitions} ::=
    | $\tt{val} \; x \; \tt{=} \; \expr$ : bind name to expression
    ;;
    $\expr$ : Expressions ::= 
    | $x, y, z$ : names
    | $K\bracketed{\expr}$ : value constructor application 
    | $\ttbackslash x. \; \expr$ : lambda declaration  
    | $\expr[1] \; \expr[2]$ : function application 
    | $\tt{case} \; \expr \; \bracketed{p \; \ttrightarrow \; \expr}$ : case expression 
    | \ttbraced{$\expr$}
    ;;
    $p$ : \textsf{Patterns} ::= $p_{1}\pbar p_{2}$ : or-pattern
    | $p \tt{,} p'$ : pattern guard 
    | $p \; \leftarrow \; \expr$ : pattern from explicit expression  
    | $x$ : name 
    | $K \; \bracketed{p}$ : value constructor application 
    | $\tt{when}\; \expr$
    | \ttbraced{$p$}
    ;;
    $\v$ : Values ::= $K\bracketed{\v}$ : value constructor application 
    | $\ttbackslash x. \; \expr$ : lambda value 
    ;;
    $K$ : \textsf{Value Constructors} ::=
    | $\tt{true} \;\vert\; \mathit{false}$ : booleans
    | $\tt{\#}x$ : name beginning with \tt{\#}
    | $\tt{p-Z}x$ : name beggining with capital letter
    % | $[\tt{-}\vert\tt{+}](\tt{0}-\tt{9})+$ : signed integer literal 
    \end{bnf}
\end{center}


\section{Forms of Judgement for \PPlus:}
\begin{tabular}{ll}
\toprule
    \multicolumn2{l}{\emph{Metavariables}} \\
\midrule
    $\expr$& expression \\
    $\v, \; \v'$& value \\
    $K$& value constructor \\ 
    $p$& pattern \\ 
    $x, y$& names \\ 
    $g$& pattern guard \\ 
    $gs$& list of pattern guards \\ 
    $\dagger$& pattern match failure \\ 
    $r$& a result, either $\v$ or $\dagger$ \\ 
    \Rho& environment: $name \rightarrow \mathcal{\v}$ \\
    \Rho\:+\:\Rhoprime& extension \\
    $\Rho \uplus \Rho'$& disjoint union \\
    $\{ x \mapsto y \} $& environment with name $x$ mapping to $y$ \\
\bottomrule
\end{tabular}    

\bigskip

\begin{tabular}{ll}
    \toprule
        \multicolumn2{l}{\emph{Sequences}} \\
    \midrule
        $\emptyseq$& the empty sequence \\
        $S_1 \cdot S_2 $&  Concatenate sequence $S_1$ and sequence $S_2$ \\
        $x \cdot S_2 $& Cons $x$ onto sequence $S_2$ \\
    \bottomrule
    \end{tabular}    
    
    \medskip
    
    \medskip 


    For the forms of judgement for patterns, we borrow from Ramsey
    in our formalization [Ramsey 2023] XXX TO LINK:

    \begin{align*}
        &\pmatch \quad   \rm{ Pattern $p$ matches value $\v$, 
                              producing bindings $\rho'$;} \\
        &\pfail  \quad\; \rm{ Pattern $p$ does not match value $\v$.} 
    \end{align*}

    If a pattern is bound to an expression in the form $\pmatch[pat = {p
    \leftarrow \expr}, newenv = r]$, it will match if it the expression $e$
    evaluates to value $v'$ and $p$ matches with $v'$. If a pattern is
    standalone, as in any other form, it will match on $v$, the \it{original}
    scrutinee of the case expression.
    \rab{help phrasing this}

    Pattern matching is defined inductively: 
    \begin{itemize}
        \item a name $x$ matches any value $\v$, and produces the environment 
        $\bracketed{x \mapsto \v}$. 
        \item a value constructor $K$ applied to atoms  matches 
        a value $\v$ if $\v$ is an application of $K$ to the same number of values,
        each of which matches the corresponding atom. Its match produces 
        the disjoint union of matching all internal atoms to all internal values. 
        \item a pattern \whenexpr\: matches when $\expr$ evaluates to a value other than 
        \item a pattern \parrowe\: matches when $\expr$ evaluates to 
              value $\v$, and $p$ matches $\v$. 
        $\mathit{false}$, and produces the empty environment. 
        \item a pattern \pcommap\: matches if both $p$ and $p'$ match.
        \item a pattern \por\: matches if either $p_{1}$ or $p_{2}$
        matches. 
    \end{itemize}

    When a pattern is of the form $\textsc{vconapp} (K, p_{1}, \dots, p_{n})$,
    each sub-pattern $p_{i}$ may introducing new variables during pattern
    matching. Bindings for all these variables must be combined in a single 
    environment 
     \it{Disjoint
    union} is an operation on two environments 

    \subsection{Expressions}
    
        An expression in \PPlus evaluates to produce a single value. 

        \begin{align*}
            &\prun
        \end{align*}
    

%     TODO: include case literal rule and disjoint union section "Don't
% incorporate technical material by reference. You should explain disjoint union
% and +, but not necessarily the way I did. Your proximate audience is your thesis
% committee. Your ultimate audience is PL professionals."    
    \bigskip 



\section{Rules (Big-step Operational Semantics) for \PPlus:}

Some of these rules are a variation on the rules found in Ramsey (2022, Section
8.3). 


\subsection{Evaluating Expressions}


\subsubsection{Evaluating expressions other than \tt{case}}

\[
\inferrule*[Left=\textsc{ (Eval-Vcon-Empty) }]
    {\ }
    {\veval{\textsc{vcon} \; (K, \sqbraced{})}{K}}
\]

\[
\inferrule*[Left=\textsc{ (Eval-Vcon-Multi) }]
    {\inferrule* {}
    {
    \veval{\expr[i]}{v_{i}}
    \and 
    1 \leq i \leq n
    }}
    {\veval{\textsc{vcon} \;(K, \expr[1], \dots \expr[n])}{K(v_{1}, 
    \dots v_{i})}}
\]

\[
\inferrule*[Left=\textsc{ (Eval-Name) }]
    {x \in \dom \rho 
    \\\\
    \rho(x) = \v}
    {\prun[exp={\textsc{name} (x)}]}
\]

\[
\inferrule*[Left=\textsc{ (Eval-Lambda-Decl) }]
    {\ }
    {\prun[exp={\textsc{lambdaexp} (\lambda x.\expr)}, value={\lambda x.\expr}]}
\]


\[
\inferrule*[Left=\textsc{ (Eval-Funapp) }]
    {\veval{\expr[1]}{\lambda x.\expr}
    \\\\
    \veval{\expr[2]}{\v'}
    \\\\
    \prun[envext=\bracketed{x \mapsto \v'}]}
    {\veval{\textsc{funapp} (\expr[1],\; \expr[2])}{\v}}
\]

\[
\inferrule*[Left=\textsc{ (CaseScrutinee) }]
    {\inferrule* {}
    {\prun[value=\v]}
    \and 
    \prun[exp=
        {\textsc{case} \; (\textsc{literal}(\v), 
        [p_{1} \; \expr[1]], \dots, [p_{n} \; \expr[n]])},
        value=\v']}    
    {\prun[exp=
    {\textsc{case} \; (\expr, 
    [p_{1} \; \expr[1]], \dots, [p_{n} \; \expr[n]])},
    value=\v']}
\]

\[
\inferrule*[Left=\textsc{ (CaseMatch) }]
    {\inferrule* {}
    {\pmatch[pat={p_{1}}, newenv=\rho']}
    \and
    {\prun[exp= {\expr[1]}, env=\rho + \rho']}}
    {\prun[exp=
    {\textsc{case} \; (\textsc{literal}(\v), 
    [p_{1} \; \expr[1]], \dots, [p_{n} \; \expr[n]])},
    value=\v']}
\]

\[
\inferrule*[Left=\textsc{ (CaseFail) }]
    {\inferrule* {}
    {\pmatch[pat={p_{1}}, newenv=\dagger]}
    \and 
    \prun[exp={\textsc{case} \; (\textsc{literal}(\v), 
    [p_{2} \; \expr[2]], \dots, [p_{n} \; \expr[n]])},
    value=\v']}    
    {\prun[exp=
    {\textsc{case} \; (\textsc{literal}(\v), 
    [p_{1} \; \expr[1]], \dots, [p_{n} \; \expr[n]])},
    value=\v']}
\]



\subsection{Rules for pattern matching}


\[
\inferrule*[Left=\textsc{ (MatchVcon) }]
    {\inferrule* {}
    {
    \pmatch[pat=p_{i}, value=v_{i}, newenv=r_{i}], \and 1 \leq i \leq m
    \\\\
    r = r_{1} \uplus \dots \uplus r_{m}
    }}
    {\pmatch[pat={\textsc{vconapp} \;(K,\; p_{1}, \dots 
            p_{m})}, value={\textsc{vcon} \; (K, [v_{1}', \dots v_{m}'])},
            newenv=r]}
\]

\rab{nr: you have square brackets in these rules from the book on the vcon. why?}

\[
\inferrule*[Left=\textsc{ (FailVcon) }]
    {\v \rm{ does not have the form } \textsc{vcon} \; (K, [v_{1}', \dots v_{m}'])}
    {\pmatch[pat={\textsc{vconapp} \;(K,\; p_{1}, \dots 
            p_{m})}, 
            newenv=\dagger]}
\]

\[
\inferrule*[Left=\textsc{ (MatchBareVcon) }]
    {\ }
    {\pmatch[pat={\textsc{vconapp} \;(K, \bracketed{})}, value={\textsc{vcon} \; (K, [])},
            newenv=\bracketed{}]}
\]

\[
\inferrule*[Left=\textsc{ (FailBareVcon) }]
    {\v \neq {\textsc{vcon} \; (K, [])}}
    {\pmatch[pat={\textsc{vconapp} \;(K, \bracketed{})},
            newenv=\dagger]}
\]

\[
\inferrule*[Left=\textsc{ (MatchVar) }]
    {\ }
    {\pmatch[pat={\textsc{patname} \; (x)},
            newenv=\bracketed{x \mapsto \v}]}
\]

\[
\inferrule*[Left=\textsc{ (MatchWhen) }]
    {\prun[value=\v'] \and \v' \neq \mathit{false}}
    {\pmatch[pat={\textsc{when}\; (\expr)},
            newenv=\bracketed{}]}
\]

\[
\inferrule*[Left=\textsc{ (FailWhen) }]
{\prun[value=\v'] \and \v' = \mathit{false}}
{\pmatch[pat={\textsc{when}\; (\expr)},
            newenv=\dagger]}
\]


\[
\inferrule*[Left=\textsc{ (ArrowExpPattern) }]
{\prun[value=\v'] \and \pmatch[pat=p, value=\v', newenv=r]}
{\pmatch[pat={\textsc{arrowexpr} \; (p, \expr)},
            newenv=r]}
\]


\[
\inferrule*[Left=\textsc{ (PatMultiFail) }]
{\pmatch[pat=p, newenv=\dagger]}
{\pmatch[pat={\textsc{patternseq}\; (p, p')},
            newenv=\dagger]}
\]


\[
\inferrule*[Left=\textsc{ (PatMultiResult) }]
{\inferrule* {}
{\pmatch[pat=p, newenv=\Rhoprime]}
\\\\
\pmatch[env=\Rho \uplus \Rhoprime, pat=p', newenv=r]}
{\pmatch[pat={\textsc{patternseq}\; (p, p')}, newenv=r]}
\]

\[
\inferrule*[Left=\textsc{ (OrPatFst) }]
    {\pmatch[pat={p_{1}}]}
    {\pmatch[pat={\textsc{orpat}\; (p_{1}, p_{2})}]}
\]


\[
\inferrule*[Left=\textsc{ (OrPatSnd) }]
    {\pmatch[pat=p_{1}, newenv=\dagger]
    \and 
    \pmatch[pat={p_{2}}, newenv=r]}
    {\pmatch[pat={\textsc{orpat}\; (p_{1}, p_{2})}, newenv=r]}
\]


\section{Pattern match rules without textsc}

\[
\inferrule*[Left=\textsc{ (MatchVcon) }]
    {\inferrule* {}
    {
    \pmatch[pat=p_{i}, value=v_{i}, newenv=r_{i}], \and 1 \leq i \leq m
    \\\\
    r = r_{1} \uplus \dots \uplus r_{m}
    }}
    {\pmatch[pat={K\; p_{1}, \dots 
            p_{m}}, value={K\; [v_{1}', \dots v_{m}']},
            newenv=r]}
\]

\rab{nr: you have square brackets in these rules from the book on the vcon. why?}

\[
\inferrule*[Left=\textsc{ (FailVcon) }]
    {\v \rm{ does not have the form } K\; [v_{1}', \dots v_{m}']}
    {\pmatch[pat={K\; p_{1}, \dots 
            p_{m}}, 
            newenv=\dagger]}
\]

\[
\inferrule*[Left=\textsc{ (MatchBareVcon) }]
    {\ }
    {\pmatch[pat={K}, value={K},
            newenv=\bracketed{}]}
\]

\[
\inferrule*[Left=\textsc{ (FailBareVcon) }]
    {\v \neq K}
    {\pmatch[pat={K},
            newenv=\dagger]}
\]

\[
\inferrule*[Left=\textsc{ (MatchVar) }]
    {\ }
    {\pmatch[pat={x},
            newenv=\bracketed{x \mapsto \v}]}
\]

\[
\inferrule*[Left=\textsc{ (MatchWhen) }]
    {\prun[value=\v'] \and \v' \neq \mathit{false}}
    {\pmatch[pat={\mathit{when}\; \expr},
            newenv=\bracketed{}]}
\]

\[
\inferrule*[Left=\textsc{ (FailWhen) }]
{\prun[value=\v'] \and \v' = \mathit{false}}
{\pmatch[pat={\mathit{when}\; \expr},
        newenv=\dagger]}
\]


\[
\inferrule*[Left=\textsc{ (ArrowExpPattern) }]
{\prun[value=\v'] \and \pmatch[pat=p, value=\v', newenv=r]}
{\pmatch[pat={p \leftarrow \expr},
            newenv=r]}
\]


\[
\inferrule*[Left=\textsc{ (PatMultiFail) }]
{\pmatch[pat=p, newenv=\dagger]}
{\pmatch[pat={\pcommap},
            newenv=\dagger]}
\]


\[
\inferrule*[Left=\textsc{ (PatMultiResult) }]
{\inferrule* {}
{\pmatch[pat=p, newenv=\Rhoprime]}
\\\\
\pmatch[env=\Rho \uplus \Rhoprime, pat=p', newenv=r]}
{\pmatch[pat={\pcommap}, newenv=r]}
\]

\[
\inferrule*[Left=\textsc{ (OrPatFst) }]
    {\pmatch[pat={p_{1}}]}
    {\pmatch[pat={\por}]}
\]


\[
\inferrule*[Left=\textsc{ (OrPatSnd) }]
    {\pmatch[pat=p_{1}, newenv=\dagger]
    \and 
    \pmatch[pat={p_{2}}, newenv=r]}
    {\pmatch[pat={\por}, newenv=r]}
\]
\end{document}
