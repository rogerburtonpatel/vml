\documentclass{article}
\usepackage{vmlmacros}

\begin{document}
nr's theory: 


1. An equation can be solved if it has a side with no unevaluated (i.e.,
unbound) logical variables. 

2. Once an equation is solved, all its logical variables are evaluated (bound). 

3. A guard can be evaluated "like pattern matching" if there is an order in
which all its equations can be solved. 

Now consider a graph of equations, not variables.  There is an edge from
equation A to equation B if solving A makes B solvable.  That may be the
dependency graph you are looking for.

guard ::= exp list 

exp ::= value $\vert$ eq; e $\vert$ $\exists$ x. exp $\vert$ fail $\vert$ e1 \choice e2 $\vert$ v1 v2 $\vert$ one{exp} $\vert$ all{exp}

eq ::= exp $\vert$ equation 

equation ::= x = exp 


A term eq is either an ordinary expression e, or an equation v = e; this syntax
ensures that equations can only occur to the left of a â€œ; â€. 


BUILDING A GUARD IS THE TOPOLOGICAL SORT. 

the guard is the decision tree. 

BIG NOTE: 

In verse, 

1 ; 2 will give you 2 results. we can't have 2 results in ml. 
so- can you eliminate the form e1 ; e2 ? 

% ntegers ğ‘˜
% Variables ğ‘¥, ~, ğ‘§, ğ‘“ , ğ‘”
% Programs ğ‘ ::= one{e} where fvs(ğ‘’) = âˆ…
% Expressions ğ‘’ ::= v | ğ‘’ğ‘; e | âˆƒx. e | fail | e1 e2 | v1 v2 | one{e} | all{e}
% ğ‘’ğ‘ ::= e | v = e Note: â€œğ‘’ğ‘â€ is pronounced â€œexpression or equationâ€
% Values v ::= ğ‘¥ | hnf
% Head values hnf ::= ğ‘˜ | ğ‘œğ‘ | âŸ¨v1, Â·Â·Â·, vnâŸ© | ğœ†x. e
% Primops ğ‘œğ‘ ::= gt | add
% Concrete syntax: â€œ â€ and â€œ;â€ are right-associative.
% â€œ=â€ binds more tightly than â€œ;â€.
% â€œğœ†â€ and â€œâˆƒâ€ each scope as far to the right as possible.
% For example, (ğœ†y. âˆƒx. x = 1; x + y) means (ğœ†y. (âˆƒx. ((x = 1); (x + y)))).
% Parentheses may be used freely to aid readability and override default precedence.
% fvs(e) means the free variables of e; in VC, ğœ† and âˆƒ are the only binders.

\end{document}