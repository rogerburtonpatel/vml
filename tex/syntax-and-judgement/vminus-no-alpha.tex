\documentclass[]{article}
\usepackage{vmlmacros}
\usepackage{syntax}
\usepackage{relsize}
% \usepackage{palatino} % I don't love this, to be honest. 
\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{simplebnf}
\setcounter{secnumdepth}{1}

\DeclareMathOperator{\dom}{dom}



% \setlength{\grammarparsep}{20pt plus 1pt minus 1pt} % increase separation between rules
\setlength{\grammarindent}{10em} % increase separation between LHS/RHS
\setlength{\parindent}{0cm}
\title{Syntax and Semantics of \Vminus with no $\alpha$}
\author{Roger Burtonpatel}
\begin{document}

\maketitle

\section{Syntax}

\subsection{\Vminus with no $\alpha$}

We present a grammar of \Vminus, a variant of Verse with a defined
decision-making construct: 

\bigskip


\begin{center}
    \begin{bnf}
    $P$ : \textsf{Programs} ::=
    $\bracketed{d}$ : definition
    ;;
    $d$ : \textsf{Definitions} ::=
    | $\tt{val} \; x \; \tt{=} \; e$ : bind name to expression
    ;;
    $e$ : \textsf{Expressions} ::=
    | $x, y, z$ : names
    % Question: ebnf braces vs. regular brackets
    | $\tt{if} \; \tt{[}\; g \; \bracketed{[] g} \;\tt{]} \; \tt{fi}$ : if-fi 
    | $K \bracketed{e}$ : value constructor application 
    | $e[1] \; e[2]$ : function application 
    ;;
    $g$ : \textsf{Guarded Expressions} ::=  
    $\boldsymbol{\rightarrow}e$ : terminating experession
    | $e; \; g$ : intermediate expression 
    | $\exists \bracketed{x} \tt{.} g$ : existential 
    | $e_{1} = e_{2}; \; g$ : equation 
    | $\lambda x. \; e$ : lambda 
    ;;
    $v$ : Values ::= $K\bracketed{v}$ : value constructor application 
    | $\lambda x. \; e$ : lambda 
    ;;
    $K$ : \textsf{Value Constructors} ::=
    | \tt{true} $\vert$ \tt{false} : booleans
    | $\tt{\#}x$ : name beginning with \tt{\#}
    | \tt{A-Z}$x$ : name beggining with capital letter
    | $[\tt{-}\vert\tt{+}](\tt{0}-\tt{9})+$ : signed integer literal 
    \end{bnf}
\end{center}

A \it{name} is any token that is not an integer literal, 
does not contain whitespace, a bracket, or parenthesis, 
and is not a value constructor name or a reserved word.
        
\section{Refinement ordering on environments}

\begin{align*}
\rho \subseteq \Rhoprime \text{ when }&\dom\rho  \subseteq \dom \Rhoprime\\
\text{ and } &\forall x \in \dom \rho: \rho(x) \subseteq \Rhoprime(x)
\end{align*}



\vfilbreak



\section{Forms of Judgement for $V^{-}$:}
\begin{tabular}{ll}
\toprule
    \multicolumn2{l}{\emph{Metavariables}} \\
\midrule
    $v, \; v'$& value \\
    $eq$& equation \\ 
    % $\tempstuck$& a temporarily-stuck equation \\
    $\reject$& equation rejection \\
    $\result$& $v \mid$ \reject : a result of v \; or
    rejection\\
    \Rho& environment: $name \rightarrow \mathcal{V}_{\bot}$ \\
    $\rho\{ x \mapsto y \} $& environment extended with name $x$ mapping to $y$ \\
    $\mathcal{T}$& Context of all temporarily stuck equations (a sequence) \\ 
    $e$& An expression \\ 
    $g$& A guarded expression \\
    % \uppsidown& Inability to compile to a decision tree; a compile time error \\
\bottomrule
\end{tabular}    

\bigskip

\begin{tabular}{ll}
    \toprule
        \multicolumn2{l}{\emph{Sequences}} \\
    \midrule
        $\emptyseq$& the empty sequence \\
        $S_1 \cdot S_2 $&  Concatenate sequence $S_1$ and sequence $S_2$ \\
        $x \cdot S_2 $& Cons $x$ onto sequence $S_2$ \\
    \bottomrule
    \end{tabular}    
    
    \medskip
    
    % \mkjudgementcmd{EquationSuccess}{\vtuple{\rho, eq}}{\rhohat REMOVE THIS}
    % \mkjudgementcmd{EquationTempStuck}{\vtuple{\rho, eq}}{\tempstuck}
    % \mkjudgementcmd{EquationReject}{\vtuple{\rho, eq}}{reject}

    % \showvjudgement{EquationSuccess}{\EquationSuccess}
    % \showvjudgement{EquationTempStuck}{\EquationTempStuck}
    % \showvjudgement{EquationReject}{\EquationReject}
    
    
    
    
    % Success only refines the environment; that~is, when
    % ${\vtuple{\rho, e}} \rightarrowtail{} {\Rhoprime}$, we~expect $\rho \subseteq \Rhoprime$.
    
    

    
    \subsection{Expressions}
    
    \newcommand\GNoTree{\vmrun \rightsquigarrow \uppsidown} 
    
    An expression in core Verse evaluates to produce possibly-empty sequence of
    values. In \Vminus, expressions evaluate to a single value. We will explore
    a Verse variant in which expressions may evaluate to multiple values. 

    

    A guarded expression evaluates to produce a \bf{result}. A result is either
    a metavalue \valpha ~or reject. 
    
    \[\it{r} \; \rm{::=} \; v \;|\; \reject \]
    
    \showvjudgement{Eval}{\veval{e}{v}}
    \showvjudgement{Eval-Guarded-Expr}{\vmrun[term=g]}
    
    % \bigskip
    % If a guarded expression cannot be evaluated without producing logical 
    % variables at runtime, it cannot be expressed as a decision tree. 
    % This notation indicates this failure (think of \uppsidown as a fallen 
    % tree), which results in a compile-time error. 
    % \showvjudgement{NoTree}{\GNoTree}
    
    \bigskip
\subsection{Equations}

In \Vminus, we solve equations (intermediate computations in a guarded
expression of the form \\$e[1] = e[2]$) in a similar way to the
authors of the original Verse paper: we pick one, attempt to solve for it, and
move on. 

\rab{How do we express that \Vminus semantics preclude backtracking/logical 
variables at runtime?}

Given an environment from names to metavalues {\valpha}s \Rho, an equation \eq
~will either refine the environment ($\Rhoprime$) or lead to failure. We use
the metavariable $\dagger$ to represent failure, and an equation failing will
cause the top-level guarded expression to evaluate to \reject. 

\showvjudgement{Eq-Refine}\eqrefine
\showvjudgement{Eq-Fail}\eqfail
    
    
    \section{Sequences}
    
    The trivial sequence is \emptyseq. Sequences can be concatenated with infix 
$\cdot$. In an appropriate context, a value like $x$ stands for 
the singleton sequence containing $x$. 

\begin{align*}
    \emptyseq \cdot \ys &\equiv \ys \\
    \ys \cdot \emptyseq &\equiv \ys \\
    (\xs \cdot \ys) \cdot \zs &\equiv \xs \cdot (\ys \cdot \zs)
\end{align*}

\end{document}
