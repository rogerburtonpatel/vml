\documentclass[]{article}
\usepackage{vmlmacros}
\usepackage{syntax}
\usepackage{relsize}
\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{simplebnf}
\setcounter{secnumdepth}{1}

\DeclareMathOperator{\dom}{dom}



% \setlength{\grammarparsep}{20pt plus 1pt minus 1pt} % increase separation between rules
\setlength{\grammarindent}{10em} % increase separation between LHS/RHS
\setlength{\parindent}{0cm}
\title{Syntax and Semantics of {\VMinus} with no $\alpha$}
\author{Roger Burtonpatel}
\begin{document}

\maketitle

\section{Syntax}

\subsection{{\VMinus} with no $\alpha$}

We present a grammar of {\VMinus}, a variant of Verse with a defined
decision-making construct: 

\bigskip


\begin{center}
    \begin{bnf}
    $P$ : \textsf{Programs} ::=
    $\bracketed{d}$ : definition
    ;;
    $d$ : \textsf{Definitions} ::=
    | $\tt{val}\; x\; \tt{=}\; \expr$ : bind name to expression
    ;;
    $\expr$ : \textsf{Expressions} ::=
    | $v$ : literal values 
    | $x, y, z$ : names
    % Question: ebnf braces vs. regular brackets
    | $\tt{if}\; \tt{[}\; G\; \bracketed{\square\; G}\; \tt{]}\; \tt{fi}$ : if-fi 
    | $K \bracketed{\expr}$ : value constructor application 
    | $\expr[1]\; \expr[2]$ : function application 
    | $\lambda x.\; \expr$ : lambda declaration 
    ;;
    $G$ : \textsf{Guarded Expressions} ::=  
    $[\vexists{\bracketed{x}}] \bracketed{g} \boldsymbol{\rightarrow}\expr$ : names, guards, and body
    ;;
    $g$ : \textsf{Guards} ::=  
    | $\expr$ : intermediate expression 
    | $x = \expr$ : equation 
    | $ g \bracketed{; g} \; \choice \; g \bracketed{; g}$ : choice 
    ;;
    $\v$ : Values ::= $K\bracketed{\v}$ : value constructor application 
    | $\lambda x.\; \expr$ : lambda value
    ;;
    % $K$ : \textsf{Value Constructors} ::=
    % | \tt{true} $\vert$ \tt{false} : booleans
    % | $\tt{\#}x$ : name beginning with \tt{\#}
    % | \tt{A-Z}$x$ : name beggining with capital letter
    % | $[\tt{-}\vert\tt{+}](\tt{0}-\tt{9})+$ : signed integer literal 
    \end{bnf}
\end{center}

A \it{name} is any token that is not an integer literal, 
does not contain whitespace, a bracket, or parenthesis, 
and is not a value constructor name or a reserved word.
        
\section{Refinement ordering on environments}

\begin{align*}
\rho \subseteq \Rhoprime \text{ when }&\dom\rho  \subseteq \dom \Rhoprime\\
\text{ and } &\forall x \in \dom \rho: \rho(x) \subseteq \Rhoprime(x)
\end{align*}



\vfilbreak



\section{Forms of Judgement for ${\VMinus}$:}
\begin{tabular}{ll}
\toprule
    \multicolumn2{l}{\emph{Metavariables}} \\
\midrule
    $\expr$& An expression \\ 
    $\v,\; \v'$& value \\
    $\fail$& expression failure \\
    $\result$& $\v \vert$ \fail : expressions produce \it{results}: values or
    failure. \\
    \Rho& environment: $name \rightarrow {\mathcal{V}}_{\bot}$ \\
    $\rho\{ x \mapsto y \} $& environment extended with name $x$ mapping to $y$ \\
    $g$& A guard \\
    $eq$& equation \\ 
    % $\tempstuck$& a temporarily-stuck equation \\
    $\reject$& when solving guards is rejected \\
    $\solution$& $\rhohat \mid$ \reject : guards produce \it{solutions}: a
    refined environment \rhohat\; or rejection\\
    $\mathcal{T}$& Context of all temporarily stuck guards (a sequence) \\ 
    $G$& A guarded expression \\
    % \uppsidown& Inability to compile to a decision tree; a compile time error \\
\bottomrule
\end{tabular}    

\bigskip

\begin{tabular}{ll}
    \toprule
        \multicolumn2{l}{\emph{Sequences}} \\
    \midrule
        $\emptyseq$& the empty sequence \\
        $S_1 \cdot S_2 $&  Concatenate sequence $S_1$ and sequence $S_2$ \\
        $x \cdot S_2 $& Cons $x$ onto sequence $S_2$ \\
    \bottomrule
    \end{tabular}    
    
    \medskip
    
    % \mkjudgementcmd{EquationSuccess}{\vtuple{\rho, eq}}{\rhohat REMOVE THIS}
    % \mkjudgementcmd{EquationTempStuck}{\vtuple{\rho, eq}}{\tempstuck}
    % \mkjudgementcmd{EquationReject}{\vtuple{\rho, eq}}{reject}

    % \showvjudgement{EquationSuccess}{\EquationSuccess}
    % \showvjudgement{EquationTempStuck}{\EquationTempStuck}
    % \showvjudgement{EquationReject}{\EquationReject}
    
    
    
    
    Success only refines the environment; that~is, when
    ${\vtuple{\rho, \expr}} \rightarrowtail{} {\Rhoprime}$, 
    we~expect $\rho \subseteq \Rhoprime$.
    
    

    
    \subsection{Expressions}
    
    \newcommand\GNoTree{\vmrung \rightsquigarrow \uppsidown} 
    
    An expression in core Verse evaluates to produce possibly-empty sequence of
    values. In {\VMinus}, expressions evaluate to a single value. 
    % We will
    % explore a Verse variant in which expressions may evaluate to multiple
    % values. 

    An expression evaluates to produce a \bf{result}. A result is either
    a value $\v$ or \fail. 
    
    \[\it{r}\; \rm{::=}\; \rhohat\; \vert \; \fail \]
    
    \showvjudgement{Eval}{\vmeval}
    \showvjudgement{Solve-Guards}{\vmgs}
    
    % \bigskip
    % If a guarded expression cannot be evaluated without producing logical 
    % variables at runtime, it cannot be expressed as a decision tree. 
    % This notation indicates this failure (think of \uppsidown as a fallen 
    % tree), which results in a compile-time error. 
    % \showvjudgement{NoTree}{\GNoTree}
    
    \bigskip
\subsection{Equations}

In {\VMinus}, we solve equations (intermediate computations in a guarded
expression of the form \\$x = \expr$) in a similar way to the authors of the
original Verse paper: we pick one, attempt to solve for it, and move on. 

In our semantics, we do this with a \it{list} of guards: we pick a guard, 
attempt to solve it to refine our environment or fail, and repeat. If we 
can't make progress in solving a guard, we put it in \context\ and move on.


Given an environment from names to metavalues {\v}s \Rho, a guard \g\ will
either refine the environment ($\Rhoprime$) or be \bf{rejected}. We use the
metavariable $\reject$ to represent rejection, and a guard producing no
solution will cause the top-level list of guards to also produce \reject. 

    \showvjudgement{Guard-Refine}{\grefine[result=\rho']}
    \showvjudgement{Guard-reject}\gfail
    
    \section{Sequences}
    
    The trivial sequence is \emptyseq. Sequences can be concatenated with infix 
$\cdot$. In an appropriate context, a value like $x$ stands for 
the singleton sequence containing $x$. 

\begin{align*}
    \emptyseq \cdot \ys &\equiv \ys \\
    \ys \cdot \emptyseq &\equiv \ys \\
    (\xs \cdot \ys) \cdot \zs &\equiv \xs \cdot (\ys \cdot \zs)
\end{align*}

\section{Rules (Big-step Operational Semantics) for ${\VMinus}$:}
    
\subsection{Evaluating Guarded Expressions}


\subsubsection{Evaluating simple parts of guarded expressions}

% \[
% \inferrule*[Left=\textsc{ (Eval-ArrowExpr) }]
%     {\vmrung[context=\emptyseq, guard=\expr]}
%     {\vmrung[context=\emptyseq, guard=\rightarrow \expr, result=\v]}
% \]

% \[
% \inferrule*[Left=\textsc{ (Eval-Exists) }]
%     {\vmrung[env=\rho\{x \mapsto \bot \}]}
%     {\vmrung[guard=\vexists{x}\; g]}
% \]


\subsubsection{Shifting an equation to the context}
\[
\inferrule*[Left=\textsc{ (Guard-Move-To-Ctx) }]
    {\inferrule*{\vmgs[context=g \cdot \context]}
    {}
    }
    {\vmgs[guards={gs \cdot g \cdot gs'}]}
\]

\subsubsection{Choosing and solving an equation}

\[
\inferrule*[Left=\textsc{ (Solve-Guard-Refine) }]
    {\grefine[result=\Rhoprime]
    \and
    \vmgs[env=\Rhoprime,context=\;\TT]}
    {\vmgs[context=\TeqT{g}]}
\]

\[
\inferrule*[Left=\textsc{ (Solve-Guard-Reject) }]
    {\gfail}
    {\vmgs[context=\TeqT{g},solution=\reject]}
\]
\subsubsection{Properties of equations}

% \[
% \inferrule*[Left=\textsc{ (Single-Eq-Assoc) }]
%     {\vmrung[context=\TeqT{\expr[2] = \expr[1]}]}
%     {\vmrung[context=\TeqT{\expr[1] = \expr[2]}]}
% \]

\[
\inferrule*[Left=\textsc{ (Multi-Guard-Assoc) }]
    {\vmrung[context=\TeqT{g_{1} \cdot g_{2}}]}
    {\vmrung[context=\TeqT{g_{2} \cdot g_{1}}]}
\]


% \[
% \inferrule*[Left=\textsc{ (Multi-Eq-Assoc) }]
%     {\vmrung[context=\TeqT{\expr[2] = \expr[1] \cdot \expr[1] = \expr[2]}]}
%     {\vmrung[context=\TeqT{\expr[1] = \expr[2] \cdot \expr[2] = \expr[1]}]}
% \]

% \subsubsection{Desugaring of Complex Equations}
% \[
% \inferrule*[Left=\textsc{ (Desugar-EqExps) }]
%     {\inferrule* {}
%     {
%     x,\; \; \rm{are distinct and fresh}
%     \\\\
%     \vmrung[envext=\bracketed{x \mapsto \bot,\; y \mapsto \bot},
%           context=\eqTT{x = \expr[1] \cdot y = \expr[2] \cdot x = y}]}}
%     {\vmrung[context=\TeqT{\expr[1] = \expr[2]}]}
% \]

% \[
% \inferrule*[Left=\textsc{ (Desugar-Vcon-Multi) }]
%     {
%     \vmrung[context=\TeqT{\lbrack \expr[i]=\expr[i]'\; 
%            \vert\; 1 \leq i \leq n \rbrack}]}
%     {\vmrung[context=\TeqT{K(\expr[1], \dots 
%             \expr[n]) = K(\expr[1]', \dots \expr[n]')}]}
% \]

\subsubsection{Refinement with different types of equations}

\[
\inferrule*[Left=\textsc{ (G-NameExp-Bot) }]
    {\inferrule* {}
    {
    x \in \dom \rho
    \\\\
    \vmeval[result=\v]
    \\\\
    \rho(x) = \bot
    }}
    {\eqrefine[eq={x = \expr},newenv={\Rho[x \mapsto \v]}]}
\]

\[
\inferrule*[Left=\textsc{ (G-NameExp-Eq) }]
    {\inferrule* {}
    {
    x \in \dom \rho
    \\\\
    \vmeval[result=\v]
    \\\\
    \rho(x) = \v
    }}
    {\eqrefine[eq={x = \expr},newenv={\Rho[x \mapsto \v]}]}
\]

\[
\inferrule*[Left=\textsc{ (G-NameExp-Fail) }]
    {\inferrule* {}
    {
    x \in \dom \rho
    \\\\
    \vmeval[result=\v]
    \\\\ 
    \rho(x) = \v'
    \\\\
    \v \neq \v'
    }}
    {\eqrefine[eq={x = \expr},newenv=\reject]}
\]

\[
\inferrule*[Left=\textsc{ (G-NameNotFound-Fail) }]
    {\inferrule* {}
    {
    x \not\in \dom \rho
    }}
    {\eqrefine[eq={x = \expr},newenv=\reject]}
\]

\[
\inferrule*[Left=\textsc{ (G-EqNames-Vals-Succ) }]
    {\inferrule* {}
    {
    x,\;  \in \dom \rho
    \\\\
    \rho(x) = \v,\; \rho(y) = \v
    }}
    {\eqrefine[eq={x = y},newenv=\rho]}
\]

\[
\inferrule*[Left=\textsc{ (G-EqNames-Vals-Fail) }]
    {\inferrule* {}
    {
    x,\;  \in \dom \rho
    \\\\
    \rho(x) = \v,\; \rho(y) = \v'
    \\\\
    \v \neq \v'}}
    {\eqrefine[eq={x = y},newenv=\reject]}
\]

% \[
% \inferrule*[Left=\textsc{ (G-EqNames-Bots-Fail) }]
%     {\inferrule* {}
%     {
%     x,\;  \in \dom \rho
%     \\\\
%     \rho(x) = \bot,\; \rho(y) = \bot
%     \\\\
%     x,\; \; \rm{do not appear in}\; \context,\; \context'}}
%     {\vmrung[context=\TeqT{x = y}] 
%     \rightsquigarrow \uppsidown}
% \]

\[
\inferrule*[Left=\textsc{ (G-EqNames-BotVal-Succ) }]
    {\inferrule* {}
    {
    x,\;  \in \dom \rho
    \\\\
    \rho(x) = \bot,\; \rho(y) = \v
    }}
    {\eqrefine[eq={x = y},newenv={\Rho[x \mapsto \v]}]}
\]

\[
\inferrule*[Left=\textsc{ (G-Vcon-Single-Fail) }]
    {K \neq K'}
    {\eqrefine[eq={K = K'}, newenv=\reject]}
\]

\[
\inferrule*[Left=\textsc{ (G-Vcon-Single-Succ) }]
    {\ }
    {\eqrefine[eq={K = K}, newenv=\Rho]}
\]


\[
\inferrule*[Left=\textsc{ (G-Vcon-Multi-Fail) }]
    {K \neq K'}
    {\eqrefine[eq={K(\expr[1], \dots 
            \expr[n]) = K'(\expr[1]', \dots \expr[n]')},
            newenv=\reject]}
\]

\[
\inferrule*[Left=\textsc{ (G-Vcon-Multi-Arity-Fail) }]
    {n \neq m}
    {\eqrefine[eq={K(\expr[1], \dots 
            \expr[n]) = K(\expr[1]', \dots \expr[m]')},
            newenv=\reject]}
\]

\[
\inferrule*[Left=\textsc{ (G-Expseq-Succ) }]
    {\inferrule* {}
    {
    \vmeval[result=\v]}}
    {\grefine[guard=\expr, result=\bracketed{}]}
\]

\[
\inferrule*[Left=\textsc{ (G-Expseq-Fail) }]
    {\vmeval[result={\fail}]}
    {\grefine[guard=\expr, result=\reject]}
\]

\[
\inferrule*[Left=\textsc{ (G-Choice-First) }]
    {\vmgs[context=\emptyseq, solution=\rho']}
    {\grefine[guard={\choiceg{gs}{gs'}}, result=\rho']}
\]

\[
\inferrule*[Left=\textsc{ (G-Choice-Second) }]
    {\vmgs[context=\emptyseq, solution=\rho'] 
    \and 
    \vmgs[context=\emptyseq, guards=gs']}
    {\grefine[guard={\choiceg{gs}{gs'}}, result=s]}
\]



\subsection{Evaluating General Expressions}


\[
\inferrule*[Left=\textsc{ (If-Fi-Fail) }]
    {\ }
    {\vmeval[exp={\iffi{\ }}, result={\fail}]}
\]

\[
\inferrule*[Left=\textsc{ (If-Fi-Success) }]
{\inferrule* {}
    {\rho' = \Rho[x_{1} \mapsto \bot \dots x_{n} \mapsto \bot]}
    \\\\
    {\vmgs[env=\rho', context=\emptyseq, result=\rho'']}
    \\\\ 
    {\vmeval[env={\rho''}]}}
    {\vmeval[exp={\iffi{\vexists{x_{1} \dots x_{n}}\; gs \rightarrow e\; \square\; \dots}}]}
\]

\[
\inferrule*[Left=\textsc{ (If-Fi-Reject) }]
{\inferrule* {}
    {\rho' = \Rho[x_{1} \mapsto \bot \dots x_{n} \mapsto \bot]}
    \\\\
    {\vmgs[env=\rho', context=\emptyseq, result=\reject]}
    \\\\
    \vmeval[exp={\iffi{\dots}}]}
    {\vmeval[exp={\iffi{\vexists{x_{1} \dots x_{n}}\; gs \rightarrow e\; \square\; \dots}}]}
\]


\[
\inferrule*[Left=\textsc{ (Vcon-Empty) }]
    {\ }
    {\vmeval[exp={K}, result={K}]}
\]

\[
\inferrule*[Left=\textsc{ (Vcon-Multi) }]
    {\inferrule* {}
    {
    \vmeval[exp={\expr[i]}, result={v_{i}}]
    \and 
    1 \leq i \leq n
    }}
    {\vmeval[exp={K(\expr[1], \dots \expr[n])}, result={K(v_{1}, 
    \dots v_{i})}]}
\]

\[
\inferrule*[Left=\textsc{ (Vcon-Multi-Fail) }]
    {\inferrule* {}
    {
    \exists e_{i}.\; 1 \leq i \leq n : \vmeval[exp={\expr[i]}, result={\fail}]
    }}
    {\vmeval[exp={K(\expr[1], \dots \expr[n])}, result={\fail}]}
\]


\[
\inferrule*[Left=\textsc{ (Eval-Name) }]
    {x \in \dom \rho 
    \\\\
    \rho(x) = \v}
    {\vmeval[exp={x}, result={\v}]}
\]

\[
\inferrule*[Left=\textsc{ (Eval-Name-Fail) }]
    {x \notin \dom \rho}
    {\vmeval[exp={x}, result={\fail}]}
\]

% \[
% \inferrule*[Left=\textsc{ (Eval-Funapp-Fail) }]
%     {\vmeval[exp={\expr[1]}]
%     \\\\
%     r \rm{ does not have the form } {\lambda x.\expr}}
%     {\vmeval[exp={\expr[1]\; \expr[2]}, result=\fail]}
% \]

\[
\inferrule*[Left=\textsc{ (Eval-Funapp) }]
    {\vmeval[exp={\expr[1]}, result={\lambda x.\expr}]
    \\\\
    \vmeval[exp={\expr[2]}, result={\v'}]
    \\\\
    \vmeval[envext=\bracketed{x \mapsto \v'}]}
    {\vmeval[exp={\expr[1]\; \expr[2]}]}
\]

\[
\inferrule*[Left=\textsc{ (Eval-Literal) }]
    {\ }
    {\vmeval[exp={\v}, result={\v}]}
\]

\end{document}
