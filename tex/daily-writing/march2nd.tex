\documentclass{article}
\usepackage{vmlmacros}

\setlength{\parindent}{0cm}
\title{March 2nd, 2024}
\author{Roger Burtonpatel}

\begin{document}

\maketitle

Pattern matching is nice and has an appealing cost model, but people keep
extending it to make it more expressive. Verse [XXX TODO CITE] looks very simple
and is surprisingly expressive, but the cost model is a challenge. Why not look
for a compromise?

Pattern matching is a well-established paradigm within functional languages, and
"""has been the subject of significant discourse.""" \it{Appeal to authority here.}

Indeed, pattern matching is quite appealing when deconstructing data, especially 
data that may be represented with an algebraic data type, is the primary programming problem: 

\it{Example. Simple deconstruction.}

Figure 1 illustrates an example in which pattern matching is an elegant solution 
to a problem (compare to equivalent Scheme code that manually deconstructs a list:)

\it{Example in Scheme.}

However, language designers continue to extend pattern matching 

\section{Pattern Matching as it is Now}
\it{Pattern matching} is defined as "checking and locating of specific sequences
of data of some pattern among raw data or a sequence of tokens." We will return
to the notion of "checking" often in this paper: pattern matching answers the
question "when I'm checking to see if a piece of data (called a \it{scrutinee})
is of the same form as a certain pattern, does that match succeed or fail?"

\it{Example}.

In addition to this checking and locating, pattern matching serves as
\it{assignment}: it can bind fresh variables based on the form of data and use
those bindings in subsequent expressions. 

\it{Example}.

Here, "checking" means "do the data match what I expect them to." Because
pattern matching is inherently built to match a scrutinee (pure data) with a
pattern, pattern matching is quite expressive in these cases. 

Because of this, most modern functional languages, especially \it{data
dependency languages} like Haskell or ML, \it{(is this right?)} employ pattern
matching as their main way to deconstruct data (citation?). 

We here explore pattern matching through the lens of \PPlus, an invented
language that has pattern matching along with several of its popular extensions.
(The examples above are written in \PPlus.) 
\subsection{Strengths}

- "Checking" and assignment- nice! No car, cdr 

- Nested patterns - powerful 

- Literal patterns let you mix names and values 

\subsection{Weaknesses and Proposed Mitigations}

We return to the concept of unifying "checking" with assignment, i.e. "match if
the data take this form, and give them names." Pattern matching succeeds here
when checking means "is the form of data the way I expect"; in fact, as we know,
assignment in general \it{is} pattern matching (figure/example?). But when
checking means "does this computation succeed" or "does this binding conflict
with a prior binding," pattern matching is at a loss, where Verse succeeds. 

Example: 


Pattern matching's extensions get closer to unifying "checking" and binding.
Here, Verse enjoys a different suite of advantages. 

First, its "or" operation (`one` with `choice`) allows for more than patterns to
appear as a top-level "choose this or that" construct in a match sequence; you
can also include arbitrary expressions. You can't do this in pattern matching's
version, which is an or-pattern. Simply put, saying "does this pattern match or
is this expression true" is easy in Verse and clunky if you use patterns. I'll
show examples at our meeting. 

Second, Verse can express operations out of order, letting important checks
appear higher up even if they are executed later. This helps program legibility.
Again, I have examples from the chapter I wrote today. 

Third, in a pattern-match clause, the initial data must still match an initial
pattern in order to enter a guard; in Verse there is no restriction. This is
minor, because you could simply match the data to a variable, and then enter a
guard-- but again, all of these advantages are in elegance and brevity, and
elegant that solution is not. 

Finally, mingling pattern guards with other extensions to pattern matching
(especially or-patterns) is a murky subject. Haskell has pattern guards and side
conditions, but no or-patterns. OCaml has side conditions and or-patterns, but
no guards. Mixing all three is (according to some readings) simply difficult for
implementers- including, interestingly, those of parsers. In Verse, having `one`
and `choice` closely tied in with the simple `e1 = e2` equation form, which by
itself subsumes pattern matching, side-conditions, and pattern guards, means
that integrating options is easy. A key theme that arises of this: Verse has
fewer constructs, and they are more expressive.  

\section{A Proposal, Inspired by the Verse Calculus}

\subsection{Verse Flexibility}
\subsection{Something else}
\subsection{A third thing}

\section{Verse's Equations Subsume Pattern Matching}

\subsection{Claim}
\subsection{Proof}
\subsection{Translations}

\section{(Maybe) Writing Efficient Verse Code}

\subsection{Claim}
\subsection{Proof}
\subsection{Translations}


\section{Citations and Bibliographies}



% \section{Syntax}

% \subsection{The Core Language}

% We present a grammar of a base language, with no decision-making constructs: 

% \bigskip

% % I attempted to use the grammar environment you provided. But there was either
% % something missing or something I overlooked in the example code and it would
% % not compile, despite many reducing changes I made. So I went with the
% % simplebnf package, which I quite like.  
% \begin{center}
%     \begin{bnf}
%     $P$ : \textsf{Programs} ::=
%     $\bracketed{d}$ : definition
%     ;;
%     $d$ : \textsf{Definitions} ::=
%     | $\tt{val} \; x \; \tt{=} \; \expr$ : bind name to expression
%     ;;
%     $\expr$ : Core expressions ::= 
%     | $x, y, z$ : names
%     | $K\bracketed{\expr}$ : value constructor application 
%     | $\tt{if} \; \expr[1] \; \tt{then} \; \expr[2] \; \tt{else} \; e_{3} $ : if
%     | $\lambda x. \; \expr$ : lambda 
%     | $\expr[1] \; \expr[2]$ : function application 
%     ;;
%     $\v$ : Values ::= $K\bracketed{\v}$ : value constructor application 
%     ;;
%     $K$ : \textsf{Value Constructors} ::=
%     % \cons : cons 
%     % | \tt{[]} : empty list 
%     | \tt{true} $\vert$ \tt{false} : booleans
%     | $\tt{\#}x$ : name beginning with \tt{\#}
%     | \tt{A-Z}$x$ : name beggining with capital letter
%     | $[\tt{-}\vert\tt{+}](\tt{0}-\tt{9})+$ : signed integer literal 

%     \end{bnf}
% \end{center}


% A \it{name} is any token that is not an integer literal, 
% does not contain whitespace, a bracket, or parenthesis, 
% and is not a value constructor name or a reserved word.


% We then present three language extensions that build off of this core: 
% \PPlus, the language of patterns, \VMinus, the language of 
% verse-like equations, and $D$, the language of decision trees. 

% \subsection{Three Language Extensions}

% \subsubsection{\VMinus:}

% \begin{center}
%     \begin{bnf}
%     $\ealpha$ : \textsf{$\alpha$-Expressions} ::=
%     | $\alpha$ : terminating alpha
%     | $x, y, z$ : names
%     % Question: ebnf braces vs. 
%     | $\tt{if} \; \tt{[}\; \galpha \; \bracketed{[] \galpha} \;\tt{]} \; \tt{fi}$ : if-fi 
%     | $K \bracketed{\ealpha}$ : value constructor application 
%     | $\ealpha[1] \; \ealpha[2]$ : function application 
%     ;;
%     $\galpha$ : \textsf{Guarded Expressions} ::=  
%     $\boldsymbol{\rightarrow}\ealpha$ : terminating $\ealpha$ 
%     | $\ealpha; \; \galpha$ : intermediate expression 
%     | $\exists \bracketed{x} \tt{.} \galpha$ : existential 
%     | $\ealpha[1] = \ealpha[2]; \; \galpha$ : equation 
%     % ;;
%     \end{bnf}
% \end{center}

% \bigskip 

% \subsubsection{\PPlus:}
% \begin{center}
%     \begin{bnf}
% $\expr$ : \textsf{Expressions} ::=
%     | $\ttbraced{\tt{case} \; \expr \; \bracketed{\tt{[} p \; \expr \tt{]}}}$ : case expression 
%     ;;
%     $p$ : \textsf{Patterns} ::= $x$ : name 
%     | $K$ : value constructor 
%     | $\ttbraced{K \; \bracketed{p}}$ : value constructor application 
%     % | $\ttbraced{p \; \tt{when} \; \expr }$ : side condition
%     | $\ttbraced{\tt{oneof} \; p_{1} \;, p_{2} }$ : or-pattern 
%     | $\ttbraced{p \tt{;} \bracketed{\expr \vert \ttbraced{p  <- \expr}}}$ : pattern guard
%     \end{bnf}
% \end{center}


% \bigskip 

% \subsubsection{$D$:}

% \begin{center}
%     \begin{bnf}
%         \Dalpha : \textsf{Decision Tree} ::= 
%         $\tt{case} \; x \; \tt{of} \; 
%         \bracketed{\vert \; K\bracketed{x} \; \tt{=>} \; \Dalpha}
%         [\vert \; x \; \tt{=>} \Dalpha]$ : test node 
%         | $\alpha$ : match node 
%         | $\tt{if} \; x \; \tt{then} \; \Dalpha \; \tt{else} \; \Dalpha$ : condition with two children 
%         | $\tt{let} \; x \; \tt{=} \; \expr \; \tt{in} \; \Dalpha$ : let-bind a name
%         ;;
%         $\expr$ : \textsf{Expressions} ::=
%         | $\mathcal{D}_{\expr}$ : decision trees 
%     \end{bnf}
% \end{center}



\end{document}