\documentclass{article}
\usepackage{vmlmacros}

\setlength{\parindent}{0cm}
\title{Week of February 26th, 2024}
\author{Roger Burtonpatel}

\begin{document}

\maketitle

Pattern matching is nice and has an appealing cost model, but people keep
extending it to make it more expressive. Verse [XXX TODO CITE] looks very simple
and is surprisingly expressive, but the cost model is a challenge. Why not look
for a compromise?

\bigskip 
\it{The introduction will have a motivating example.}
\bigskip 


% Prior work has introduced extesions to pattern matching [XXX TODO CITE, INCLUDE
% SPJ PATTERN GUARDS]

We introduce two small functional programming languages to address this issue:
\PPlus, a language with several of the popular extensions to pattern matching
and minimal syntactic restrictions, and \VMinus, which replaces pattern matching
with equations like those in Verse [XXX TODO CITE: Verse paper]. 

Where to include this: 
We also introduce \D, a language where decision making is decided purely with decision
trees. We will use \D to prove efficient compilation of \VMinus. 

\PPlus provides or-patterns, side-conditions, and pattern guards, whose
combination does not appear in Haskell, OCaml, Standard ML, or any other major
functional language. 
\bigskip
Next steps: Finish introduction of language table, say where semantics are. 

\bigskip
interesting thoughts: 

Having a strategem for verse to decision tree is analagous to tail recursion. 
You have to write your code in a way that allows the optimization. 


% Pattern matching is a well-established paradigm within functional languages, and
% """has been the subject of significant discourse.""" \it{Appeal to authority here.}

% Without pattern matching, it can be tiresome to deconstruct data using manual 
% accessor functions. Consider the following Standard ML code: 
% \smllst

% \begin{lstlisting}
% val rec len = fn ys => 
%     if null ys 
%     then 0 
%     else let xs = tl ys 
%          in len xs 
%          end 
% \end{lstlisting}
% \it{An implementation of List.len in Standard ML that does not use pattern 
%     matching.}

% Manual checking and deconstruction, with built-in functions like \tt{null} and
% \tt{tl}, can be both error-prone (\bf{say more on this?}) and verbose. Most
% functional programmers likely prefer the follwing implementation of \tt{len}:

% \begin{lstlisting}
%     val rec len = fn ys => 
%         case ys 
%           of [] => 0
%            | _::xs => 1 + len xs
%     \end{lstlisting}

% \it{An equivalent implementation that uses pattern matching.}

% Indeed, pattern matching is quite appealing when deconstructing data, especially 
% data that may be represented with an algebraic data type, is the primary programming problem: 



% \begin{lstlisting}
% val len = \ys. case ys 
%                  of [] -> 0
%                   | _::xs -> 1 + len xs
% \end{lstlisting}


% Figure 1 illustrates an example in which pattern matching is an elegant solution
% to a problem (compare to equivalent Standard ML code that manually deconstructs
% a list:)


% Most functional programmers likely prefer the first example 

% However, language designers continue to extend pattern matching 

% \section{Pattern Matching as it is Now}
% \it{Pattern matching} is defined as "checking and locating of specific sequences
% of data of some pattern among raw data or a sequence of tokens." We will return
% to the notion of "checking" often in this paper: pattern matching answers the
% question "when I'm checking to see if a piece of data (called a \it{scrutinee})
% is of the same form as a certain pattern, does that match succeed or fail?"

% \it{Example}.

% In addition to this checking and locating, pattern matching serves as
% \it{assignment}: it can bind fresh variables based on the form of data and use
% those bindings in subsequent expressions. 

% \it{Example}.

% Here, "checking" means "do the data match what I expect them to." Because
% pattern matching is inherently built to match a scrutinee (pure data) with a
% pattern, pattern matching is quite expressive in these cases. 

% Because of this, most modern functional languages, especially \it{data
% dependency languages} like Haskell or ML, \it{(is this right?)} employ pattern
% matching as their main way to deconstruct data (citation?). 

% We here explore pattern matching through the lens of \PPlus, an invented
% language that has pattern matching along with several of its popular extensions.
% (The examples above are written in \PPlus.) 
% \subsection{Strengths}

% - "Checking" and assignment- nice! No car, cdr 

% - Nested patterns - powerful 

% - Literal patterns let you mix names and values 

% \subsection{Weaknesses and Proposed Mitigations}

% We return to the concept of unifying "checking" with assignment, i.e. "match if
% the data take this form, and give them names." Pattern matching succeeds here
% when checking means "is the form of data the way I expect"; in fact, as we know,
% assignment in general \it{is} pattern matching (figure/example?). But when
% checking means "does this computation succeed" or "does this binding conflict
% with a prior binding," pattern matching is at a loss, where Verse succeeds. 

% Example: 


% Pattern matching's extensions get closer to unifying "checking" and binding.
% Here, Verse enjoys a different suite of advantages. 

% First, its "or" operation (`one` with `choice`) allows for more than patterns to
% appear as a top-level "choose this or that" construct in a match sequence; you
% can also include arbitrary expressions. You can't do this in pattern matching's
% version, which is an or-pattern. Simply put, saying "does this pattern match or
% is this expression true" is easy in Verse and clunky if you use patterns. I'll
% show examples at our meeting. 

% Second, Verse can express operations out of order, letting important checks
% appear higher up even if they are executed later. This helps program legibility.
% Again, I have examples from the chapter I wrote today. 

% Third, in a pattern-match clause, the initial data must still match an initial
% pattern in order to enter a guard; in Verse there is no restriction. This is
% minor, because you could simply match the data to a variable, and then enter a
% guard-- but again, all of these advantages are in elegance and brevity, and
% elegant that solution is not. 

% Finally, mingling pattern guards with other extensions to pattern matching
% (especially or-patterns) is a murky subject. Haskell has pattern guards and side
% conditions, but no or-patterns. OCaml has side conditions and or-patterns, but
% no guards. Mixing all three is (according to some readings) simply difficult for
% implementers- including, interestingly, those of parsers. In Verse, having `one`
% and `choice` closely tied in with the simple `e1 = e2` equation form, which by
% itself subsumes pattern matching, side-conditions, and pattern guards, means
% that integrating options is easy. A key theme that arises of this: Verse has
% fewer constructs, and they are more expressive.  

% \section{A Proposal, Inspired by the Verse Calculus}

% \subsection{Verse Flexibility}
% \subsection{Something else}
% \subsection{A third thing}

% \section{Verse's Equations Subsume Pattern Matching}

% \subsection{Claim}
% \subsection{Proof}
% \subsection{Translations}

% \section{(Maybe) Writing Efficient Verse Code}

% \subsection{Claim}
% \subsection{Proof}
% \subsection{Translations}


% \section{Citations and Bibliographies}



% \section{Syntax}

% \subsection{The Core Language}

% We present a grammar of a base language, with no decision-making constructs: 

% \bigskip

% % I attempted to use the grammar environment you provided. But there was either
% % something missing or something I overlooked in the example code and it would
% % not compile, despite many reducing changes I made. So I went with the
% % simplebnf package, which I quite like.  
% \begin{center}
%     \begin{bnf}
%     $P$ : \textsf{Programs} ::=
%     $\bracketed{d}$ : definition
%     ;;
%     $d$ : \textsf{Definitions} ::=
%     | $\tt{val} \; x \; \tt{=} \; \expr$ : bind name to expression
%     ;;
%     $\expr$ : Core expressions ::= 
%     | $x, y, z$ : names
%     | $K\bracketed{\expr}$ : value constructor application 
%     | $\tt{if} \; \expr[1] \; \tt{then} \; \expr[2] \; \tt{else} \; e_{3} $ : if
%     | $\lambda x. \; \expr$ : lambda 
%     | $\expr[1] \; \expr[2]$ : function application 
%     ;;
%     $\v$ : Values ::= $K\bracketed{\v}$ : value constructor application 
%     ;;
%     $K$ : \textsf{Value Constructors} ::=
%     % \cons : cons 
%     % | \tt{[]} : empty list 
%     | \tt{true} $\vert$ \tt{false} : booleans
%     | $\tt{\#}x$ : name beginning with \tt{\#}
%     | \tt{A-Z}$x$ : name beggining with capital letter
%     | $[\tt{-}\vert\tt{+}](\tt{0}-\tt{9})+$ : signed integer literal 

%     \end{bnf}
% \end{center}


% A \it{name} is any token that is not an integer literal, 
% does not contain whitespace, a bracket, or parenthesis, 
% and is not a value constructor name or a reserved word.


% We then present three language extensions that build off of this core: 
% \PPlus, the language of patterns, \VMinus, the language of 
% verse-like equations, and $D$, the language of decision trees. 

% \subsection{Three Language Extensions}

% \subsubsection{\VMinus:}

% \begin{center}
%     \begin{bnf}
%     $\ealpha$ : \textsf{$\alpha$-Expressions} ::=
%     | $\alpha$ : terminating alpha
%     | $x, y, z$ : names
%     % Question: ebnf braces vs. 
%     | $\tt{if} \; \tt{[}\; \galpha \; \bracketed{[] \galpha} \;\tt{]} \; \tt{fi}$ : if-fi 
%     | $K \bracketed{\ealpha}$ : value constructor application 
%     | $\ealpha[1] \; \ealpha[2]$ : function application 
%     ;;
%     $\galpha$ : \textsf{Guarded Expressions} ::=  
%     $\boldsymbol{\rightarrow}\ealpha$ : terminating $\ealpha$ 
%     | $\ealpha; \; \galpha$ : intermediate expression 
%     | $\exists \bracketed{x} \tt{.} \galpha$ : existential 
%     | $\ealpha[1] = \ealpha[2]; \; \galpha$ : equation 
%     % ;;
%     \end{bnf}
% \end{center}

% \bigskip 

% \subsubsection{\PPlus:}
% \begin{center}
%     \begin{bnf}
% $\expr$ : \textsf{Expressions} ::=
%     | $\ttbraced{\tt{case} \; \expr \; \bracketed{\tt{[} p \; \expr \tt{]}}}$ : case expression 
%     ;;
%     $p$ : \textsf{Patterns} ::= $x$ : name 
%     | $K$ : value constructor 
%     | $\ttbraced{K \; \bracketed{p}}$ : value constructor application 
%     % | $\ttbraced{p \; \tt{when} \; \expr }$ : side condition
%     | $\ttbraced{\tt{oneof} \; p_{1} \;, p_{2} }$ : or-pattern 
%     | $\ttbraced{p \tt{;} \bracketed{\expr \vert \ttbraced{p  <- \expr}}}$ : pattern guard
%     \end{bnf}
% \end{center}


% \bigskip 

% \subsubsection{$D$:}

% \begin{center}
%     \begin{bnf}
%         \Dalpha : \textsf{Decision Tree} ::= 
%         $\tt{case} \; x \; \tt{of} \; 
%         \bracketed{\vert \; K\bracketed{x} \; \tt{=>} \; \Dalpha}
%         [\vert \; x \; \tt{=>} \Dalpha]$ : test node 
%         | $\alpha$ : match node 
%         | $\tt{if} \; x \; \tt{then} \; \Dalpha \; \tt{else} \; \Dalpha$ : condition with two children 
%         | $\tt{let} \; x \; \tt{=} \; \expr \; \tt{in} \; \Dalpha$ : let-bind a name
%         ;;
%         $\expr$ : \textsf{Expressions} ::=
%         | $\mathcal{D}_{\expr}$ : decision trees 
%     \end{bnf}
% \end{center}



\end{document}