\documentclass[manuscript,screen 12pt, nonacm]{acmart}
\let\Bbbk\relax % Fix for amssymb clash 
\usepackage{vmlmacros}
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}
\usepackage{outlines}
\setlength{\headheight}{14.0pt}
\setlength{\footskip}{13.3pt}
\title{An Alternative to Pattern Matching, Inspired by Verse}

\author{Roger Burtonpatel}
\email{roger.burtonpatel@tufts.edu}
\affiliation{%
\institution{Tufts University}
\streetaddress{419 Boston Ave}
  \city{Medford}
  \state{Massachusetts}
  \country{USA}
  \postcode{02155}
  }
\begin{document}
%~\section{Equations subsume pattern matching with popular extensions}
%~\label{pplustovminus}
%     In my introduction I~stated that~\VMinus can be compiled to a decision tree,
%     and that~\VMinus subsumes pattern matching with popular extensions. Having
%     shown the former, I~now show the latter. I~do so by presenting an algorithm
%     \PtoVTran\ which translates~\PPlus to~\VMinus. 
    
%     % , and proving that the
%     % translation preserves semantics. 

%     \subsection{Domains}

%     I~give the names and domains of the translation functions: 
    
%     \begin{align*}
%         &\PtoVTran:~\PPlus Exp\;~\rightarrow\;~\VMinus Exp~\\
%         &\PTran: Pattern\;~\rightarrow\; Name\;~\rightarrow\; Name\ list\ *\ Guard\ list~\\
%         % &\mathcal{B}: Pattern\; ->\; Name\; Set~\\
%     \end{align*}
    
%     The translation functions~\PtoVTran\ and~\PTran\ are defined case by case: 
    
%     %~\subsection{Binding names}
    
%     %~\begin{align*}
%         %     &\Bindings{x} =~\bracketed{x}~\\ 
%         %     &\Bindings{K} =~\bracketed{}~\\
%         %     &\Bindings{K\; p_{1} {\dots} p_{n}} =~\Bindings{p}~\cup {\dots}~\cup~\Bindings{p_{n}}~\\
%         %     &\Bindings{\porp} =~\Bindings{p_{1}}~\cap~\Bindings{p_{2}}~\\
%         %     &\Bindings{\pcommap} =~\Bindings{p}~\cup~\Bindings{p'}~\\
%         %     &\Bindings{\parrowe} =~\Bindings{p}~\\
%         %     &\Bindings{\whenexpr} =~\bracketed{}
%         %~\end{align*}
        
%         \subsection{Translating Expressions}
        
%         \newcommand\btran[1]{\mathcal{B}[\![#1]\!]}
        
%         \begin{align*}
%             &\ptov[exp=x, result=x]~\\
%             &\ptov[exp={K\;~\expr[1] {\dots}~\expr[n]}, result={K\;~\ptovtran{\expr[1]} {\dots}~\ptovtran{\expr[n]}}]~\\
%             &\ptov[exp={\lambda x.\;~\expr}, result={\lambda x.\;~\ptovtran{\expr}}]~\\
%             &\ptov[exp={\expr[1]\;~\expr[2]}, result={\ptovtran{\expr[1]}\;~\ptovtran{\expr[2]}}]~\\
%             % &\ptov[exp={\tt{case}\;~\expr\;  \emptyseq}, result={{\iffitt{\vexists{x}\; x =~\ptovtran{\expr};\;~\iffitt{}}}}]\;~\rm{, $x$ fresh }   \\
%             &\ptovtran{\tt{case}\;~\expr\;  p_{1}\;~\expr[1]~\vert {\dots}~\vert p_{n}\;~\expr[n]}~\rightsquigarrow~\\
%             &\hspace{2em}~\rm{$\forall i.\; 1~\leq i~\leq n:$}~\\
%             &\hspace{2em}~\tt{if } {\vexists{x}\; x~\tt{ = }~\ptovtran{\expr};}\;~\\
%             &\hspace{2em}~\rm{ let } (\mathit{ns}_{1},~\mathit{gs}_{1}) {\dots} (\mathit{ns}_{i},~\mathit{gs}_{i}) =~\ptran{p_{1}}x\;~\cdot\; {\dots}~\cdot\;~\ptran{p_{i}}x~\rm { in }~\\
%             &\hspace{2em}~\iffitt{\vexists{\mathit{ns}_{1}}\; {\mathit{gs}_{1}}~\rightarrow~\ptovtran{\expr[1]};\;
%                        \dbar\; {\dots}~\dbar\;~\vexists {\mathit{ns}_{i}}\; {\mathit{gs}_{i}}~\rightarrow~\ptovtran{\expr[i]}}~\\
%             &\hspace{2em}~\tt{fi}~\\
%             &\hspace{2em}~\rm{, $x$ fresh }
%         \end{align*}
        
%         \subsection{Translating Patterns}
        
%         \begin{align*}
%             &\pattov[pat=y, result={(y, [x = y])}]~\\
%             &\pattov[pat=K, result={([], [x = K])}]~\\
%             &\ptran{K\; p_{1}\; {\dots}\; p_{n}}x~\rightsquigarrow~\\
%             &\hspace{2em}~\rm{$\forall i.\; 1~\leq i~\leq n:$}~\\
%             &\hspace{2em}~\rm{ let } y_{i}~\rm{ be a fresh name, }  \\
%             &\hspace{2em} (\mathit{ns}_{1},~\mathit{gs}_{1}) {\dots} (\mathit{ns}_{i},~\mathit{gs}_{i}) =~\ptran{p_{1}}y_{1}~\cdot {\dots}~\cdot~\ptran{p_{i}}y_{i}~\\
%             &\hspace{2em}~\rm{ in }~\\
%             &\hspace{2em} ({\mathit{ns}_{1}~\cdot {\dots}~\cdot~\mathit{ns}_{i}}~\cdot {y_{1} {\dots} y_{i}}, x = K\; y_{1}\; {\dots}\; y_{i}~\cdot~\;~\mathit{gs}_{1}~\cdot {\dots}~\cdot~\mathit{gs}_{i})~\\
%             &\pattov[pat=\mathit{when}\; e, result={([], [\ptovtran{e}])}]~\\
%             &\pattov[pat=\pcommap, 
%             result={\rm{let } 
%             {(\mathit{ns}_{1},~\mathit{gs}_{1}) =~\ptran{p}x}\; , 
%             {(\mathit{ns}_{2},~\mathit{gs}_{2}) =~\ptran{p'}x}~\rm{ in }
%             (\mathit{ns}_{1}~\cdot~\mathit{ns}_{2},~\mathit{gs}_{1}~\cdot~\mathit{gs}_{2})}]~\\
%             &\pattov[pat=\porp, 
%             result={\rm{let } (\mathit{ns}_{1},~\mathit{gs}_{1}) =~\ptran{p}x\; ,
%             (\mathit{ns}_{2},~\mathit{gs}_{2}) =~\ptran{p'}x~\rm{ in }
%             (\mathit{ns}_{1}~\cdot~\mathit{ns}_{2}, [\mathit{gs}_{1}~\choice~\mathit{gs}_{2}])}]
%         \end{align*}

%     \subsubsection{Significance of the translation}

%     In Section~\ref{extensions}, I~showed how extensions to pattern matching
%     uphold Nice Properties~\ref{p1}~and~\ref{p2}, and how with them, programmers
%     can write more concise code.~\bf{The translation aims to show that if a
%     programmer can code with desirable properties in~\PPlus, they can write code
%     with the same properties in~\VMinus.} Proving this claim formally is a goal
%     for future work. Informally,~\PTran\ does not duplicate code except for
%     introducing new names when translating a constructor-application pattern,
%     and I~believe eliminating this redundancy is possible through a desugaring
%     optimization based off of the laws presented in Section~\ref{ppweird}. 

%     \PtoVTran\ is largely uninteresting, except for the translation from
%     \it{case} to~\iffibf.
        
%     To compile~\it{case} expressions to decision trees as Maranget does,
%     translate~\PPlus to~\D using $(\DTran\; o\;~\PtoVTran)$.
    
%     Finally, I~claim that the translation from~\it{case} expressions to decision
%     trees, $(\DTran\; o\;~\PtoVTran)$, is consistent with Maranget and
%     others~\citep{maranget,scottramsey}. Proving this claim is a good goal for
%     future work; it is not the main focus of this paper. 

    \section{Implementations}

    I~have placed implementations of~\VMinus and~\D at
    \url{https://github.com/rogerburtonpatel/vml}. The implementations are
    complete, from parsers to evaluation to unparsers. In the same repository
    lives the~\tt{dtran} program, which translates from~\VMinus to~\D. With the
    implementations, I~include test cases for
    evaluation of~\VMinus, evaluation
    of~\D, and the translation between the two. 
    In~each of these test cases, the translation preserves semantics. 


    \section{Related and Future Work}

    This paper builds on Augustsson et al.'s Verse Calculus~\citep{verse} and
    decision trees~\citep{maranget}. Augustsson et al. give the formal rewrite
    semantics for the Verse Calculus; Maranget gives an elegant formalism of
    decision trees and a translation algorithm from patterns to decision trees.
    I~attempted to imitate the behavior of the rewrite semantics of~\VC in the
    big-step semantics of~\VMinus by manually rewriting terms in~\VC and
    creating rules that would imitate the ultimate result of term-rewriting.
    Proving the equivalence between the two semantics is the subject of future
    work. I~chose a big-step semantics because it is the style of semantics I~am
    most comfortable with; writing the formalisms this way helped me write the
    code. Using a rewrite semantics instead would more closely relate~\VMinus
    and~\VC, and is a likely future project. Maranget's formalism was the
    foundation off of which I~built~\D. 
    
    Extensions to pattern matching, and how they appeal to language designers,
    find an excellent example in~\citet{guardproposal}. The authors describe
    pattern guards and transformational patterns (another extension to pattern
    matching), both of which allow a Haskell programmer to write more concise
    code using pattern matching. Or-patterns are documented in the OCaml
    Language Reference Manual~\citep{ocaml}.
    
    \citet{augustsson1985compiling}~ gives a foundation in compiling pattern
    matching. \citet{scottramsey} have a crisp example of a match-compilation
    algorithm (pattern matching to decision trees). Scott and Ramsey's algorithm
    structurally inspired mine, and studying the source code from the paper
    aided my implementation. 

    %\subsubsection{Desirable theorems about translations}
    For future work, my top priority is to prove that \DTran\ preserves
    semantics.
    %Solid proofs~will strengthen my
    %argument that~\VMinus is not only a viable alternative to pattern
    %matching syntactically; it is also formally equivalent. 
    Next, I~plan to prove that
    %Two theorems would strengthen the viability of~\VMinus, and are
    %essential targets for future work:~\bf{Proving~
    \VMinus~is deterministic, and that \bf{the big-step semantics of~\VMinus~is
    consistent with the published semantics of~\VC.} As the authors of the Verse
    paper proved that the rewrite semantics of Verse is skew-confluent, I~plan
    to prove that big-step semantics of~\VMinus is deterministic, despite the
    nondeterminism of choosing a guard. Second, \VMinus~is designed to be
    Verse-like, and formalizing the relationship between the two would
    strengthen \VMinus's~viability as a language that compromises between
    pattern matching and equations. 

    Finally, I~would like to explore
    exhaustiveness analysis of~\VMinus.
    Exhaustiveness analysis
    can warn programmers of a missing or extraneous alternative in a~\it{case} expression.
    Owing to its significantly more flexible structure,
    however,~\iffibf may prove trickier to analyze.
    
    
    \section{Discussion: The design of \VMinus}        
    \label{futurework}
    
    %~\subsubsection{\VMinus and~\PPlus, side by side}
    % I~compare~\VMinus with~\PPlus as an exercise in comparing equations with
    % pattern matching. They certainly look similar, which hints that~\VMinus
    % might be as expressive as pattern matching with the three extensions. 
    % Proving this claim is the topic of Section~\ref{pplustovminus}. 
    
    % When might a programmer prefer~\VMinus over~\PPlus, or vice versa? After
    % programming in both, I~have come up with three empirical observations: 
    
    %~\begin{enumerate}
    %   \item~\it{The scrutinee:} When there is no obvious single scrutinee,~\VMinus is more succinct.
    %   When there is a scrutinee,~\PPlus is more succinct. 
    %   \item~\it{Binding and decision-making:} Binding and decision-making are
    %   joined in a single construct in~\VMinus:~\tt{=}.~\PPlus needs different
    %   kinds of syntax, like~\tt{<-}, to express different kinds of binding. And
    %   a programmer wanting for~\tt{let} in~\PPlus will never feel this need in
    %   \VMinus:~\tt{=} subsumes that, too. 
    %   \item~\it{Names:} In~\VMinus, names are explicitly introduced. In
    %   practice, this helps prevent a common mistake in pattern matching in which
    %   a programmer attempts to match a value $v$ on an in-scope name $x$,
    %   expecting the match to succeed iff $x$ evaluates to $v$ at runtime, only
    %   to see the match always succeed. 
    %~\end{enumerate}     
    
    %~\rab{How do you feel about examples for each of these points here? This
    % section is very long, but they help drive these points home.}
    
    
    % An example in~\VC illustrates this precise
    % scenario: 
    
    % FIRST PAPER EXAMPLE 
    
    % IMPORTANTLY,~\VMinus REALLY ISN'T A FUNCTIONAL LOGIC PROGRAMMING LANGUAGE ANYMORE. 
    
    %  Doesn't backtrack
    
    %  No multiple results 
    
    %  Doesn't evaluate functions backwards, have top-level patterns like verse, the list goes on 
    
    % If you're well-versed in functional logic programming, may perceive that
    % imposing such restrictions on choice and names effectively strips away
    % much of Verse's essence as a functional logic programming language. With
    % these constraints enforced, there can be no backtracking, multiple
    % results, backward function evaluation, or top-level patterns, among
    % other classic functional logic programming features. But do not fear:
    % our intent is not to recklessly strip Verse of its meticulously crafted
    % core tenets. Instead, our aim is to extract a select few—namely, its
    % equations, existentials, and nondeterministic evaluation order—and
    % juxtapose them with pattern matching.    
    
    
    %~\section{Addressing how~\PPlus handles unusual pattern combinations}
    %~\label{ppweird}
    %     \PPlus admits of strange-looking patterns: consider~\tt{Cons (when true)
    %     zs}. But these should not be alarming, because such syntactic forms reduce
    %     to normal forms by (direct) application of algebraic laws: 
    
    %     \begin{align}
    %       K (\whenexpr)~\;p2\;~\dots &=== K~\;\_~\;p2\;~\dots,~\whenexpr~\\
    %       K (\whenexpr,~\;p2\;)~\;p3\;~\dots  &=== K~\;p2\;~\;p3\;~\dots,~\whenexpr~\\
    %       K (p1\;,~\whenexpr)~\;p3\;~\dots  &=== K~\;p1\;~\;p3\;~\dots,~\whenexpr~\\
    %       K (\whenexpr~\pbar p2\;)~\;p3\;~\dots &=== (K~\;\_~\;p3\;~\dots,~\whenexpr)~\pbar (K~\;p2\;~\;p3\;~\dots)~\\
    %       K (p1~\pbar~\whenexpr)~\;p3\;~\dots &=== (K~\;p2\;~\;p3\;~\dots)~\pbar (K~\;\_~\;p3\;~\dots,~\whenexpr)  \\
    %       \whenexpr~\leftarrow e &===~\;\_ <- e,~\whenexpr
    %     \end{align}   
        
    %     Repeatedly applying these laws until the program reaches a fixed point
    %     normalizes placements of~\it{when}. Laws (2) and (3) work because~\PPlus
    %     has no side effects and the laws assume all names are unique (the compiler
    %     takes care of this), so changing the order in which patterns match has no
    %     effect on semantics.         
    

%    \subsection{The design of~\VMinus}

    This section is aimed at audience familiar with \VC; in particular, with the
    concept of \it{names as values}.
    
    \subsection{Forms in \VC and \VMinus}
    
    When designing~\VMinus, I~wanted the language to capture the expressiveness
    of~\VC's equations while retaining a similar decision-making construct to
    pattern matching. In~pattern matching, the only decision-making
    construct is~\it{case}; other forms of decision-making like~\it{if}
    desugar to it. In~\VMinus, the only decision-making construct is~\iffibf.
    This design differs from~\VC, which features numerous ways to make decisions by
    combining~\bf{one}, \bf{all}, equations, intermediate expressions,
    and~choice. I~did not want multiple results in~\VMinus, so I~eliminated
    anything that looked like~\bf{all}, and I~combined all of the above
    constructs into the singular form~\iffibf. Like~\it{case}, there is only one
    way to use~\iffibf- unlike \bf{one}, equations, intermediate expressions,
    and~choice in~\VC. By restricting all decision-making to \iffibf,
    programmers cannot ``misuse'' any of the forms in ways that might lead to
    problematic computations, such as multiple results by returning choice as an
    expression. Furthermore, as I've shown in the examples, the way in which programmers use~\iffibf mirrors
    the way they use~\it{case}. 
    
    \subsection{Choice in \VMinus vs. \VC}

    \VC's choice operator is often the culprit behind both
    backtracking and multiple results, which tempted me to remove choice
    from~\VMinus altogether. However, I~want to harness the expressive potential
    of choice, particularly when paired with~\VC's~\bf{one} keyword. When
    combined with choice, \bf{one} elegantly signifies ``proceed if any branch of
    the choice succeeds.'' 
    
    To this end, in~\VMinus, choice is permitted with several modifications:
    
        \begin{enumerate}
        \item Choice may only appear as a condition or 'guard', not as a result
        or the right-hand side of a binding.
        \item If any branch of the choice succeeds, the choice succeeds,
        producing any bindings found in that branch. The program examines the
        branches in a left-to-right order.
        \item The existential $\exists$ may not appear under choice.
        \end{enumerate}
        
        I~introduce one more crucial modification to~\VC: a name in
        \VMinus is an~\it{expression}, not a~\it{value}. This modification,
        coupled with my adjustments to choice, eradicates backtracking. My~rationale is straightforward: if~an expression returns a
        name, and if the program later imposes a new constraint on that
        name, it may necessitate the reevaluation of the earlier expression---a
        scenario I~insist on avoiding. 



        %~\subsubsection{Type-agnostic decision-making: the $\alpha$}
        %~\label{alphas}

        % The three languages look similar: they each have value constructors and
        % a 'decision-making construct' to deal with constructed data. In~\PPlus, the
        % construct is pattern-matching; in~\VMinus, it is the guarded expression; in~\D,
        % it is the decision tree. 

        % Because of this, it might be possible to make all three languages
        %~\it{higher order} in right-hand sides; that is, to parameterize the
        % expressions that occur~\it{after} all decision-making. Imagine an
        % abstract expression $\alpha$ that appears on the right-hand side of a
        %~\it{case} branch, the right-hand side of a guarded expression, or in a
        %~\it{match} node. The abstract syntax of the new~\it{case},~\iffibf,
        % and decision tree might look like this: 
        %~\begin{center}
        %     \begin{bnf}
        %         $\VMinus_{\alpha}$ :~\VMinus with $\alpha$ ::=
        %         $\mathit{if}\;~\mathit{[}\; g\;~\bracketed{[] g}\;~\mathit{]}\;~\mathit{fi}$ : if-fI~with $\alpha$
        %         ;;
        %         $G_{\alpha}$ : Guarded Expressions with $\alpha$ ::=
        %         $[\vexists{\bracketed{x}}]~\bracketed{g}~\boldsymbol{\rightarrow}\alpha$ : 
        %         ;;
        %         $\PPlus_{\alpha}$ :~\PPlus with $\alpha$::=
        %         $\tt{case}\;~\expr\;~\bracketed{p\;~\ttrightarrow\;~\alpha}$ :~\it{case} expression with $\alpha$ 
        %         ;;
        %         $t_{\alpha}$ : Decision Trees with $\alpha$ ::= 
        %         |~\dots : other forms of tree 
        %         | $\alpha$ : match node 
        %     \end{bnf}
        %~\end{center}

        % Why would one want to do this? Well, recall that~\VMinus had to be
        % stripped of multiple results and other~\VC-like constructs in order to
        % retain its desirable efficiency properties. $\alpha$ lets~\VMinus and
        % the other languages do efficient decision-making without worrying about
        % the form of the result. If the result is a complex multi-value or a
        % computation that involves backtracking, it will be agnostic of the
        % decision-making. $\alpha$ makes right-hand sides polymorphic and
        % abstract, so a programmer could potentially insert expressions from~\VC
        % in their place and know that the decision-making before the $\alpha$
        % will still be efficient. This would allow for fuller interoperability
        % between~\VC and~\VMinus. Section~\ref{vminusandvc} further describes
        % why bridging the gap between the two languages might be a worthwhile
        % exercise. 

        % However, the language designer must take special care to ensure no
        % $\alpha$ finds its way into the decision-making itself, or the whole
        % idea falls apart. I~am developing an implementation that enforces this
        % invariant, and may include it in a future publication. 
        
        % Other alpha material: 
% The decision-making construct that gets us there. Whether
% it's a single value (ML-style) a sequence of values (Verse-style), or
% even something else, the $\alpha$ represents~\it{any} ultimate result of
% "making a decision," and it's the ways in which we make decisions that
% we truly care about examining. By making the return result both
% polymorphic and abstract, we eschew the need to worry about its type and
% compatibility with other results of otherwise-equivalent trees. 

% An expression in core Verse evaluates to produce possibly-empty sequence of
% values. In~\VMinus, values depend on the form of abstract expression $\alpha.$
% If $\alpha$ is a Verse-like expression,~\valpha\ will be a value sequence. If it
% is an ML-like expression, it will be a single value. 
            
%         A guarded expression evaluates to produce a~\bf{result}. A result is either
%         a metavalue~\valpha\ or reject. 
            
%         \[\it{r}\;~\rm{::=}\;~\vartheta\;~\vbar~\;~\reject~\]
            
%         \showvjudgement{Eval-Alpha}{\veval{\alpha}{\valpha}}

% Of note in both~\VMinus and~\D is that the 'decision-making construct'
% is annotated with an $\alpha$. This annotation gives us type flexibility on the
% right-hand side of the~\it{terminating} case for each construct
% (\tt{$\rightarrow$ exp} in~\VMinus and the match node in~\D.) 


        %~\subsubsection{Or-patterns and pattern guards}
        %~\label{pplusindependently}
        %~\PPlus has side conditions, guards, and or-patterns. No major
        % functional language has all three of these extensions. Back
        % Section~\ref{extensions}'s examples, I~had to switch from OCaml to
        % Haskell to use guards, and back to OCaml for or-patterns. The two
        % extensions are mutually exclusive in Haskell, OCaml, Scala,
        % Erlang/Elixir, Rust, F\#, Agda.~\citep{haskell, ocaml, scala, erlang,
        % elixir, rust, fsharp, agda}

        % Why is this the case? In my research, I~have yet to encounter a
        % substantial justification for this. I~have several theories: one,
        % reengineering the Haskell parser to integrate or-patterns into the
        % language may be considered too great an effort; two, the lesser
        % popularity of functional programming in comparison to other paradigms
        % has meant there are not enough voices in any one language's community
        % claiming that theirs needs all known extensions to pattern matching;
        % three, Haskell, the only language with guards, is lazy, and lazy
        % semantics may not operate well with or-patterns. Future work may explore
        % if a lazy semantics of~\PPlus is possible; such a study may answer this
        % question. 

        % \subsubsection{Using~\VMinus to inform programming in Verse}
        % \label{vminusandvc}
        
        % At ICFP last year, Tim Sweeney said that he wanted Verse to be an
        % accessible programming language to write a scalable, collaborative
        % metaverse~\citep{timtalk}. Can~\VMinus be aid in this goal? I~can imagine
        % two ways in which it might:
        
        %~\begin{enumerate}
        %     \item~\VMinus could be  a tool to help ease programmers who are
        %     more familiar with pattern matching into the realm of functional
        %     logic programming with equations. 
        %     \item Programs written in Verse using ideas from~\VMinus might have
        %     a friendlier cost model (depending on the compiler)
        %~\end{enumerate}
        
        % To point~1,~\VMinus sits both syntactically and semantically in between
        %~\PPlus and~\VC, which might help a new programmer to Verse bridge the
        % conceptual gap between pattern matching and equations. Also,~\PtoVTran,
        % the $\PPlus~\rightarrow~\VMinus$ translation, could help a programmer 
        % who wishes to write code using pattern matching see how their ideas 
        % can be expressed in Verse. 

        % To point~2, 
        
        % \DTran\ and the proof that~\DTran\ preserves semantics help show that
        % certain computations that use equations for decision-making can be
        % compiled to efficient code. A future project could be to extend~\VMinus
        % to include~\it{all} of~\VC, and use~\DTran to eliminates as much
        % backtracking at runtime as possible, falling back to the VC's fully
        % general evaluation mechanism only when necessary. My hope is that, using
        % these ideas, both the Verse programmer and language designer might make
        % any discovery that allows them to increase the efficiency of full-Verse
        % programs. 

    \section{Conclusion}

    I~have introduced \VMinus, a~language that makes decisions using equations.
    By~example, I have shown that
    programs written in~\VMinus can have the same desirable properties
    as equivalent programs written using pattern matching.
    And~to~show that equations can be compiled to efficient decision trees, I have
    introduced~\D and~\DTran.
    In doing so, I~have demonstrated that
    programming with equations is a promising alternative to pattern matching.
    %%  \D~and~\DTran~serve to demonstrate that~\VMinus is a viable alternative to
    %%  pattern matching on the grounds that they have equivalent cost models:
    %%  pattern matching can be compiled to a decision tree,
    %%  which~\citet{macqueen1985tree} built the foundation for and~\citet{maranget}
    %%  expanded on.

    I~have also fully implemented the languages. They exist for use and
    experimentation: they are syntactically simple and have conceptually
    accessible operational semantics. I~hope that programmers will explore and
    develop their own opinions of these languages, which are publically
    available at~\url{https://github.com/rogerburtonpatel/vml}. 

    % Finally, and in particular with~\VMinus, I~hope to provide a stepping
    % stone between pattern matching and equations that a new programmer to
    % Verse will find illuminating. 
    
    % hope to have paved a small
    % segment of the path that the curious programmer or language enthusiast who
    % wishes to better understand Verse will take. Be they transitioning to
    % equations from pattern matching to equations or curious about how those
    % equations might be compilable to decision trees, I~hope they find the
    % languages, and this document, illuminating. 
    

\end{document}
