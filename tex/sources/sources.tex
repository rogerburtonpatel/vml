\documentclass{article}
\usepackage{hyperref}
\begin{document}

Verse paper: 
\url{https://simon.peytonjones.org/assets/pdfs/verse-icfp23.pdf}

Scala has side conditions (called guards): 
\url{https://docs.scala-lang.org/tour/pattern-matching.html}

\^ Scala can case match on classes! 

Haskell has pattern guards (look up since when): 
    \url{https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-460003.13}


Proposal: 
\url{https://web.engr.oregonstate.edu/~erwig/papers/PGandTP_Haskell00.pdf}

Maragnet paper: 
\url{https://www.cs.tufts.edu/comp/150FP/archive/luc-maranget/jun08.pdf}

Needed: 
\begin{enumerate}
    \item Appeal to authority on pattern matching: 
    
    SPJ Proposal- Pattern matching is a well-appreciated feature of languages
    like ML or Haskell; it greatly simplifies the task of inspecting values of
    structured data types and facilitates succinct function definitions that are
    easy to understand. In its basic form, pattern matching tries to identify a
    certain structure of a value to be processed by a function. This structure
    is specified by a pattern, and if it can be recovered in a value,
    corresponding parts of the value are usually bound to variables. These
    bindings are exploited on the right-hand side of the definition. There are
    numerous proposals for extending the capabilities of patterns and pattern
    matching; in particular, the problems with pattern matching on abstract
    data types have stimulated a lot of research [19, 16, 3, 12, 4, 6, 11].
    Other aspects have also been subject to extensions and generalisations of
    pattern matching [18, 1, 9, 7, 17].
    \item 
\end{enumerate}


\end{document}