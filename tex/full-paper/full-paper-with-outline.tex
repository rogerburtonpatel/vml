%%
\documentclass[manuscript,screen,review, 12pt]{acmart}
\let\Bbbk\relax % Fix for amssymb clash 
\usepackage{vmlmacros}
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}
\usepackage{outlines}
\setlength{\headheight}{14.0pt}
\setlength{\footskip}{13.3pt}
\begin{document}
\title{A Replacement for Pattern Matching, Inspired by Verse}

\author{Roger Burtonpatel}
\email{roger.burtonpatel@tufts.edu}
\affiliation{%
  \institution{Tufts University}
  \streetaddress{419 Boston Ave}
  \city{Medford}
  \state{Massachusetts}
  \country{USA}
  \postcode{02155}
}

\author{Norman Ramsey}
\email{nr@cs.tufts.edu}
\affiliation{%
\institution{Tufts University}
\streetaddress{177 College Ave}
\city{Medford}
\state{Massachusetts}
\country{USA}
\postcode{02155}
}

\author{Milod Kazerounian}
\email{milod.mazerouniantufts.edu}
\affiliation{%
\institution{Tufts University}
\streetaddress{177 College Ave}
\city{Medford}
\state{Massachusetts}
\country{USA}
\postcode{02155}
}

\renewcommand{\shortauthors}{Burtonpatel et al.}

\begin{abstract}
    \it{WILL BE REVISED.}
  Pattern matching is nice and has an appealing cost model, but seems to lack in
  expressiveness: people keep extending it to make it more expressive. Verse
  [cite-Verse] doesn't use pattern matching and instead favors equations, which
  look very simple and surprisingly expressive, but the language's cost model is
  a challenge. Why not look for a compromise? 
  
%   We introduce two small functional languages that
%   attempt to address the limitations of pattern matching in popular functional
%   languages.

  We explore the realm of pattern matching in common functional languages and
  compare it with Verse's equation-based approach. Recognizing the balance
  between expressiveness and efficiency, we introduce two modest functional
  languages aimed at addressing the limitations of prevalent pattern matching
  techniques. We show how a subset of Verse can be compiled to decision trees. 

  \end{abstract}

\maketitle

\section{Introduction}
\it{We will add this at the end.}

Pattern matching is popular and well-researched. However, it often needs to be
augmented with extensions. Is this the most efficient thing to be doing? Can we
take inspiration from Verse and use equations instead? Do Verse's equations
subsume pattern matching with popular extensions? Can we get them at no
additional runtime cost? 
% We consider a toy language with many of the popular
% extensions to pattern matching. 
% \VMinus\ can be compiled to efficient decision
% trees. 


\section{Pattern Matching and Equations}
\subsection{Pattern matching as an upgrade to observer functions}
    \begin{outline}[enumerate]
    \1 \bf{PM dominates observer functions} 
    
    % extensively discussed in abundant literature
    Pattern matching is a well-established and researched construct in
    functional programming languages, and the topic of much rich literature
    [cite, appeal to authority]. A primary appeal of pattern matching is its
    dominance over observer functions\footnote{In functional programming,
    observer functions manually scrutinize and deconstruct data. Examples
    include Scheme's \tt{null?}, \tt{car}, and \tt{cdr}, and ML's \tt{null},
    \tt{hd}, and \tt{tl}.}. Consider implementation of \tt{List.len} in Standard
    ML, using observers in Figure~\ref{fig:observerlen}. \rab{Should I say
    'observers' to avoid repeating myself, or 'observer functions' to use the
    same term for the same thing?}
    
    % Figure 1 illustrates an example in which pattern matching is an elegant solution
    % to a problem (compare to equivalent Standard ML code that manually deconstructs
    % a list:)
    
    
    % Most functional programmers likely prefer the first example 
    
    
    % Pattern matching is a well-established and researched construct in functional
    % programming langauges [cite, appeal to authority]. It shines in its ability to
    % break down constructed data implicity, which is often much preferred to using
    % explict deconstructors like Scheme's \tt{car} and \tt{cdr}. But when deciding to
    % perform a terminal computation based on prior checks that don't involve a single
    % value matching on a pattern, pattern matching struggles to retain its brevity.
    % Consider the following algorithm on an abstract type~\tt{FiniteMap}, involving a
    % lookup function. This examples is a modificaiton of one borrowed from SPJ
    % proposal [cite]. 
    \2 \bf{Example. }

    \begin{figure}[ht!]
        \smllst
        \begin{verbatim}
            fun len ys =
                if null ys 
                then 0 
                else let xs = tl ys 
                     in len xs 
                     end 
        \end{verbatim}
    \caption{Standard ML's \tt{List.len} using observer functions.}
    % \caption{An implementation of \tt{List.len} in Standard ML that does not use 
    % pattern matching.}
    \Description{An implementation of len using null, hd, and tl}
    \label{fig:observerlen}
    \end{figure}
    
    Manual case analysis and deconstruction with observer functions can be both
    error-prone (\rab{say more on this or cite?}) and verbose \rab{can I make
    this claim?}. Most functional programmers would likely prefer the
    implementation of \tt{len} found in Figure~\ref{fig:pmlen}.
    \begin{figure}[htt]
    \begin{verbatim}
            fun len ys =
                case ys 
                of []    => 0
                 | x::xs => 1 + len xs
        \end{verbatim}

    \caption{An equivalent implementation that uses pattern matching.}
    \Description{An implementation of len using implicit deconstruction via
    patterns.}
    \label{fig:pmlen}
    \end{figure}

    As a final step towards simplicity, most functional languages allow
    programmers to merge pattern matching and function declaration in a form of
    syntactic sugar known as a \it{clausal definition}. We present a final
    implementation of \tt{len} using pattern matching with a clausal definition
    in Figure~\ref{fig:pmclausallen}.

    \begin{figure}[ht]
    \smllst
    \begin{verbatim}
            fun len []      = 0
              | len (x::xs) = 1 + len xs
        \end{verbatim}
    \caption{A final implementation that uses pattern matching with a clausal definition.}
    \Description{An implementation of len using pattern matching within a 
    clausal definition.}
    \label{fig:pmclausallen}
    \end{figure}
        

    \1 \bf{Common extensions simplify some special cases that would otherwise be awkward}
\subsection{Extensions as upgrades to pattern matching}

    Indeed, pattern matching serves as a cornerstone in functional programming
    languages as a way to make decisions [cite, appeal to authority]. However,
    in particular instances, pattern matching may prove cumbersome, driving
    functional languages to frequently employ \it{extensions} to mitigate such
    scenarios. 
    
    Below, we illustrate several such instances and demonstrate how popular
    functional languages employ extensions to streamline clunky or verbose code.
    For the sake of comparison, we coin the term \it{bare pattern matching} to
    denote pattern matching \it{without} extensions: in bare pattern matching,
    the only syntactic forms of patterns are names and applications of value
    constructors to zero or more patterns. 
    \2 First, side conditions (OCaml, Erlang, Haskell)

    \3 We show a classic example with if 

\subsubsection{Side conditions}

    First, we illustrate the need for \it{side conditions}\footnote{We use the
    term \it{side conditions} to refer to a pattern followed by a boolean
    expression. Some languages call this a \it{guard}, which we use to describe
    a different, more powerful extension to pattern matching in
    Section~\ref{guards}.}, an extension to pattern matching common in most
    functional languages, including OCaml, Erlang, Scala,
    and~Haskell\footnote{Haskell uses guards to subsume side conditions. We
    discuss guards in Section~\ref{guards}.}. Consider
    Figure~\ref{fig:ifnameof}. 
    
    \begin{figure}[ht]
        \begin{verbatim}
            let nameOf rho e = match e with 
                  NAME n -> if binds rho n then n else raise NotFound
                | _      -> raise NotFound  

                (* where binds rho n == true, where n in dom(rho)
                         binds rho n == false, otherwise
                and NotFound is an exception 
                delcared earlier in the program *)
            \end{verbatim}    
        \caption{An invented function \tt{nameOf}, using an \tt{if} statement}    
        \Description{An implementation of a function nameOf in OCaml, which
        uses pattern matching and an if statement.}
        \label{fig:ifnameof}
    \end{figure}
    
    \3 Then get a side condition: nice. 
    
    Seeing the duplicate right-hand sides of \tt{nameOf}, the reader likely sees
    how the code could be simplified with a \it{side condition} to a pattern,
    i.e., a syntactic form for “match a pattern \it{and} a boolean condition.”
    Fortunately, the \tt{when} keyword in OCaml provides such a form, as seen in
    Figure~\ref{fig:whennameof}.
        
        \begin{figure}[ht]
            \begin{verbatim}
            let nameOf rho e = match e with     
                  NAME n when binds rho n -> n
                | _                       -> raise NotFound  
                \end{verbatim}
            \caption{\tt{nameOf}, using a side condition with \tt{when}}    
            \Description{An implementation of a function nameOf in OCaml, which
            uses pattern matching and a side condition.}
            \label{fig:whennameof}
            \end{figure}

        
    \3 Footnote desugaring of \tt{if} \it{condition} \tt{then} \it{branch1} \tt{else} \it{branch2} to \tt{case} \it{condition} \tt{of} \tt{true =>} \it{branch1} \tt{| false =>} \it{branch2}
    
    \3 Part of what's nice is getting names from the pattern into the condition. 

    Programmers can employ side conditions to streamline cases and minimize
    overhead. One notable advantage of side conditions is their capacity to
    exploit bindings that emerge from the preceding pattern match. For
    instance, the \tt{when} clause in Figure~\ref{fig:whennameof} utilizes \tt{n},
    which is bound in the match of \tt{e} to \tt{NAME n}.

    Side conditions serve to address the necessity of incorporating an extra
    “check”- in this case, a boolean expression- within a pattern. But what if
    the need arises to conduct additional pattern matches within such a check?
    Here, side conditions prove inadequate. Without additional tooling,
    programmers may resort to nested pattern matching as a potential solution;
    yet, this often leads to duplicated right-hand sides and convoluted code
    that is cumbersome to write and challenging to follow at first glance. We
    now consider a more powerful extension to pattern matching which addresses
    this problem. 

 \subsubsection{Pattern guards}
\label{guards}

    % \2 Transition to pat guards: 

    
    % \2 \bf{Example: pat guards} 
    % \rab{Help here:
            % \begin{enumerate}
            % \item I'm quoting a chunk of another paper, including code blocks. 
            % My education up to now hasn't covered this. What's protocol here?
            % \item How can I force the figures to appear in the same order as in 
            %       the original paper? Using [h!] does not appear to be working. 
            % \item With correct formatting, I believe this borrowed example is
            % helpful as a clear example and an appeal to authority to illustrate
            % the expressive power of guards as extensions to pattern matching. Do
            % you agree? 
            % \end{enumerate}}


            % \rab{Better way to begin this next paragraph?}

            While pattern matching is known for its effectiveness in
            deconstructing individual values, its expressiveness diminishes when
            faced with sequential computations. What about when we wish to fire
            a right-hand side (\rab{should I just say "evaluate?" Many authors I read use "fire a
            right-hand side."}) only after \it{multiple
            sequential expressions} match with patterns? Consider the following
            example, borrowed from Erwig and Peyton-Jones (2001): 

    \begin{quote}
    
    \dots suppose we have an abstract data type of finite maps, with a lookup
    operation:

        \begin{verbatim}


lookup :: FiniteMap -> Int -> Maybe Int
        \end{verbatim}

        The lookup returns \tt{Nothing} if the supplied key is not in the domain of
    the mapping, and \tt{(Just v)} otherwise, where \tt{v} is the value that the
    key maps to. Now consider the following definition:


    % \begin{figure}[hbt!]
    \begin{minipage}{\textwidth}
        \begin{verbatim}
clunky env varl var2 | ok1 && 0k2 = val1 + val2 
                        | otherwise  = var1 + var2 
where 
    m1  = lookup env var1 
    m2  = lookup env var2
    ok1 = isJust m1 
    ok2 = isJust m2 
    Just val1 = m1 
    Just val2 = m2    
        \end{verbatim}        
    \end{minipage}
    % \caption{\tt{clunky} in Haskell with bare pattern matching} \Description{An
    % implementation of clunky using only simple pattern matching within a clausal
    % definition.}
    % \label{fig:whereclunky}
    % \end{figure}
        
    \dots This is certainly legal Haskell, but it is a tremendously verbose and
    un-obvious way to achieve the desired effect. Is it any better using case
    expressions?

        % The authors show how explicit pattern matching with \tt{case} may
        % mitigate the verbosity of this problem:
    
    % \begin{figure}[hbt!]
        \begin{minipage}{\textwidth}
            \begin{verbatim}


clunky env var1 var2 = 
    case lookup env var1 of 
        Nothing -> fail 
        Just val1 -> 
            case lookup env var2 of 
            Nothing -> fail 
            Just val2 -> val1 + val2
where 
    fail = var1 + var2
            \end{verbatim}
        \end{minipage}
    % \caption{\tt{clunky} with \tt{case}} 
    % \Description{An implementation of clunky using case.}
    % \label{fig:caseclunky}
    % \end{figure}
    
        This is a bit shorter, but hardly better. Worse, if this was just one
        equation of \tt{clunky}, with others that follow, then the thing would
        not work at all.

    \end{quote}

    (Source: Erwig, Martin, and Simon Peyton Jones. "Pattern guards and transformational patterns." Electronic Notes in Theoretical Computer Science 41.1 (2001): 2-3.)

        To mitigate the problem, the authors propose \it{pattern guards}, a form
        of “smart pattern” in which intermediate patterns bind to
        expressions within a single branch of a match. Their solution with
        pattern guards is shown in Figure~\ref{fig:guardclunky}. 

    \begin{figure}[hbt!]  
        \begin{center}
        \begin{verbatim}
                        clunky env var1 var2    
                           | Just vall <- lookup env var1
                           , Just val2 <- lookup env var2
                           = val1 + val2
        \end{verbatim}
        \it{… other equations for clunky}
        \end{center}    
    \caption{\tt{clunky} with pattern guards} 
    \Description{An implementation of clunky using pattern guards.}
    \label{fig:guardclunky}
    \end{figure}

    Guards offer an elegant solution to the problem of matching on successive
    computations.\footnote{The authors of the proposal show several other
    examples where guards drastically simplify otherwise-maddening code.}
    Additionally, a further power of pattern guards lies in the ability for
    expressions within guards to utilize names bound in preceding guards. This
    enables imperative pattern-matched steps with expressive capabilities akin
    to Haskell's \tt{do} notation [cite or example? I came up with this idea;
    not sure if it exists- I'll look.]. \rab{should this be its own example?}

        % \it{This is obviously better. But now consider something where you need 
        % or-patterns; this fails. }
        \2 \bf{Example: or-patterns}

\subsubsection{Or-patterns}

        In the preceding example, we observed how pattern guards facilitated a
        multi-step computation within a single match. However, what if the
        programmer's intention isn't to match on \it{all} parts of a pattern
        sequence, but instead to match a value on \it{any one} of such a
        sequence of patterns? Our example in Figure~\ref{fig:barepgot}
        illustrates this need. Examining \tt{parent\_game\_of\_token}, written
        in OCaml using bare patterns, many functional programmers likely sense
        the need for such functionality.
        
        
        \begin{figure}
            \begin{center}
                \begin{verbatim}
        let parent_game_of_token token = match token with 
            | BattlePass      -> "Fortnite"
            | ChugJug         -> "Fortnite"
            | TomatoTown      -> "Fortnite"
            | HuntersMark     -> "Bloodborne"
            | SawCleaver      -> "Bloodborne"
            | MoghLordOfBlood -> "Elden Ring"
            | PreatorRykard   -> "Elden Ring"
            | _               -> "Irrelevant"
                \end{verbatim}
            \end{center}    

        \caption{\tt{parent\_game\_of\_token}, with redundant right-hand sides.} 
        \Description{An implementation of parent_game_of_token using bare patterns.}
        \label{fig:barepgot}
        \end{figure}

Thankfully, an extension once again comes to our rescue. \it{Or-patterns}
condense multiple patterns which share right-hand sides, and programmers can
exploit them to eliminate much redundant code
(Figure~\ref{fig:orpgot}).\footnote{Or-patterns are a feature built into OCaml.}

    \begin{figure}
    \begin{center}
    \begin{verbatim}
        let parent_game_of_token token = match token with 
            | BattlePass | ChugJug | TomatoTown  -> "Fortnite"
            | HuntersMark | SawCleaver           -> "Bloodborne"
            | MoghLordOfBlood | PreatorRykard    -> "Elden Ring"
            | _                                  -> "Irrelevant"
    \end{verbatim}
    \end{center}    
    \caption{\tt{parent\_game\_of\_token} using or-patterns.} 
    \Description{An implementation of parent_game_of_token using or-patterns.}
    \label{fig:orpgot}
    \end{figure}

    In addition to the inherent appeal of brevity, or-patterns serve to
    concentrate complexity at a single juncture. Consider a scenario where,
    instead of a string, \tt{parent\_game\_of\_token} yields the outcome of a
    complex computation. In the initial model, duplicating the right-hand sides
    across multiple patterns would necessitate the programmer to manage numerous
    redundant copies of this computation. Or-patterns empower programmers to
    centralize such maintenance at a single point of truth.
    
    \subsection{Verse's equations as an upgrade to observer functions}
    
    \1 \bf{Verse Dominates observer functions }

    Instead of pattern matching, \it{functional logic programming} languages
    like Verse [cite: Verse] may favor equations to test for structural equality
    and create bindings. (Consider the Verse implementation of \tt{len} on a
    list built of nested tuples in Figure~\ref{fig:verselen}).

    \2 \bf{Example.}

    \begin{figure}
        \verselst
        \begin{lstlisting}[numbers=none]
$\exists$ len. len = \ys. 
  one {ys = $\langle \rangle$; 0
       |  $\exists$ x xs. ys = $\langle$x, xs$\rangle$; 1 + len xs}
        \end{lstlisting}
    \caption{\tt{len} in Verse, with existentials and equations.} 
    \Description{An implementation of len in Verse.}
    \label{fig:verselen}
    \end{figure}
    
    \1 \bf{\bf{Verse is comparably pleasing to PM }} 
    



    BIOHAZARD START 

    Equations in Verse take the form \it{x = e}, where \it{x} is a name and
    \it{e} is an expression. At runtime, both \it{x} and any names found in
    \it{e} may be unbound, and unifying these names with values using equations
    is how Verse scrutinizes and deconstructs data. 
    
    Verse's equations are comparably pleasing to pattern matching in their
    brevity and expressiveness, and most functional programmers would likely
    prefer them to observer functions, as well. Equations in Verse, however,
    differ from pattern matching in a few key respects. Like pattern matching,
    equations can attempt to bind values to patterns. In Verse, however, 

    programmers introduce names explicitly 

    leading to differences: 
    105 mistake. 

    In Verse, programmers can also express "do a thing if a condition succeeds":
    guarding an expression with another before a semicolon, 
    idea of failure. 

    INLINE EXAMPLES. 

    Verse's equations comparably pleasing to pattern matching in their brevity
    and expressiveness, though they differ in a few key ways. For one, in Verse,
    the programmer \it{explicitly} introduces the names that appear inside an
    equation with the existential $\exists$. These names will be bound to the
    components of a value when a match succeeds. On line~3 of the example, we
    see the existential $\exists$ introduce two fresh names, \tt{x} and \tt{xs},
    before attempting to bind them to \tt{ys}. These fresh names correspond to
    the \tt{x} and \tt{xs} in (\cref{fig:pmlen}). 

    Also, in Verse's equations, names with prior bindings \it{retain those
    bindings} during matching. This is different from pattern matching, where a
    name in a pattern is always considered fresh and will always succeed in
    binding to a value. This is best illustrated with an example (Figure~TODO). 
    We discuss the implications of this difference in Section~(TODO which).

    % Todo: show "105 student mistake" example. 

    % Todo: write more. 

    % \rab{The transition here feels shaky at best. I'd like help connecting the
    % two points: 1. Verse is comparably pleasing to PM, albeit a bit different
    % and 2. However, Verse has an unpredictable cost model.}

    % BIOHAZARD END 

    % Example above illustrates this. Likely add more. 
    % \1 \bf{Full Verse allows/encourages computations that are bad, cost-wise } 
    
    % \2 \bf{Hard to predict?}
    % \2 \bf{Exponential?}
    % \2 \bf{Multiple results?}
    % \2 \bf{Bad how? }

    However, full Verse allows/encourages computations that are problematic,
    cost-wise. In Verse, names (logical variables) are \tt{values}, and can just
    as easily be the result of evaluating an expression as an integer or tuple.
    To bind these names, Verse, like other functional logic languages, relies on
    unifying its logical variables at runtime to meet a set of program
    constraints [cite]. Unifying logical variables at runtime clasically
    requires backtracking [cite], which can lead to exponential runtime cost
    [cite]. 
        
    Furthermore, rather than returning a single value, an expression in Verse
    evaluates to return a \it{sequence} of zero or more values. As such,
    unifying the results of expressions can quickly lead to """massive
    combinatorials""" whose size can be difficult to predict. (Todo: technical phrase for 'something massive.') 


    \2 Crisp example of this 

    \3 I would say 1-2 short examples that illustrate necessity of backtracking  and multiple results. Also, implementation of standard functions (zip):  maybe hard to predict runtime of functions written like this. Come up with a good example. 

    \3 We outline 2 solutions for this! 

    \end{outline}
\section{Simplification for Study and Synthesis}

We now present solutions to the problem posed above in the form of two small
functional programming languages. % which we informally introduce

\subsection{Introducing \PPlus\ }

\begin{outline}[enumerate]
    \1 \bf{To study "all" the interesting/standard extensions to PM, we introduce}
    \PPlus. Its definition is found in \dots TODO 
    \2 \bf{Definition of \PPlus}
    \2 \bf{{\PPlus} packages common/standard extensions to PM}
    \begin{itemize}
        \item side conditions
        \item or-patterns 
        \item pattern guards 
    \end{itemize}

    \PPlus\ packages common and standard extensions to pattern matching. In
    addition to traditional patterns (maybe say bare patterns?)-- names and
    applications of value constructors-- the language includes pattern guards,
    or-patterns, and side conditions (Footnote: side conditions are subsumed by
    pattern guards [cite?]; they are included for purpose of study.)
    Furthermore, a pattern in \PPlus\ be a \it{sequence} of sub-patterns,
    allowing for combinations of arbitrary numbers of patterns. 
    
    \3 \bf{Examples of \PPlus. }

    Figure~\ref{fig:ppexs} provides an example of how a programmer might utilize
    \PPlus\ to solve the previous problems: 

    TODO fix line nums, add other examples 
    \begin{figure}
        \begin{center}
            \pplst 
            \begin{lstlisting}
        val parent_game_of_token = \t. 
            case t of  
                BattlePass | ChugJug | TomatoTown  -> Fortnite
            | HuntersMark | SawCleaver             -> Bloodborne
            | MoghLordOfBlood | PreatorRykard      -> Elden Ring
            | _                                    -> Irrelevant
        \end{lstlisting}
        \end{center}    
        \caption{\tt{parent\_game\_of\_token} in \PPlus.} 
        \Description{An implementation of parent_game_of_token in \PPlus.}
        \label{fig:ppexs}
        \end{figure}
    
    
\subsection{Addressing how \PPlus\ handles unusual pattern combinations}
\2 \bf{\PPlus\ admits of strange looking patterns, but these should not be alarming. }
\2 \bf{-> Because they reduce to standard things by (direct) application of algebraic laws. }
\3 \bf{\tt{when} within vcons }

    Given its minimal restrictions on what kind of pattern can appear where,
    \PPlus\ admits of strange looking patterns: consider \tt{Cons (when true)
    zs}. But these should not be alarming, because such syntactic forms reduce
    to normal forms by (direct) application of algebraic laws: 

    
        \3 Laws: float out vcon, float out from guard
        \3 \bf{This law is applied repeatedly until we reach a fixed point.}

        \3 K (when e) p2 \dots === K \_ p2 \dots, when e
        \3 K (when e, p2) p3 \dots  === K p2 p3 \dots, when e
        \3 K (p2, when e) p3 \dots  === K p2 p3 \dots, when e
        \3 Footnote: This works because no side fx in \PPlus\ and all names are unique $\uparrow$ 
        \3 K (when e \pbar p2) p3 \dots === (K \_ p3 \dots, when e) \pbar (K p2 p3 \dots)
        \3 K (p1 \pbar when e) p3 \dots === (K p2 p3 \dots) \pbar (K \_ p3 \dots, when e) 
        \3 when e $\leftarrow$ e === \_ <- e, when e

        
        These laws are applied repeatedly until we reach a fixed point. 
        Todo: add in revision 
\subsection{Introducing \VMinus\ }
\1 \bf{We want to study decision-making inspired by Verse.}
        
        To fuel our pursuit of smarter decision-making, we now draw inspiration
        from Verse. We begin by trimming away the aforementioned culprits that
        tends to lead to unpredictable or costly outcomes during runtime:
        backtracking and multiple results. Footnote (Our removing these language
        traits strips much of the identity of Verse; however, we do so in order
        to study only Verse's \it{equations} while grounding ourselves in an
        otherwise-typical programming context of single results and no
        backtracking at runtime.) Both backtracking and multiple results often
        manifest within Verse's choice operator, tempting us to consider its
        removal altogether. However, we are drawn to harnessing the expressive
        potential of this operator, particularly when paired with Verse's 'one'
        keyword. When employed with choice as a condition, 'one' elegantly
        signifies 'proceed if any branch of the choice succeeds. 
        
        \2 \bf{We remove obvious backtracking/multiple results (ask what the notecard says)}
        SAY WHAT CHOICE DOES. 

        To this end, we imagine a new language, \VMinus, in which we permit
        choice with several modifications:

        \begin{enumerate}
        \item Choice may only appear as a condition or 'guard', not as a result
        or the right-hand side of a binding.
        \item If any branch of the choice succeeds, the choice succeeds,
        producing any bindings found in that branch. The program examines the
        branches in a left-to-right order.
        \item The existential $\exists$ may not appear under choice.
        \end{enumerate}

        We introduce one more crucial modification to the Verse runtime: a name
        in \VMinus is an \it{expression} rather than a \it{value}. This
        alteration, coupled with our adjustments to choice, effectively
        \rab{remove 'effectively' here?} eradicates backtracking. Our rationale
        behind this is straightforward: if an expression returns a name, and
        subsequently, the program imposes a new constraint on that name, it may
        necessitate the reevaluation of the earlier expression—- a scenario we
        strive to avoid. An example in Verse illustrates this precise scenario:

        FIRST PAPER EXAMPLE 

        \2 Example 

        \2 IMPORTANTLY, \VMinus REALLY ISN'T A FUNCTIONAL LOGIC PROGRAMMING LANGUAGE ANYMORE. 
        \3 Doesn't backtrack
        \3 No multiple results 
        \3 Doesn't evaluate functions backwards, have top-level patterns like verse, the list goes on 


        The discerning reader, particularly those well-versed in functional
        logic programming, may perceive that imposing such restrictions on
        choice and names effectively strips away much of Verse's essence as a
        functional logic programming language. With these constraints enforced,
        there can be no backtracking, multiple results, backward function
        evaluation, or top-level patterns, among other classic functional logic
        programming features. But do not fear: our intent is not to recklessly
        strip Verse of its meticulously crafted core tenets. Instead, our aim is
        to extract a select few—namely, its equations, existentials, and
        nondeterministic evaluation order—and juxtapose them with pattern
        matching.

        % The reader, especially if they are familiar with functional logic
        % programming, will by now have realized that such restrictions on choice
        % and names effectively eliminate much of the identity of Verse as a
        % functional logic programming language. With them in place, there can be
        % no backtracking, no multiple results, no evaluating functions backwards,
        % no top-level patterns: the list of curios goes on. But fear not: we do
        % not aim to thoughtlessly gut Verse of its meticulously-chosen core
        % features, but rather to extract a select few of them- namely, its
        % equations, existentials, and nondeterministic evaluation order- and
        % compare them with pattern matching. 
    

        Indeed, having stripped out the functional logic programming elements of
        Verse, we are left with just the decision-making bits. To wrap these, we
        add a classic decision-making construct: guarded commands [cite-
        Dijkstra paper, others.] The result is \VMinus. \VMinus is defined in 
        Figure~(TODO, whatever extension solution you choose). 

        % \bf{Choice forces "name knowing." Names must be known in all branches 
        % if bound to unknown variable or bound to known variable if any name 
        % is unknown}.
        
        \2 \bf{We add a classic decision-making construct: Guarded commands. } [cite- Dijkstra paper]
        \2 \bf{The result: \VMinus. }
        
        With these modifications in place, alongside a few additional
        adjustments to the placement of existentials and the timing of choice
        evaluation (footnote: we discuss these later), we unveil a redefined decision-making core. To complete this
        transformation, we incorporate a venerable decision-making construct:
        Guarded commands [cite: Dijkstra]. The result is \VMinus. 

    \1 \bf{Definition of \VMinus}

    To facilitate comparisons and proofs, \VMinus\ and \PPlus\ are each a subset
    of a single unifying language(\cref{fig:unilang}). Column “Unique To” indicates
    which components of this unifying language belong to the sub-languages. 
    \PPlus, \VMinus, and the decision tree language \D\ (Section~TODO) all share 
    the same core of lambdas, value constructors (\it{K}), names, and function 
    application. 


    \1 \bf{Continued Discussion:}

    \2 IMPORTANTLY, \VMinus REALLY ISN'T A FUNCTIONAL LOGIC PROGRAMMING LANGUAGE ANYMORE. 
    \3 Doesn't backtrack
    \3 No multiple results 
    \3 Doesn't evaluate functions backwards, have top-level patterns like verse, the list goes on 



    \subsection{Maybe a subsection break here}
    
    \2 \bf{\VMinus\ admits of many of the same pleasing computations as full Verse. }
    
    Even with multiple modifications, \VMinus\ still allows for many of the same
    pleasing computations as full Verse. Programmers can... 
        \begin{enumerate}
            \item Introduce a set of equations, to be solved in a nondeterministic order 
            \item Guard expressions with those equations 
            \item Flexibly express "proceed when any of these operations succeeds" with choice 
        \end{enumerate}

    Figure~TODO provides an example of how a programmer might utilize
    \VMinus\ to solve the previous problems:

    
    \2 \bf{Examples of programming in \VMinus }
    \3 \bf{Show: beautiful examples. }
    
    Look! It looks just like Verse! 
   
    \2 \bf{\VMinus\ is at least as good as \PPlus? Or just as comparable? }
        Or incomparable? (Why not both?)
    
    \subsection{\VMinus\ and \PPlus, side by side}

    \begin{itemize}
        \item We compare \VMinus\ with \PPlus\ as an exercise in comparing
        equations with pattern matching. 
        \item They definitely look similar: as expressive as pattern. Great! 
        \item{BIG PAYLOAD ALERT}
        \item Bonus 1: You don't need the scrutinee in \VMinus. 
        \item Bonus 2: Binding, checking are all in one construct: =. No
                $\leftarrow$ vs case. No guessing what value patterns match to. 
                And, unlike ML, Haskell, OCaml: no need for \tt{let}.
        \item Bonus 3: Names. Explicit name introduction means we can use a name
        from before and know if it's a pattern or an expression. This prevents
        common mistakes like the kind 105 students make. 
    \end{itemize}
    

    \3 \bf{\bf{This is likely motivated strongly by examples of comparable code.}}

    \4 Let's say 2-3 examples here

    \end{outline}

IN EITHER OF THESE SECTIONS: Semantics of \PPlus, \VMinus

\section{(PAYLOAD) {\VMinus} can be compiled to \D 
        [Evidence that \dots efficiency]}
\begin{outline}[enumerate]
    \1 Maybe say "in our semantics of \PPlus\ and \VMinus, we adhere to the
    strict invariant that no value is examined more than once at runtime. But we wish to go further in our assertion, 
    so we compile \VMinus to a decision tree. 
    \1 \bf{Examples of Decision Trees - From Maragnet. }
    \1 For our compilation, we introduce \D, a language of decision trees. 
    \1 \bf{Definition of \D}
    \2 \bf{Indeed, we are consistent with Maragnet }
    \1 \bf{D is a simple generalization of Maragnet, et al. }
    \1 \bf{Semantics of \D: ML Runtime! Yippee!}
    \1 \bf{\D\ has a great cost model: }

    \bf{A decision tree can be exponential in size but never examines a word of
    the scrutinee more than once. }

    \1 \bf{Algorithm: Translation from \VMinus\ to \D\ : match compiler }
    \1 \bf{Theorem: Translation from \VMinus\ to \D\ preserves semantics }
    \2 \bf{Likely inductive hypothesis. 1-4 sentences on proof max. }
\end{outline}

\section{\PPlus -> \VMinus is interesting (optional)}
\begin{outline}[enumerate]
    \1 \bf{\VMinus subsumes pattern matching}
    \1 \bf{Algorithm: Translation from \PPlus\ to \VMinus}
    \1 \bf{Theorem: Translation from \PPlus\ to \VMinus preserves semantics}
    \1 \bf{Claim: Translation \PPlus\ -> \D\ is consistent with Maragnet and others}
\end{outline}

\section{Related Work}
\section{Future Work}
\begin{outline}[enumerate]
    \1 \bf{Why we wish for $\alpha$s}
    \1 \bf{What's up with \PPlus\ ? It's worth study in its own right- in future work.}
    \2 \bf{\PPlus is interesting because it combines or-patterns with pattern }
        guards. No major functional language does this. 
    \1 \bf{Programs written in Verse using ideas from \VMinus\ might have a }
    friendlier cost model (depending on compiler)
    \1 \bf{\VMinus might give Verse programmers good ideas }
        (That is, how to solve problems in Verse)
    \2 \bf{Examples of programming in Verse in the style of \VMinus }
\end{outline}

\section{Conclusion, Discussion}

\renewcommand\thesection{\Alph{section}}
\setcounter{section}{0}
\section{Proofs}
\begin{outline}
    \1 \bf{Proof: Translation from \VMinus to \D\ preserves semantics }
    \1 \bf{Proof: Translation from \PPlus\ to \VMinus preserves semantics }
    \1 \bf{Proof: Translation from \VMinus to Verse preserves semantics     }
\end{outline}

\section{Trust me on \VMinus (It's reduced to Verse)}
\begin{outline}
    \1 \bf{\VMinus\ has something to do with Verse, semantically }
    \1 \bf{Our semantics of Verse is consistent with ICFP's semantics of Verse }
    \1 \bf{Definition: Our semantics of Verse}
    \1 \bf{Theorem: Translation from \VMinus to Verse preserves semantics     }
\end{outline}

\begin{table}[ht]
    \centering
    \small
    \begin{tabular}{l l l}
        \textbf{Syntactic Forms} & \textbf{Cases} & \textbf{Unique to} \\
        \hline
        $P$ : Programs & $\bracketed{d}$ & \\
        $d$ : Definitions & $\mathit{val}\; x\; \mathit{=}\; \expr$ & \\
        $\expr$ : Expressions & $x, y, z$ & \\
        & $K\bracketed{\expr}$ &  \\
        & $\lambda x.\; \expr$ & \\
        & $\expr[1]\; \expr[2]$ & \\
        & $\mathit{case}\; \expr\; \bracketed{p\; \rightarrow\; \expr}$ & \PPlus \\
        & $\mathit{if}\; \mathit{[}\; g\; \bracketed{[] g}\; \mathit{]}\; \mathit{fi}$ & \VMinus \\
        & $\dt$ & \D \\
        $\v$ : Values & $K\bracketed{\v}$ & \\
        & $\lambda x.\; \expr$ & \\
        $p$ : Patterns & $x$ & \PPlus \\
        & $K\; \bracketed{p}$ & \PPlus \\
        & $\mathit{when}\; \expr$ & \PPlus \\
        & $p, p'$ & \PPlus \\
        & $p\; \boldsymbol{\leftarrow}\; \expr$ & \PPlus \\
        & $p_{1}\pbar p_{2}$ & \PPlus \\
        $g$ : Guarded Expressions & $\boldsymbol{\rightarrow}\expr$ & \VMinus \\
        & $\expr;\; g$ & \VMinus \\
        & $\vexists{x} g$ & \VMinus \\
        & $x = \expr;\; g$ & \VMinus \\
        \dt : Decision Trees & $\mathit{case}\; x\; \mathit{of}\; \bracketed{\vert\; K\bracketed{x}\; \mathit{=>}\; \dt} [\vert\; x\; \mathit{=>} \dt]$ & \D \\
        & $\expr$ & \D \\
        & $\mathit{if}\; x\; \mathit{then}\; \dt\; \mathit{else}\; \dt$ & \D \\
        & $\mathit{let}\; x\; \mathit{=}\; \expr\; \mathit{in}\; \dt$ & \D \\
    \end{tabular}
    \caption{Example LaTeX Table}
    \label{fig:unilang}
\end{table}



%     \item Programmers use pattern matching. But pattern matching is not good for
%     everything. 
%     \item Consider Example. 
%     \item Explain example. 
%     \item Attempted mitigations in the past: extensions, SPJ example. 
%     \item We go futher. 
%     \item \bf{P3}: 
%     \item Contribution: 2 languages that attempt to mitigate this problem. 
%     \item Our goal: One simple, expressive, efficient decision-making construct.
%     \item One is {\PPlus}, the other is {\VMinus}. 
%     \item Example of {\VMinus} in action on prior example. 
% \end{itemize}

% We begin by informally introducing two small functional programming languages to
% address the issue of inflexibility of patterns.

% {\PPlus} models standard pattern matching with common extensions. {\VMinus}
% models Verse without features that lead to unpredictable costs (backtracking and
% multiple results) [cite-Verse]. 

% To aid proofs of efficiency, we also introduce a third langauge, {\D}. {\D} is a
% language of decision trees to which both {\PPlus} and {\VMinus} can be
% translated. Targets of translation are efficient in the standard technical
% sense: no value is ever scrutinized more than once (Maranget 2008).

% To facilitate comparisons and proofs, the languages are each a subset of a
% single unifying language(\cref{fig:U}). Asterisks (${}^{*}$) indicate components
% of this unifying language which belong to the sub-languages. 

% % The keen reader will notice that our syntax includes a forms for decision trees,
% % which we have not yet discussed. Decision trees will be crucial in proving
% % properties of efficiency of our languages, and will we be discussed in full in a
% % later section. 

% \begin{figure}[ht!p]
%     \small
%     \begin{flushleft}
%         \begin{bnf}
%         $P$ : \textsf{Programs} ::=
%         $\bracketed{d}$ : definition
%         ;;
%         $d$ : \textsf{Definitions} ::=
%         | $\mathit{val}\; x\; \mathit{=}\; \expr$ : bind name to expression
%         ;;
%         $\expr$ : Expressions ::= 
%         | $x, y, z$             : names
%         | $K\bracketed{\expr}$  : value constructor application 
%         | $\lambda x.\; \expr$  : lambda declaration  
%         | $\expr[1]\; \expr[2]$ : function application 
    
%         | $\mathit{case}\; \expr\; \bracketed{p\; \rightarrow\; \expr}$ : $\rm{case expression}^{*}$
%         | $\mathit{if}\; \mathit{[}\; g\; 
%             \bracketed{[] g}\; \mathit{]}\; \mathit{fi}$                : $\rm{if-fi}^{**}$
%         | $\dt$                                                         : $\rm{decision tree}^{***}$
%         ;;
%         $\v$ : Values ::= 
%           $K\bracketed{\v}$     : value constructor application 
%         | $\lambda x.\; \expr$  : lambda value 
%         ;;
%         $p$ : $\textsf{Patterns}^{*}$ ::= 
%         $x$ : name 
%         | $K\; \bracketed{p}$           : value constructor application 
%         | $\mathit{when}\; \expr$       : side condition
%         | $p, p'$                       : pattern guard 
%         | $p\; \leftarrow\; \expr$      : pattern from explicit expression  
%         | $p_{1}\pbar p_{2}$            : or-pattern
%         ;;
%         $g$ : $\textsf{Guarded Expressions}^{**}$ ::=  
%         $\boldsymbol{\rightarrow}\expr$ : terminating experession
%         | $\expr;\; g$                  : intermediate expression 
%         | $\vexists{x} g$      : existential 
%         | $x = \expr;\; g$              : equation 
%         ;;
%         \dt : $\textsf{Decision Trees}^{***}$ ::= 
%         | $\mathit{case}\; x\; \mathit{of}\; 
%             \bracketed{\vert\; K\bracketed{x}\; \mathit{=>}\; \dt} 
%             [\vert\; x\; \mathit{=>} \dt]$                              : $\rm{test node }^{***}$
%         | $\expr$                                                       : $\rm{match node }^{***}$
%         | $\mathit{if}\; x\; \mathit{then}\; \dt\; \mathit{else}\; \dt$ : $\rm{condition with two children }^{***}$
%         | $\mathit{let}\; x\; \mathit{=}\; \expr\; \mathit{in}\; \dt$   : $\rm{let-bind a name}^{***}$
%         % ;;
%         % $K$ : \textsf{Value Constructors} ::=
%         % | $\mathit{true}\; \vert\; \mathit{false}$ : booleans
%         % | $\mathit{\#}x$                           : name beginning with $\mathit{\#}$
%         % | $\mathit{A-Z}x$                          : name beggining with capital letter
%         % | $[\mathit{-}\vert\mathit{+}]
%         %     (\mathit{0}-\mathit{9})+$              : signed integer literal 
%         \end{bnf}
%         \medskip
        
        
%         \it{Concrete Syntax}: "$\lambda$" and "\exists" each scope as far to
%         the right as possible.
        
%         $\hskip 8em$ For example, $(\lambda y.\> \vexists{x}\> x = 1;\> x + y)$ means 
%         $(\lambda y.\> (\vexists{x}\> ((x = 1);\> (x + y))))$.
        
%         Parentheses may be used freely to aid readability and override default precedence.

%         A \it{name} is any token that is not an integer literal, does not
%         contain whitespace, a bracket, or parenthesis, and is not a value
%         constructor name or a reserved word.
        
%         \medskip

%         % \bf{Desugaring of Extended Expressions}

%         ${}^{*}$ Indicates forms within {\PPlus}

%         ${}^{**}$ Indicates forms within {\VMinus}
        
%         ${}^{***}$ Indicates forms within {\D}

%     \end{flushleft}
    
%     \medskip

    

%     \caption{\U, a decision-making language}
%     \Description{A BNF grammar for \U, the universal decision-making language.
%                  It includes patterns, guarded expressions, and decision trees.}
%     \label{fig:U}
% \end{figure}
% % \begin{table}[ht]
% %     \centering
% %     \small
% %     \begin{tabular}{l l l}
% %         \textbf{Syntactic Forms} & \textbf{Cases} & \textbf{Belong to} \\

% %         $P$ : Programs & $\bracketed{d}$ & many definitions & \\
% %         $d$ : Definitions & $\mathit{val}\; x\; \mathit{=}\; \expr$ & bind name to expression & \\
% %         $\expr$ : Expressions & $x, y, z$ & names & \\
% %         & $K\bracketed{\expr}$ & value constructor applied to expressions & \\
% %         & $\lambda x.\; \expr$ & lambda declaration & \\
% %         & $\expr[1]\; \expr[2]$ & function application & \\
% %         & $\mathit{case}\; \expr\; \bracketed{p\; \rightarrow\; \expr}$ & $\rm{case expression}$ & \\
% %         & $\mathit{if}\; \mathit{[}\; g\; \bracketed{[] g}\; \mathit{]}\; \mathit{fi}$ & $\rm{if-fi}$ & \\
% %         & $\dt$ & $\rm{decision tree}$ & \\
% %         $\v$ : Values & $K\bracketed{\v}$ & value constructor applied to values & \\
% %         & $\lambda x.\; \expr$ & lambda value & \\
% %         $p$ : Patterns & $x$ & name & \\
% %         & $K\; \bracketed{p}$ & value constructor applied to patterns & \\
% %         & $\mathit{when}\; \expr$ & side condition & \\
% %         & $p, p'$ & pattern guard & \\
% %         & $p\; \leftarrow\; \expr$ & pattern from explicit expression & \\
% %         & $p_{1}\pbar p_{2}$ & or-pattern & \\
% %         $g$ : Guarded Expressions & $\boldsymbol{\rightarrow}\expr$ & terminating expression & \\
% %         & $\expr;\; g$ & intermediate expression & \\
% %         & $\vexists{x} g$ & existential & \\
% %         & $x = \expr;\; g$ & equation & \\
% %         \dt : Decision Trees & $\mathit{case}\; x\; \mathit{of}\; \bracketed{\vert\; K\bracketed{x}\; \mathit{=>}\; \dt} [\vert\; x\; \mathit{=>} \dt]$ & $\rm{test node}$ & \\
% %         & $\expr$ & $\rm{match node}$ & \\
% %         & $\mathit{if}\; x\; \mathit{then}\; \dt\; \mathit{else}\; \dt$ & $\rm{condition with two children}$ & \\
% %         & $\mathit{let}\; x\; \mathit{=}\; \expr\; \mathit{in}\; \dt$ & $\rm{let-bind a name}$ & \\
% %     \end{tabular}
% %     \caption{Example LaTeX Table}
% %     \label{tab:example}
% % \end{table}

% Most syntactic categories in \U are present in all of its subsets: Values, Value
% Constructors, Definition Forms, and most forms of expression are shared. Indeed,
% the sub-langauge, like in Verse, is just the the lambda calculus with a few
% extended syntactic categories (this time favoring value constructors over
% tuples). Like in Verse, every Lambda Calculus program is a valid \U program. 

% On top of this core, three languages are defined as subsets of \U. {\PPlus} is
% the subset of~\U including Patterns and the $\mathit{case}\; \expr\;
% \bracketed{p \rightarrow \expr}$ form of case expression. {\VMinus} is the
% subset of \U including Guarded Expressions and \it{if-fi}. Finally, {\D} is the
% subset of \U that includes decision tree syntax, including the reduced case
% expression, $\mathit{case}\; x\; \mathit{of}\; \bracketed{\vert\;
% K\bracketed{x}\; \mathit{=>}\; \dt} [\vert\; x\; \mathit{=>} \dt]$.
% Importantly, the three are mutually exclusive with respect to exactly these
% extensions; all subsets share the sub-langauge and no subset has more than one
% of the expanded \it{case}, \it{if-fi}, or the decision tree syntactic
% categories. 

% % {\PPlus} provides or-patterns, side-conditions, and pattern guards, whose
% % combination does not appear in Haskell, OCaml, Standard ML, or any other major
% % functional language. 
% % \bigskip
% % Next steps: Finish introduction of language table, say where semantics are. 


% \it{The following sections and paragraphs are written:}

% \begin{itemize}
%     \item \bf{Subsection: General Evaluation}
%     \item Big-step opsem with environments. 
%     \item \bf{Subsection: {\PPlus}}
%     \item Patterns, case, environment + disjoint union 
% \end{itemize}

% \it{The following sections and paragraphs are in progress:}
% \begin{itemize}
%     \item when, or-patterns, pattern guards 
%     \item \bf{Subsection: {\VMinus}}
%     \item Guarded expressions, new type of environment
%     \item Evaluation stragety 
% \end{itemize}

% \it{Finally, much has been commented out below because I am still determining
%     the order in which their appearance is most clear. After your review of this
%     initial format, I will begin to include them.}


% % Prior work has introduced extesions to pattern matching [cite, including
% % SPJ proposal for pattern guards.]

% % {\PPlus} provides or-patterns, side-conditions, and pattern guards, whose
% % combination does not appear in Haskell, OCaml, Standard ML, or any other major
% % functional language. 

% % \bigskip
% % interesting thoughts: 

% % Having a strategem for verse to decision tree is analagous to tail recursion. 
% % You have to write your code in a way that allows the optimization. 


% % Pattern matching is a well-established paradigm within functional languages, and
% % """has been the subject of significant discourse.""" \it{Appeal to authority here.}

% % Without pattern matching, it can be tiresome to deconstruct data using manual 
% % accessor functions. Consider the following Standard ML code: 
% % \smllst

% % \begin{lstlisting}
% % val rec len = fn ys => 
% %     if null ys 
% %     then 0 
% %     else let xs = tl ys 
% %          in len xs 
% %          end 
% % \end{lstlisting}
% % \it{An implementation of List.len in Standard ML that does not use pattern 
% %     matching.}

% % Manual checking and deconstruction, with built-in functions like \tt{null} and
% % \tt{tl}, can be both error-prone (\bf{say more on this?}) and verbose. Most
% % functional programmers likely prefer the follwing implementation of \tt{len}:

% % \begin{lstlisting}
% %     val rec len = fn ys => 
% %         case ys 
% %           of [] => 0
% %            | _::xs => 1 + len xs
% %     \end{lstlisting}

% % \it{An equivalent implementation that uses pattern matching.}

% % Indeed, pattern matching is quite appealing when deconstructing data, especially 
% % data that may be represented with an algebraic data type, is the primary programming problem: 



% % \begin{lstlisting}
% % val len = \ys. case ys 
% %                  of [] -> 0
% %                   | _::xs -> 1 + len xs
% % \end{lstlisting}


% % Figure 1 illustrates an example in which pattern matching is an elegant solution
% % to a problem (compare to equivalent Standard ML code that manually deconstructs
% % a list:)


% % Most functional programmers likely prefer the first example 

% % However, language designers continue to extend pattern matching 

% % \section{Pattern Matching as it is Now}
% % \it{Pattern matching} is defined as "checking and locating of specific sequences
% % of data of some pattern among raw data or a sequence of tokens." We will return
% % to the notion of "checking" often in this paper: pattern matching answers the
% % question "when I'm checking to see if a piece of data (called a \it{scrutinee})
% % is of the same form as a certain pattern, does that match succeed or fail?"

% % \it{Example}.

% % In addition to this checking and locating, pattern matching serves as
% % \it{assignment}: it can bind fresh variables based on the form of data and use
% % those bindings in subsequent expressions. 

% % \it{Example}.

% % Here, "checking" means "do the data match what I expect them to." Because
% % pattern matching is inherently built to match a scrutinee (pure data) with a
% % pattern, pattern matching is quite expressive in these cases. 

% % Because of this, most modern functional languages, especially \it{data
% % dependency languages} like Haskell or ML, \it{(is this right?)} employ pattern
% % matching as their main way to deconstruct data (citation?). 

% % We here explore pattern matching through the lens of {\PPlus}, an invented
% % language that has pattern matching along with several of its popular extensions.
% % (The examples above are written in {\PPlus}.) 
% % \subsection{Strengths}

% % - "Checking" and assignment- nice! No car, cdr 

% % - Nested patterns - powerful 

% % - Literal patterns let you mix names and values 

% % \subsection{Weaknesses and Proposed Mitigations}

% % We return to the concept of unifying "checking" with assignment, i.e. "match if
% % the data take this form, and give them names." Pattern matching succeeds here
% % when checking means "is the form of data the way I expect"; in fact, as we know,
% % assignment in general \it{is} pattern matching (figure/example?). But when
% % checking means "does this computation succeed" or "does this binding conflict
% % with a prior binding," pattern matching is at a loss, where Verse succeeds. 

% % Example: 


% % Pattern matching's extensions get closer to unifying "checking" and binding.
% % Here, Verse enjoys a different suite of advantages. 

% % First, its "or" operation (`one` with `choice`) allows for more than patterns to
% % appear as a top-level "choose this or that" construct in a match sequence; you
% % can also include arbitrary expressions. You can't do this in pattern matching's
% % version, which is an or-pattern. Simply put, saying "does this pattern match or
% % is this expression true" is easy in Verse and clunky if you use patterns. I'll
% % show examples at our meeting. 

% % Second, Verse can express operations out of order, letting important checks
% % appear higher up even if they are executed later. This helps program legibility.
% % Again, I have examples from the chapter I wrote today. 

% % Third, in a pattern-match clause, the initial data must still match an initial
% % pattern in order to enter a guard; in Verse there is no restriction. This is
% % minor, because you could simply match the data to a variable, and then enter a
% % guard-- but again, all of these advantages are in elegance and brevity, and
% % elegant that solution is not. 

% % Finally, mingling pattern guards with other extensions to pattern matching
% % (especially or-patterns) is a murky subject. Haskell has pattern guards and side
% % conditions, but no or-patterns. OCaml has side conditions and or-patterns, but
% % no guards. Mixing all three is (according to some readings) simply difficult for
% % implementers- including, interestingly, those of parsers. In Verse, having `one`
% % and `choice` closely tied in with the simple `e1 = e2` equation form, which by
% % itself subsumes pattern matching, side-conditions, and pattern guards, means
% % that integrating options is easy. A key theme that arises of this: Verse has
% % fewer constructs, and they are more expressive.  

% % \section{A Proposal, Inspired by the Verse Calculus}

% % \subsection{Verse Flexibility}
% % \subsection{Something else}
% % \subsection{A third thing}

% % \section{Verse's Equations Subsume Pattern Matching}

% % \subsection{Claim}
% % \subsection{Proof}
% % \subsection{Translations}

% % \section{(Maybe) Writing Efficient Verse Code}

% % \subsection{Claim}
% % \subsection{Proof}
% % \subsection{Translations}


% % \section{Citations and Bibliographies}

\end{document}
\endinput
%%
