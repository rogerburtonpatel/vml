%%
\documentclass[manuscript,screen,review, 12pt]{acmart}
\let\Bbbk\relax % Fix for amssymb clash 
\usepackage{vmlmacros}
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}
\usepackage{outlines}
\setlength{\headheight}{14.0pt}
\setlength{\footskip}{13.3pt}
\begin{document}
\title{A Replacement for Pattern Matching, Inspired by Verse}

\author{Roger Burtonpatel}
\email{roger.burtonpatel@tufts.edu}
\affiliation{%
  \institution{Tufts University}
  \streetaddress{419 Boston Ave}
  \city{Medford}
  \state{Massachusetts}
  \country{USA}
  \postcode{02155}
}

\author{Norman Ramsey}
\email{nr@cs.tufts.edu}
\affiliation{%
\institution{Tufts University}
\streetaddress{177 College Ave}
\city{Medford}
\state{Massachusetts}
\country{USA}
\postcode{02155}
}

\author{Milod Kazerounian}
\email{milod.mazerouniantufts.edu}
\affiliation{%
\institution{Tufts University}
\streetaddress{177 College Ave}
\city{Medford}
\state{Massachusetts}
\country{USA}
\postcode{02155}
}

\renewcommand{\shortauthors}{Burtonpatel et al.}

\begin{abstract}
    \it{WILL BE REVISED.}
  Pattern matching is nice and has an appealing cost model, but seems to lack in
  expressiveness: people keep extending it to make it more expressive. Verse
  [cite-Verse] doesn't use pattern matching and instead favors equations, which
  look very simple and surprisingly expressive, but the language's cost model is
  a challenge. Why not look for a compromise? 
  
%   We introduce two small functional programming languages that
%   attempt to address the limitations of pattern matching in popular functional
%   languages.

  We explore the realm of pattern matching in common functional programming
  languages and compare it with Verse's equation-based approach. Recognizing the
  balance between expressiveness and efficiency, we introduce two toy languages
  aimed at addressing the limitations of prevalent pattern matching techniques.
  We show how a subset of Verse can be compiled to decision trees. 

  \end{abstract}

\maketitle

\section{Introduction}
\it{We will add this at the end.}

Pattern matching is popular and well-researched. However, it often needs to be
augmented with extensions. Is this the most efficient thing to be doing? Can we
take inspiration from Verse and use equations instead? Do Verse's equations
subsume pattern matching with popular extensions? Can we get them at no
additional runtime cost? 
% We consider a toy language with many of the popular
% extensions to pattern matching. 
% \VMinus\ can be compiled to efficient decision
% trees. 


\section{Pattern Matching and Equations}
\subsection{Pattern matching as an upgrade to observer functions}
    \begin{outline}[enumerate]
    
    
    % extensively discussed in abundant literature
    Pattern matching is a well-established and researched construct in
    functional programming languages, and the topic of much rich literature
    [cite, appeal to authority]. A primary appeal of pattern matching is its
    dominance over observer functions\footnote{In functional programming,
    observer functions manually scrutinize and deconstruct data. Examples
    include Scheme's \tt{null?}, \tt{car}, and \tt{cdr}, and ML's \tt{null},
    \tt{hd}, and \tt{tl}.}. Consider implementation of \tt{List.length} in Standard
    ML, using observers in Figure~\ref{fig:observerlen}. \rab{Should I say
    'observers' to avoid repeating myself, or 'observer functions' to use the
    same term for the same thing?}
    
    % Figure 1 illustrates an example in which pattern matching is an elegant solution
    % to a problem (compare to equivalent Standard ML code that manually deconstructs
    % a list:)
    
    
    % Most functional programmers likely prefer the first example 
    
    
    % Pattern matching is a well-established and researched construct in functional
    % programming langauges [cite, appeal to authority]. It shines in its ability to
    % break down constructed data implicity, which is often much preferred to using
    % explict deconstructors like Scheme's \tt{car} and \tt{cdr}. But when deciding to
    % perform a terminal computation based on prior checks that don't involve a single
    % value matching on a pattern, pattern matching struggles to retain its brevity.
    % Consider the following algorithm on an abstract type~\tt{FiniteMap}, involving a
    % lookup function. This examples is a modificaiton of one borrowed from SPJ
    % proposal [cite]. 
    

    \begin{figure}[ht!]
        \smllst
        \captionsetup{justification=centering}
        \begin{verbatim}
            fun length ys =
                if null ys 
                then 0 
                else let xs = tl ys 
                     in length xs 
                     end 
        \end{verbatim}
    \caption{Implementing \tt{List.length} using observer functions is tedious\\\hspace{\textwidth}
    and doesn't look very functional.}
    % \caption{An implementation of \tt{List.length} in Standard ML that does not use 
    % pattern matching.}
    \Description{An implementation of length using null, hd, and tl}
    \label{fig:observerlen}
    \end{figure}
    
    Manual case analysis and deconstruction with observer functions can be both
    error-prone (\rab{say more on this or cite?}) and verbose \rab{can I make
    this claim?}. Most functional programmers would likely prefer the
    implementation of \tt{length} found in Figure~\ref{fig:pmlen}.
    \begin{figure}[htt]
    \begin{verbatim}
            fun length ys =
                case ys 
                of []    => 0
                 | x::xs => 1 + length xs
        \end{verbatim}

    \caption{Using pattern matching makes an equivalent implementation 
             more appealing.}

    \Description{An implementation of length using implicit deconstruction via
    patterns.}
    \label{fig:pmlen}
    \end{figure}

    Figure~\ref{fig:pmlen} is an example of the most common occurrence of where
    pattern matching occurs: within a \tt{case} expression. \tt{case}
    expressions test a \it{head expression} or \it{scrutinee} (\tt{ys} in
    Figure~\ref{fig:pmlen}) against a list of patterns (\tt{[]}, \tt{x::xs}).
    When the result of evaluating the scrutinee matches on a pattern, the
    program evaluates the right-hand side of the respective branch (\tt{0} or
    \tt{1 + length xs}) within the \it{case} expression. 

    As a final step towards simplicity, most functional programming languages
    allow programmers to merge pattern matching and function declaration in a
    form of syntactic sugar known as a \it{clausal definition} that allow the
    programmer to eliminate the top-level \tt{case} entirely.
    Figure~\ref{fig:pmclausallen} shows a final implementation of \tt{length}
    using pattern matching with a clausal definition. 

    \begin{figure}[ht]
    \smllst
    \begin{verbatim}
            fun length []      = 0
              | length (x::xs) = 1 + length xs
        \end{verbatim}
    \caption{Pattern matching with a clausal definition gives a simple and 
             elegant implementation of \tt{List.length}.}
    \Description{An implementation of length using pattern matching within a 
    clausal definition.}
    \label{fig:pmclausallen}
    \end{figure}
        

    
\subsection{Extensions as upgrades to pattern matching}

    Indeed, pattern matching serves as a cornerstone in functional programming
    languages as a way to make decisions [cite, appeal to authority]. However,
    in particular instances, pattern matching may prove cumbersome, driving
    functional programming languages to frequently employ \it{extensions} to mitigate such
    scenarios. 
    
    Below, we illustrate several such instances and demonstrate how popular
    functional programming languages employ extensions to streamline clunky or verbose code.
    For the sake of comparison, we coin the term \it{bare pattern matching} to
    denote pattern matching \it{without} extensions: in bare pattern matching,
    the only syntactic forms of patterns are names and applications of value
    constructors to zero or more patterns. 
    

    

\subsubsection{Side conditions}

    First, we illustrate the need for \it{side conditions}\footnote{We use the
    term \it{side conditions} to refer to a pattern followed by a boolean
    expression. Some languages call this a \it{guard}, which we use to describe
    a different, more powerful extension to pattern matching in
    Section~\ref{guards}.}, an extension to pattern matching common in most
    popular functional programming languages, including OCaml, Erlang, Scala,
    and~Haskell\footnote{Haskell uses guards to subsume side conditions. We
    discuss guards in Section~\ref{guards}.}. Consider
    Figure~\ref{fig:ifnameof}. 
    
    \begin{figure}[ht]
        \begin{verbatim}
            let nameOf rho e = match e with 
                  NAME n -> if binds rho n then n else raise NotFound
                | _      -> raise NotFound  

                (* where binds rho n == true, where n in dom(rho)
                         binds rho n == false, otherwise
                and NotFound is an exception 
                delcared earlier in the program *)
            \end{verbatim}    
        \caption{An invented function \tt{nameOf} combines pattern matching with
        an \tt{if} expression, and is not very pretty.}    
        \Description{An implementation of a function nameOf in OCaml, which
        uses pattern matching and an if statement.}
        \label{fig:ifnameof}
    \end{figure}
    
    
    duplicates a right-hand side, and the actual “good” return of the function,
    \tt{n}, is lost in the middle of the \tt{if} expression. The reader likely
    sees how the code could be simplified with a \it{side condition} to a
    pattern, i.e., a syntactic form for “match a pattern \it{and} a boolean
    condition.” Fortunately, the \tt{when} keyword in OCaml provides such a
    form, as seen in Figure~\ref{fig:whennameof}.
        
        \begin{figure}[ht]
            \begin{verbatim}
            let nameOf rho e = match e with     
                  NAME n when binds rho n -> n
                | _                       -> raise NotFound  
                \end{verbatim}
            \caption{With a side condition, \tt{nameOf} becomes simpler and more
            clear in its goal.}
            \Description{An implementation of a function nameOf in OCaml, which
            uses pattern matching and a side condition.}
            \label{fig:whennameof}
            \end{figure}

        
    
    
    

    Programmers can employ side conditions to streamline cases and minimize
    overhead. One notable advantage of side conditions is their capacity to
    exploit bindings that emerge from the preceding pattern match. For
    instance, the \tt{when} clause in Figure~\ref{fig:whennameof} utilizes \tt{n},
    which is bound in the match of \tt{e} to \tt{NAME n}.

    Side conditions serve to address the necessity of incorporating an extra
    “check”- in this case, a boolean expression- within a pattern. But what if
    the need arises to conduct additional pattern matches within such a check?
    Here, side conditions prove inadequate. Without additional tooling,
    programmers may resort to nested pattern matching as a potential solution;
    yet, this often leads to duplicated right-hand sides and convoluted code
    that is cumbersome to write and challenging to follow at first glance. We
    now consider a more powerful extension to pattern matching which addresses
    this problem. 

 \subsubsection{Pattern guards}
\label{guards}

    % 

    
    % 
    % \rab{Help here:
            % \begin{enumerate}
            % \item I'm quoting a chunk of another paper, including code blocks. 
            % My education up to now hasn't covered this. What's protocol here?
            % \item How can I force the figures to appear in the same order as in 
            %       the original paper? Using [h!] does not appear to be working. 
            % \item With correct formatting, I believe this borrowed example is
            % helpful as a clear example and an appeal to authority to illustrate
            % the expressive power of guards as extensions to pattern matching. Do
            % you agree? 
            % \end{enumerate}}


            % \rab{Better way to begin this next paragraph?}

            While pattern matching is known for its effectiveness in
            deconstructing individual values, its expressiveness diminishes when
            faced with sequential computations. What about when we wish to fire
            a right-hand side (\rab{should I just say "evaluate?" Many authors I read use "fire a
            right-hand side."}) only after \it{multiple
            sequential expressions} match with patterns? Consider the following
            example, borrowed from Erwig and Peyton-Jones (2001): 

    \begin{quote}
    
    \dots suppose we have an abstract data type of finite maps, with a lookup
    operation:

        \begin{verbatim}


lookup :: FiniteMap -> Int -> Maybe Int
        \end{verbatim}

        The lookup returns \tt{Nothing} if the supplied key is not in the domain of
    the mapping, and \tt{(Just v)} otherwise, where \tt{v} is the value that the
    key maps to. Now consider the following definition:


    % \begin{figure}[hbt!]
    \begin{minipage}{\textwidth}
        \begin{verbatim}
clunky env varl var2 | ok1 && 0k2 = val1 + val2 
                        | otherwise  = var1 + var2 
where 
    m1  = lookup env var1 
    m2  = lookup env var2
    ok1 = isJust m1 
    ok2 = isJust m2 
    Just val1 = m1 
    Just val2 = m2    
        \end{verbatim}        
    \end{minipage}
    % \caption{\tt{clunky} in Haskell with bare pattern matching} \Description{An
    % implementation of clunky using only simple pattern matching within a clausal
    % definition.}
    % \label{fig:whereclunky}
    % \end{figure}
        
    \dots This is certainly legal Haskell, but it is a tremendously verbose and
    un-obvious way to achieve the desired effect. Is it any better using case
    expressions?

        % The authors show how explicit pattern matching with \tt{case} may
        % mitigate the verbosity of this problem:
    
    % \begin{figure}[hbt!]
        \begin{minipage}{\textwidth}
            \begin{verbatim}


clunky env var1 var2 = 
    case lookup env var1 of 
        Nothing -> fail 
        Just val1 -> 
            case lookup env var2 of 
            Nothing -> fail 
            Just val2 -> val1 + val2
where 
    fail = var1 + var2
            \end{verbatim}
        \end{minipage}
    % \caption{\tt{clunky} with \tt{case}} 
    % \Description{An implementation of clunky using case.}
    % \label{fig:caseclunky}
    % \end{figure}
    
        This is a bit shorter, but hardly better. Worse, if this was just one
        equation of \tt{clunky}, with others that follow, then the thing would
        not work at all.

    \end{quote}

    (Source: Erwig, Martin, and Simon Peyton Jones. "Pattern guards and transformational patterns." Electronic Notes in Theoretical Computer Science 41.1 (2001): 2-3.)

        To mitigate the problem, the authors propose \it{pattern guards}, a form
        of “smart pattern” in which intermediate patterns bind to
        expressions within a single branch of a match. Their solution with
        pattern guards is shown in Figure~\ref{fig:guardclunky}. 

    \begin{figure}[hbt!]  
        \begin{center}
        \begin{verbatim}
                        clunky env var1 var2    
                           | Just vall <- lookup env var1
                           , Just val2 <- lookup env var2
                           = val1 + val2
        \end{verbatim}
        \it{… other equations for clunky}
        \end{center}    
    \caption{The authors' solution to \tt{clunky} with pattern guards is plainly
    the most elegant.} 
    \Description{An implementation of clunky using pattern
    guards.}
    \label{fig:guardclunky}
    \end{figure}

    Guards offer an elegant solution to the problem of matching on successive
    computations.\footnote{The authors of the proposal show several other
    examples where guards drastically simplify otherwise-maddening code.}
    Additionally, a further power of pattern guards lies in the ability for
    expressions within guards to utilize names bound in preceding guards. This
    enables imperative pattern-matched steps with expressive capabilities akin
    to Haskell's \tt{do} notation [cite or example? I came up with this idea;
    not sure if it exists- I'll look.]. \rab{should this be its own example?}

        % \it{This is obviously better. But now consider something where you need 
        % or-patterns; this fails. }
        

\subsubsection{Or-patterns}

        In the preceding example, we observed how pattern guards facilitated a
        multi-step computation within a single match. However, what if the
        programmer's intention isn't to match on \it{all} parts of a pattern
        sequence, but instead to match a value on \it{any one} of such a
        sequence of patterns? Our example in Figure~\ref{fig:barepgot}
        illustrates this need. Examining \tt{parent\_game\_of\_token}, written
        in OCaml using bare patterns, many functional programmers likely sense
        the need for such functionality.
        
        
        \begin{figure}
            \begin{center}
                \begin{verbatim}
        let parent_game_of_token token = match token with 
            | BattlePass      -> "Fortnite"
            | ChugJug         -> "Fortnite"
            | TomatoTown      -> "Fortnite"
            | HuntersMark     -> "Bloodborne"
            | SawCleaver      -> "Bloodborne"
            | MoghLordOfBlood -> "Elden Ring"
            | PreatorRykard   -> "Elden Ring"
            | _               -> "Irrelevant"
                \end{verbatim}
            \end{center}    

        \caption{\tt{parent\_game\_of\_token}, with redundant right-hand sides,
        should raise a red flag.} 
        \Description{An implementation of
        parent_game_of_token using bare patterns.}
        \label{fig:barepgot}
        \end{figure}

Thankfully, an extension once again comes to our rescue. \it{Or-patterns}
condense multiple patterns which share right-hand sides, and programmers can
exploit them to eliminate much redundant code
(Figure~\ref{fig:orpgot}).\footnote{Or-patterns are a feature built into OCaml.}

    \begin{figure}
    \begin{center}
    \begin{verbatim}
        let parent_game_of_token token = match token with 
            | BattlePass | ChugJug | TomatoTown  -> "Fortnite"
            | HuntersMark | SawCleaver           -> "Bloodborne"
            | MoghLordOfBlood | PreatorRykard    -> "Elden Ring"
            | _                                  -> "Irrelevant"
    \end{verbatim}
    \end{center}    
    \caption{With or-patterns, \tt{parent\_game\_of\_token} condenses
    tremendously and is easier to read line-by-line.} 
    \Description{An
    implementation of parent_game_of_token using or-patterns.}
    \label{fig:orpgot}
    \end{figure}

    In addition to the inherent appeal of brevity, or-patterns serve to
    concentrate complexity at a single juncture. Consider a scenario where,
    instead of a string, \tt{parent\_game\_of\_token} yields the outcome of a
    complex computation. In the initial model, duplicating the right-hand sides
    across multiple patterns would necessitate the programmer to manage numerous
    redundant copies of this computation. Or-patterns empower programmers to
    centralize such maintenance at a single point of truth.
    
    \subsection{Verse's equations as an upgrade to observer functions}
    
    
    
    We now shift focus away from pattern matching to examine a different
    strategy for (programs to make | making) decisions. We focus our study on
    Verse [cite- Verse], a functional logic programming languages [cite- flps].

    Verse uses \it{equations} instead of pattern matching to test for structural
    equality and create bindings. Like pattern matching, equations scrutinize
    and deconstruct data at runtime by testing for structural equality and
    unifying names with values. Unlike pattern matching, Verse's equations can
    unify names on \it{both} the left- and right-hand sides. 
    
    Equations in Verse take the form \it{x = e}, where \it{x} is a name and
    \it{e} is an expression. During runtime, both \it{x} and any unbound names
    in \it{e} are unified with values. Much like pattern matching, unification
    can fail if the runtime attempts to bind incompatible values or structures. 
    
    Consider the Verse implementation of \tt{length} on a list built of nested
    tuples in Figure~\ref{fig:verselen}. Like in the pattern-matching examples
    in Figures~\ref{fig:pmlen} and~\ref{fig:pmclausallen}, the right-hand sides
    of \tt{length} are \it{guarded} by a “check;” now, the check is successful
    unification in an equation rather than a successful match on a pattern. 
    
    % At runtime, both \it{x} and any names found in \it{e} may be unbound, and
    % unifying these names with values using equations is how Verse scrutinizes
    % and deconstructs data. 
    

    % Instead of pattern matching, \it{functional logic programming} languages
    % like Verse [cite: Verse] may favor \it{equations} to test for structural
    % equality and create bindings. 
    

    

    \begin{figure}
        \verselst
        \begin{lstlisting}[numbers=none]
$\exists$ length. length = \ys. 
  one {ys = $\langle \rangle$; 0
       |  $\exists$ x xs. ys = $\langle$x, xs$\rangle$; 1 + length xs}
        \end{lstlisting}
    \caption{\tt{length} in Verse uses existentials and equations rather than
    pattern matching.} 
    \Description{An implementation of length in Verse.}
    \label{fig:verselen}
    \end{figure}
    
    
    


    % BIOHAZARD START 

    % Verse's equations are comparably pleasing to pattern matching in their
    % brevity and expressiveness, and most functional programmers would likely
    % prefer them to observer functions, as well. 
    
    % Equations in Verse, however, differ from pattern matching in a few key
    % respects. 
    
    
    % Like pattern matching, equations can attempt to bind values to patterns. 
    Notice that in Verse, programmers must introduce names explicitly with the
    existential $\exists$. These names will be bound to values when an equation
    succeeds in unifying all pairs of them. On line~3 of the example, we see the
    existential $\exists$ introduce two fresh names, \tt{x} and \tt{xs}, before
    attempting to bind them to (by unifying them with) \tt{ys}. These fresh
    names correspond to the \tt{x} and \tt{xs} in (\cref{fig:pmlen}). 

    Verse's equations appears comparable to pattern matching, and the language
    enjoys several similar forms. 

    

    In Verse, equations always guard expressions; they cannot be returned. Verse
    enforces this restriction in the syntax: expressions may take the form
    \it{eq; e}, where \it{eq} is an equation or an expression. Importantly,
    either form of \it{eq} guards {e}. If \it{eq} fails (returns no results),
    regardless of whether it is an expression or an equation, \it{e} will not be
    evaluated. This means programmers can also express “perform a computation if
    a condition succeeds” with a boolean\footnote{Verse does not have true
    booleans. Instead, it replaces 'true' and 'false' with the notion of
    'success' and 'failure.'} expression in the \it{eq} position. 

    
    any one succeeds, with bindings." 

    % % programmers introduce names explicitly 

    % % leading to differences: 
    % % 105 mistake. 


    % INLINE EXAMPLES. 

    % Verse's equations comparably pleasing to pattern matching in their brevity
    % and expressiveness, though they differ in a few key ways. For one, in Verse,
    % the programmer \it{explicitly} introduces the names that appear inside an
    % equation with the existential $\exists$. These names will be bound to the
    % components of a value when a match succeeds. On line~3 of the example, we
    % see the existential $\exists$ introduce two fresh names, \tt{x} and \tt{xs},
    % before attempting to bind them to \tt{ys}. These fresh names correspond to
    % the \tt{x} and \tt{xs} in (\cref{fig:pmlen}). 

    % Also, in Verse's equations, names with prior bindings \it{retain those
    % bindings} during matching. This is different from pattern matching, where a
    % name in a pattern is always considered fresh and will always succeed in
    % binding to a value. This is best illustrated with an example (Figure~TODO). 
    % We discuss the implications of this difference in Section~(TODO which).

    % Todo: show "105 student mistake" example. 

    % Todo: write more. 

    % \rab{The transition here feels shaky at best. I'd like help connecting the
    % two points: 1. Verse is comparably pleasing to PM, albeit a bit different
    % and 2. However, Verse has an unpredictable cost model.}

    % BIOHAZARD END 

    % Example above illustrates this. Likely add more. 
    % 
    
    % 
    % 
    % 
    % 

    Verse's equations appear to be comparably pleasing to pattern matching
    in their brevity and expressiveness. However, full Verse allows/encourages
    computations that are problematic, cost-wise. In Verse, names (logical
    variables) are \tt{values}, and can just as easily be the result of
    evaluating an expression as an integer or tuple. To bind these names, Verse,
    like other functional logic languages, relies on unifying its logical
    variables at runtime to meet a set of program constraints [cite]. Unifying
    logical variables at runtime clasically requires backtracking [cite], which
    can lead to exponential runtime cost [cite]. 
        
    Furthermore, rather than returning a single value, an expression in Verse
    evaluates to return a \it{sequence} of zero or more values. As such,
    unifying the results of expressions can quickly lead to """massive
    combinatorials""" whose size can be difficult to predict. (Todo: technical phrase for 'something massive.') 


    

    

    

    \end{outline}
\section{Simplification for Study and Synthesis}

We now present solutions to the problem posed above in the form of two small
functional programming languages. % which we informally introduce

\subsection{Introducing \PPlus\ }

\begin{outline}[enumerate]
    
    \PPlus. Its definition is found in \dots TODO 
    
    
    \begin{itemize}
        \item side conditions
        \item or-patterns 
        \item pattern guards 
    \end{itemize}

    \PPlus\ packages common and standard extensions to pattern matching. In
    addition to traditional patterns (maybe say bare patterns?)-- names and
    applications of value constructors-- the language includes pattern guards,
    or-patterns, and side conditions (Footnote: side conditions are subsumed by
    pattern guards [cite?]; they are included for purpose of study.)
    Furthermore, a pattern in \PPlus\ be a \it{sequence} of sub-patterns,
    allowing for combinations of arbitrary numbers of patterns. 
    
    

    Figure~\ref{fig:ppexs} provides an example of how a programmer might utilize
    \PPlus\ to solve the previous problems: 

    TODO fix line nums, add other examples 
    \begin{figure}
        \begin{center}
            \pplst 
            \begin{lstlisting}
        val parent_game_of_token = \t. 
            case t of  
                BattlePass | ChugJug | TomatoTown  -> Fortnite
            | HuntersMark | SawCleaver             -> Bloodborne
            | MoghLordOfBlood | PreatorRykard      -> Elden Ring
            | _                                    -> Irrelevant
        \end{lstlisting}
        \end{center}    
        \caption{\tt{parent\_game\_of\_token} in \PPlus has the same desirable
        implementation as before.} 
        \Description{An implementation of
        parent_game_of_token in \PPlus.}
        \label{fig:ppexs}
        \end{figure}
    
    
\subsection{Addressing how \PPlus\ handles unusual pattern combinations}




    Given its minimal restrictions on what kind of pattern can appear where,
    \PPlus\ admits of strange looking patterns: consider \tt{Cons (when true)
    zs}. But these should not be alarming, because such syntactic forms reduce
    to normal forms by (direct) application of algebraic laws: 

    
        
        

        
        
        
        
        
        
        

        
        These laws are applied repeatedly until we reach a fixed point. 
        Todo: add in revision 
\subsection{Introducing \VMinus\ }

        
        To fuel our pursuit of smarter decision-making, we now draw inspiration
        from Verse. We begin by trimming away the aforementioned culprits that
        tends to lead to unpredictable or costly outcomes during runtime:
        backtracking and multiple results. Footnote (Our removing these language
        traits strips much of the identity of Verse; however, we do so in order
        to study only Verse's \it{equations} while grounding ourselves in an
        otherwise-typical programming context of single results and no
        backtracking at runtime.) Both backtracking and multiple results often
        manifest within Verse's choice operator, tempting us to consider its
        removal altogether. However, we are drawn to harnessing the expressive
        potential of this operator, particularly when paired with Verse's 'one'
        keyword. When employed with choice as a condition, 'one' elegantly
        signifies 'proceed if any branch of the choice succeeds. 
        
        
        SAY WHAT CHOICE DOES. 

        To this end, we imagine a new language, \VMinus, in which we permit
        choice with several modifications:

        \begin{enumerate}
        \item Choice may only appear as a condition or 'guard', not as a result
        or the right-hand side of a binding.
        \item If any branch of the choice succeeds, the choice succeeds,
        producing any bindings found in that branch. The program examines the
        branches in a left-to-right order.
        \item The existential $\exists$ may not appear under choice.
        \end{enumerate}

        We introduce one more crucial modification to the Verse runtime: a name
        in \VMinus is an \it{expression} rather than a \it{value}. This
        alteration, coupled with our adjustments to choice, effectively
        \rab{remove 'effectively' here?} eradicates backtracking. Our rationale
        behind this is straightforward: if an expression returns a name, and
        subsequently, the program imposes a new constraint on that name, it may
        necessitate the reevaluation of the earlier expression—- a scenario we
        strive to avoid. An example in Verse illustrates this precise scenario:

        FIRST PAPER EXAMPLE 

        

        
        
        
        


        The discerning reader, particularly those well-versed in functional
        logic programming, may perceive that imposing such restrictions on
        choice and names effectively strips away much of Verse's essence as a
        functional logic programming language. With these constraints enforced,
        there can be no backtracking, multiple results, backward function
        evaluation, or top-level patterns, among other classic functional logic
        programming features. But do not fear: our intent is not to recklessly
        strip Verse of its meticulously crafted core tenets. Instead, our aim is
        to extract a select few—namely, its equations, existentials, and
        nondeterministic evaluation order—and juxtapose them with pattern
        matching.

        % The reader, especially if they are familiar with functional logic
        % programming, will by now have realized that such restrictions on choice
        % and names effectively eliminate much of the identity of Verse as a
        % functional logic programming language. With them in place, there can be
        % no backtracking, no multiple results, no evaluating functions backwards,
        % no top-level patterns: the list of curios goes on. But fear not: we do
        % not aim to thoughtlessly gut Verse of its meticulously-chosen core
        % features, but rather to extract a select few of them- namely, its
        % equations, existentials, and nondeterministic evaluation order- and
        % compare them with pattern matching. 
    

        Indeed, having stripped out the functional logic programming elements of
        Verse, we are left with just the decision-making bits. To wrap these, we
        add a classic decision-making construct: guarded commands [cite-
        Dijkstra paper, others.] The result is \VMinus. \VMinus is defined in 
        Figure~(TODO, whatever extension solution you choose). 

        % \bf{Choice forces "name knowing." Names must be known in all branches 
        % if bound to unknown variable or bound to known variable if any name 
        % is unknown}.
        
        
        
        
        With these modifications in place, alongside a few additional
        adjustments to the placement of existentials and the timing of choice
        evaluation (footnote: we discuss these later), we unveil a redefined decision-making core. To complete this
        transformation, we incorporate a venerable decision-making construct:
        Guarded commands [cite: Dijkstra]. The result is \VMinus. 

    

    To facilitate comparisons and proofs, \VMinus\ and \PPlus\ are each a subset
    of a single unifying language(\cref{fig:unilang}). Column “Unique To” indicates
    which components of this unifying language belong to the sub-languages. 
    \PPlus, \VMinus, and the decision tree language \D\ (Section~TODO) all share 
    the same core of lambdas, value constructors (\it{K}), names, and function 
    application. 


    

    
    
    
    



    \subsection{Maybe a subsection break here}
    
    
    
    Even with multiple modifications, \VMinus\ still allows for many of the same
    pleasing computations as full Verse. Programmers can... 
        \begin{enumerate}
            \item Introduce a set of equations, to be solved in a nondeterministic order 
            \item Guard expressions with those equations 
            \item Flexibly express "proceed when any of these operations succeeds" with choice 
        \end{enumerate}

    Figure~TODO provides an example of how a programmer might utilize
    \VMinus\ to solve the previous problems:

    
    
    
    
    Look! It looks just like Verse! 
   
    
        Or incomparable? (Why not both?)
    
    \subsection{\VMinus\ and \PPlus, side by side}

    \begin{itemize}
        \item We compare \VMinus\ with \PPlus\ as an exercise in comparing
        equations with pattern matching. 
        \item They definitely look similar: as expressive as pattern. Great! 
        \item{BIG PAYLOAD ALERT}
        \item Bonus 1: You don't need the scrutinee in \VMinus. 
        \item Bonus 2: Binding, checking are all in one construct: =. No
                $\leftarrow$ vs case. No guessing what value patterns match to. 
                And, unlike ML, Haskell, OCaml: no need for \tt{let}.
        \item Bonus 3: Names. Explicit name introduction means we can use a name
        from before and know if it's a pattern or an expression. This prevents
        common mistakes like the kind 105 students make. 
    \end{itemize}
    

    

    

    \end{outline}

IN EITHER OF THESE SECTIONS: Semantics of \PPlus, \VMinus

\section{(PAYLOAD) {\VMinus} can be compiled to \D 
        [Evidence that \dots efficiency]}
\begin{outline}[enumerate]
    
    strict invariant that no value is examined more than once at runtime. But we wish to go further in our assertion, 
    so we compile \VMinus to a decision tree. 
    
    
    
    
    
    
    

    \bf{A decision tree can be exponential in size but never examines a word of
    the scrutinee more than once. }

    
    
    
\end{outline}

\section{\PPlus -> \VMinus is interesting (optional)}
\begin{outline}[enumerate]
    
    
    
    
\end{outline}

\section{Related Work}
\section{Future Work}
\begin{outline}[enumerate]
    
    
    
        guards. No major functional language does this. 
    
    friendlier cost model (depending on compiler)
    
        (That is, how to solve problems in Verse)
    
\end{outline}

\section{Conclusion, Discussion}

\renewcommand\thesection{\Alph{section}}
\setcounter{section}{0}
\section{Proofs}
\begin{outline}
    
    
    
\end{outline}

\section{Trust me on \VMinus (It's reduced to Verse)}
\begin{outline}
    
    
    
    
\end{outline}

\begin{table}[ht]
    \centering
    \small
    \begin{tabular}{l l l}
        \textbf{Syntactic Forms} & \textbf{Cases} & \textbf{Unique to} \\
        \hline
        $P$ : Programs & $\bracketed{d}$ & \\
        $d$ : Definitions & $\mathit{val}\; x\; \mathit{=}\; \expr$ & \\
        $\expr$ : Expressions & $x, y, z$ & \\
        & $K\bracketed{\expr}$ &  \\
        & $\lambda x.\; \expr$ & \\
        & $\expr[1]\; \expr[2]$ & \\
        & $\mathit{case}\; \expr\; \bracketed{p\; \rightarrow\; \expr}$ & \PPlus \\
        & $\mathit{if}\; \mathit{[}\; g\; \bracketed{[] g}\; \mathit{]}\; \mathit{fi}$ & \VMinus \\
        & $\dt$ & \D \\
        $\v$ : Values & $K\bracketed{\v}$ & \\
        & $\lambda x.\; \expr$ & \\
        $p$ : Patterns & $x$ & \PPlus \\
        & $K\; \bracketed{p}$ & \PPlus \\
        & $\mathit{when}\; \expr$ & \PPlus \\
        & $p, p'$ & \PPlus \\
        & $p\; \boldsymbol{\leftarrow}\; \expr$ & \PPlus \\
        & $p_{1}\pbar p_{2}$ & \PPlus \\
        $g$ : Guarded Expressions & $\boldsymbol{\rightarrow}\expr$ & \VMinus \\
        & $\expr;\; g$ & \VMinus \\
        & $\vexists{x} g$ & \VMinus \\
        & $x = \expr;\; g$ & \VMinus \\
        \dt : Decision Trees & $\mathit{case}\; x\; \mathit{of}\; \bracketed{\vert\; K\bracketed{x}\; \mathit{=>}\; \dt} [\vert\; x\; \mathit{=>} \dt]$ & \D \\
        & $\expr$ & \D \\
        & $\mathit{if}\; x\; \mathit{then}\; \dt\; \mathit{else}\; \dt$ & \D \\
        & $\mathit{let}\; x\; \mathit{=}\; \expr\; \mathit{in}\; \dt$ & \D \\
    \end{tabular}
    \caption{Example LaTeX Table}
    \label{fig:unilang}
\end{table}



%     \item Programmers use pattern matching. But pattern matching is not good for
%     everything. 
%     \item Consider Example. 
%     \item Explain example. 
%     \item Attempted mitigations in the past: extensions, SPJ example. 
%     \item We go futher. 
%     \item \bf{P3}: 
%     \item Contribution: 2 languages that attempt to mitigate this problem. 
%     \item Our goal: One simple, expressive, efficient decision-making construct.
%     \item One is {\PPlus}, the other is {\VMinus}. 
%     \item Example of {\VMinus} in action on prior example. 
% \end{itemize}

% We begin by informally introducing two small functional programming languages to
% address the issue of inflexibility of patterns.

% {\PPlus} models standard pattern matching with common extensions. {\VMinus}
% models Verse without features that lead to unpredictable costs (backtracking and
% multiple results) [cite-Verse]. 

% To aid proofs of efficiency, we also introduce a third langauge, {\D}. {\D} is a
% language of decision trees to which both {\PPlus} and {\VMinus} can be
% translated. Targets of translation are efficient in the standard technical
% sense: no value is ever scrutinized more than once (Maranget 2008).

% To facilitate comparisons and proofs, the languages are each a subset of a
% single unifying language(\cref{fig:U}). Asterisks (${}^{*}$) indicate components
% of this unifying language which belong to the sub-languages. 

% % The keen reader will notice that our syntax includes a forms for decision trees,
% % which we have not yet discussed. Decision trees will be crucial in proving
% % properties of efficiency of our languages, and will we be discussed in full in a
% % later section. 

% \begin{figure}[ht!p]
%     \small
%     \begin{flushleft}
%         \begin{bnf}
%         $P$ : \textsf{Programs} ::=
%         $\bracketed{d}$ : definition
%         ;;
%         $d$ : \textsf{Definitions} ::=
%         | $\mathit{val}\; x\; \mathit{=}\; \expr$ : bind name to expression
%         ;;
%         $\expr$ : Expressions ::= 
%         | $x, y, z$             : names
%         | $K\bracketed{\expr}$  : value constructor application 
%         | $\lambda x.\; \expr$  : lambda declaration  
%         | $\expr[1]\; \expr[2]$ : function application 
    
%         | $\mathit{case}\; \expr\; \bracketed{p\; \rightarrow\; \expr}$ : $\rm{case expression}^{*}$
%         | $\mathit{if}\; \mathit{[}\; g\; 
%             \bracketed{[] g}\; \mathit{]}\; \mathit{fi}$                : $\rm{if-fi}^{**}$
%         | $\dt$                                                         : $\rm{decision tree}^{***}$
%         ;;
%         $\v$ : Values ::= 
%           $K\bracketed{\v}$     : value constructor application 
%         | $\lambda x.\; \expr$  : lambda value 
%         ;;
%         $p$ : $\textsf{Patterns}^{*}$ ::= 
%         $x$ : name 
%         | $K\; \bracketed{p}$           : value constructor application 
%         | $\mathit{when}\; \expr$       : side condition
%         | $p, p'$                       : pattern guard 
%         | $p\; \leftarrow\; \expr$      : pattern from explicit expression  
%         | $p_{1}\pbar p_{2}$            : or-pattern
%         ;;
%         $g$ : $\textsf{Guarded Expressions}^{**}$ ::=  
%         $\boldsymbol{\rightarrow}\expr$ : terminating experession
%         | $\expr;\; g$                  : intermediate expression 
%         | $\vexists{x} g$      : existential 
%         | $x = \expr;\; g$              : equation 
%         ;;
%         \dt : $\textsf{Decision Trees}^{***}$ ::= 
%         | $\mathit{case}\; x\; \mathit{of}\; 
%             \bracketed{\vert\; K\bracketed{x}\; \mathit{=>}\; \dt} 
%             [\vert\; x\; \mathit{=>} \dt]$                              : $\rm{test node }^{***}$
%         | $\expr$                                                       : $\rm{match node }^{***}$
%         | $\mathit{if}\; x\; \mathit{then}\; \dt\; \mathit{else}\; \dt$ : $\rm{condition with two children }^{***}$
%         | $\mathit{let}\; x\; \mathit{=}\; \expr\; \mathit{in}\; \dt$   : $\rm{let-bind a name}^{***}$
%         % ;;
%         % $K$ : \textsf{Value Constructors} ::=
%         % | $\mathit{true}\; \vert\; \mathit{false}$ : booleans
%         % | $\mathit{\#}x$                           : name beginning with $\mathit{\#}$
%         % | $\mathit{A-Z}x$                          : name beggining with capital letter
%         % | $[\mathit{-}\vert\mathit{+}]
%         %     (\mathit{0}-\mathit{9})+$              : signed integer literal 
%         \end{bnf}
%         \medskip
        
        
%         \it{Concrete Syntax}: "$\lambda$" and "\exists" each scope as far to
%         the right as possible.
        
%         $\hskip 8em$ For example, $(\lambda y.\> \vexists{x}\> x = 1;\> x + y)$ means 
%         $(\lambda y.\> (\vexists{x}\> ((x = 1);\> (x + y))))$.
        
%         Parentheses may be used freely to aid readability and override default precedence.

%         A \it{name} is any token that is not an integer literal, does not
%         contain whitespace, a bracket, or parenthesis, and is not a value
%         constructor name or a reserved word.
        
%         \medskip

%         % \bf{Desugaring of Extended Expressions}

%         ${}^{*}$ Indicates forms within {\PPlus}

%         ${}^{**}$ Indicates forms within {\VMinus}
        
%         ${}^{***}$ Indicates forms within {\D}

%     \end{flushleft}
    
%     \medskip

    

%     \caption{\U, a decision-making language}
%     \Description{A BNF grammar for \U, the universal decision-making language.
%                  It includes patterns, guarded expressions, and decision trees.}
%     \label{fig:U}
% \end{figure}
% % \begin{table}[ht]
% %     \centering
% %     \small
% %     \begin{tabular}{l l l}
% %         \textbf{Syntactic Forms} & \textbf{Cases} & \textbf{Belong to} \\

% %         $P$ : Programs & $\bracketed{d}$ & many definitions & \\
% %         $d$ : Definitions & $\mathit{val}\; x\; \mathit{=}\; \expr$ & bind name to expression & \\
% %         $\expr$ : Expressions & $x, y, z$ & names & \\
% %         & $K\bracketed{\expr}$ & value constructor applied to expressions & \\
% %         & $\lambda x.\; \expr$ & lambda declaration & \\
% %         & $\expr[1]\; \expr[2]$ & function application & \\
% %         & $\mathit{case}\; \expr\; \bracketed{p\; \rightarrow\; \expr}$ & $\rm{case expression}$ & \\
% %         & $\mathit{if}\; \mathit{[}\; g\; \bracketed{[] g}\; \mathit{]}\; \mathit{fi}$ & $\rm{if-fi}$ & \\
% %         & $\dt$ & $\rm{decision tree}$ & \\
% %         $\v$ : Values & $K\bracketed{\v}$ & value constructor applied to values & \\
% %         & $\lambda x.\; \expr$ & lambda value & \\
% %         $p$ : Patterns & $x$ & name & \\
% %         & $K\; \bracketed{p}$ & value constructor applied to patterns & \\
% %         & $\mathit{when}\; \expr$ & side condition & \\
% %         & $p, p'$ & pattern guard & \\
% %         & $p\; \leftarrow\; \expr$ & pattern from explicit expression & \\
% %         & $p_{1}\pbar p_{2}$ & or-pattern & \\
% %         $g$ : Guarded Expressions & $\boldsymbol{\rightarrow}\expr$ & terminating expression & \\
% %         & $\expr;\; g$ & intermediate expression & \\
% %         & $\vexists{x} g$ & existential & \\
% %         & $x = \expr;\; g$ & equation & \\
% %         \dt : Decision Trees & $\mathit{case}\; x\; \mathit{of}\; \bracketed{\vert\; K\bracketed{x}\; \mathit{=>}\; \dt} [\vert\; x\; \mathit{=>} \dt]$ & $\rm{test node}$ & \\
% %         & $\expr$ & $\rm{match node}$ & \\
% %         & $\mathit{if}\; x\; \mathit{then}\; \dt\; \mathit{else}\; \dt$ & $\rm{condition with two children}$ & \\
% %         & $\mathit{let}\; x\; \mathit{=}\; \expr\; \mathit{in}\; \dt$ & $\rm{let-bind a name}$ & \\
% %     \end{tabular}
% %     \caption{Example LaTeX Table}
% %     \label{tab:example}
% % \end{table}

% Most syntactic categories in \U are present in all of its subsets: Values, Value
% Constructors, Definition Forms, and most forms of expression are shared. Indeed,
% the sub-langauge, like in Verse, is just the the lambda calculus with a few
% extended syntactic categories (this time favoring value constructors over
% tuples). Like in Verse, every Lambda Calculus program is a valid \U program. 

% On top of this core, three languages are defined as subsets of \U. {\PPlus} is
% the subset of~\U including Patterns and the $\mathit{case}\; \expr\;
% \bracketed{p \rightarrow \expr}$ form of case expression. {\VMinus} is the
% subset of \U including Guarded Expressions and \it{if-fi}. Finally, {\D} is the
% subset of \U that includes decision tree syntax, including the reduced case
% expression, $\mathit{case}\; x\; \mathit{of}\; \bracketed{\vert\;
% K\bracketed{x}\; \mathit{=>}\; \dt} [\vert\; x\; \mathit{=>} \dt]$.
% Importantly, the three are mutually exclusive with respect to exactly these
% extensions; all subsets share the sub-langauge and no subset has more than one
% of the expanded \it{case}, \it{if-fi}, or the decision tree syntactic
% categories. 

% % {\PPlus} provides or-patterns, side-conditions, and pattern guards, whose
% % combination does not appear in Haskell, OCaml, Standard ML, or any other major
% % functional language. 
% % \bigskip
% % Next steps: Finish introduction of language table, say where semantics are. 


% \it{The following sections and paragraphs are written:}

% \begin{itemize}
%     \item \bf{Subsection: General Evaluation}
%     \item Big-step opsem with environments. 
%     \item \bf{Subsection: {\PPlus}}
%     \item Patterns, case, environment + disjoint union 
% \end{itemize}

% \it{The following sections and paragraphs are in progress:}
% \begin{itemize}
%     \item when, or-patterns, pattern guards 
%     \item \bf{Subsection: {\VMinus}}
%     \item Guarded expressions, new type of environment
%     \item Evaluation stragety 
% \end{itemize}

% \it{Finally, much has been commented out below because I am still determining
%     the order in which their appearance is most clear. After your review of this
%     initial format, I will begin to include them.}


% % Prior work has introduced extesions to pattern matching [cite, including
% % SPJ proposal for pattern guards.]

% % {\PPlus} provides or-patterns, side-conditions, and pattern guards, whose
% % combination does not appear in Haskell, OCaml, Standard ML, or any other major
% % functional language. 

% % \bigskip
% % interesting thoughts: 

% % Having a strategem for verse to decision tree is analagous to tail recursion. 
% % You have to write your code in a way that allows the optimization. 


% % Pattern matching is a well-established paradigm within functional programming languages, and
% % """has been the subject of significant discourse.""" \it{Appeal to authority here.}

% % Without pattern matching, it can be tiresome to deconstruct data using manual 
% % accessor functions. Consider the following Standard ML code: 
% % \smllst

% % \begin{lstlisting}
% % val rec length = fn ys => 
% %     if null ys 
% %     then 0 
% %     else let xs = tl ys 
% %          in length xs 
% %          end 
% % \end{lstlisting}
% % \it{An implementation of List.length in Standard ML that does not use pattern 
% %     matching.}

% % Manual checking and deconstruction, with built-in functions like \tt{null} and
% % \tt{tl}, can be both error-prone (\bf{say more on this?}) and verbose. Most
% % functional programmers likely prefer the follwing implementation of \tt{length}:

% % \begin{lstlisting}
% %     val rec length = fn ys => 
% %         case ys 
% %           of [] => 0
% %            | _::xs => 1 + length xs
% %     \end{lstlisting}

% % \it{An equivalent implementation that uses pattern matching.}

% % Indeed, pattern matching is quite appealing when deconstructing data, especially 
% % data that may be represented with an algebraic data type, is the primary programming problem: 



% % \begin{lstlisting}
% % val length = \ys. case ys 
% %                  of [] -> 0
% %                   | _::xs -> 1 + length xs
% % \end{lstlisting}


% % Figure 1 illustrates an example in which pattern matching is an elegant solution
% % to a problem (compare to equivalent Standard ML code that manually deconstructs
% % a list:)


% % Most functional programmers likely prefer the first example 

% % However, language designers continue to extend pattern matching 

% % \section{Pattern Matching as it is Now}
% % \it{Pattern matching} is defined as "checking and locating of specific sequences
% % of data of some pattern among raw data or a sequence of tokens." We will return
% % to the notion of "checking" often in this paper: pattern matching answers the
% % question "when I'm checking to see if a piece of data (called a \it{scrutinee})
% % is of the same form as a certain pattern, does that match succeed or fail?"

% % \it{Example}.

% % In addition to this checking and locating, pattern matching serves as
% % \it{assignment}: it can bind fresh variables based on the form of data and use
% % those bindings in subsequent expressions. 

% % \it{Example}.

% % Here, "checking" means "do the data match what I expect them to." Because
% % pattern matching is inherently built to match a scrutinee (pure data) with a
% % pattern, pattern matching is quite expressive in these cases. 

% % Because of this, most modern functional programming languages, especially \it{data
% % dependency languages} like Haskell or ML, \it{(is this right?)} employ pattern
% % matching as their main way to deconstruct data (citation?). 

% % We here explore pattern matching through the lens of {\PPlus}, an invented
% % language that has pattern matching along with several of its popular extensions.
% % (The examples above are written in {\PPlus}.) 
% % \subsection{Strengths}

% % - "Checking" and assignment- nice! No car, cdr 

% % - Nested patterns - powerful 

% % - Literal patterns let you mix names and values 

% % \subsection{Weaknesses and Proposed Mitigations}

% % We return to the concept of unifying "checking" with assignment, i.e. "match if
% % the data take this form, and give them names." Pattern matching succeeds here
% % when checking means "is the form of data the way I expect"; in fact, as we know,
% % assignment in general \it{is} pattern matching (figure/example?). But when
% % checking means "does this computation succeed" or "does this binding conflict
% % with a prior binding," pattern matching is at a loss, where Verse succeeds. 

% % Example: 


% % Pattern matching's extensions get closer to unifying "checking" and binding.
% % Here, Verse enjoys a different suite of advantages. 

% % First, its "or" operation (`one` with `choice`) allows for more than patterns to
% % appear as a top-level "choose this or that" construct in a match sequence; you
% % can also include arbitrary expressions. You can't do this in pattern matching's
% % version, which is an or-pattern. Simply put, saying "does this pattern match or
% % is this expression true" is easy in Verse and clunky if you use patterns. I'll
% % show examples at our meeting. 

% % Second, Verse can express operations out of order, letting important checks
% % appear higher up even if they are executed later. This helps program legibility.
% % Again, I have examples from the chapter I wrote today. 

% % Third, in a pattern-match clause, the initial data must still match an initial
% % pattern in order to enter a guard; in Verse there is no restriction. This is
% % minor, because you could simply match the data to a variable, and then enter a
% % guard-- but again, all of these advantages are in elegance and brevity, and
% % elegant that solution is not. 

% % Finally, mingling pattern guards with other extensions to pattern matching
% % (especially or-patterns) is a murky subject. Haskell has pattern guards and side
% % conditions, but no or-patterns. OCaml has side conditions and or-patterns, but
% % no guards. Mixing all three is (according to some readings) simply difficult for
% % implementers- including, interestingly, those of parsers. In Verse, having `one`
% % and `choice` closely tied in with the simple `e1 = e2` equation form, which by
% % itself subsumes pattern matching, side-conditions, and pattern guards, means
% % that integrating options is easy. A key theme that arises of this: Verse has
% % fewer constructs, and they are more expressive.  

% % \section{A Proposal, Inspired by the Verse Calculus}

% % \subsection{Verse Flexibility}
% % \subsection{Something else}
% % \subsection{A third thing}

% % \section{Verse's Equations Subsume Pattern Matching}

% % \subsection{Claim}
% % \subsection{Proof}
% % \subsection{Translations}

% % \section{(Maybe) Writing Efficient Verse Code}

% % \subsection{Claim}
% % \subsection{Proof}
% % \subsection{Translations}


% % \section{Citations and Bibliographies}

\end{document}
\endinput
%%
