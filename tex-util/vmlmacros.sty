\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{vmlmacros}[2011/02/23 v1.0 Custom VML macros.]
% Thank you Norman Ramsey and Cheng Shao for the foundation needed for these!
\RequirePackage{amsmath}
\RequirePackage{geometry}
\RequirePackage{amsthm}
\RequirePackage{amssymb}
\RequirePackage{verbatim}
\RequirePackage{hyperref}
\RequirePackage{graphicx}
\RequirePackage{amsmath}
\RequirePackage{mathpartir}
\RequirePackage[anticlockwise]{rotating}
\RequirePackage{upgreek}
\RequirePackage{listings}
\RequirePackage{color}
\RequirePackage{simplebnf}
\RequirePackage{cleveref}
\RequirePackage{caption}
\RequirePackage{subcaption}
\RequirePackage{hyperref}

% TODO remove if unused 
% \RequirePackage{tikz}
% \RequirePackage{ebproof}
% \RequirePackage{alltt}
% \RequirePackage{qtree}
% \RequirePackage{semantic}



%%%%%%%%%% LANGUAGES %%%%%%%%%%
\newcommand\VMinus{\ensuremath{V^{-}}}
\newcommand\PPlus{\ensuremath{P^{+}}}
\newcommand\D{\ensuremath{D}}
\newcommand\dt{\ensuremath{t}}
\newcommand\U{\ensuremath{U}}
\newcommand\VC{\ensuremath{\mathcal{VC}}}

%%%%%%%%%% GENERAL MATH %%%%%%%%%%
\DeclareMathOperator{\dom}{dom}
\newcommand\gt{\mathrel{>}}
\newcommand\lt{\mathrel{<}}

\newcommand{\bracketed}[1]{\{#1\}}
\newcommand{\ttbraced}[1]{\tt{(}#1\tt{)}}
\newcommand{\ttsqbraced}[1]{\tt{[}#1\tt{]}}
\newcommand{\sqbraced}[1]{[#1]}


%%%%%%%%%% FORMATTING %%%%%%%%%%
\newcommand\vfilbreak[1][1in]{\vskip 0pt plus #1\penalty-200 \vskip 0pt plus -#1}

%%%%%%%%%% PPlus ABBREV. %%%%%%%%%%
\newcommand\Tlp{\it{Top-level Pattern}}

%%%%%%%%%% GENERAL ABSTRACT SYNTAX %%%%%%%%%%
\newcommand\valabstract{\ensuremath{\mathit{val}\; x\; \mathit{=}\; \expr}}

%%%%%%%%%% PPlus ABSTRACT SYNTAX %%%%%%%%%%
\newcommand\tlp{\ensuremath{p^{t}}}
\newcommand\pbar{\ensuremath{\text{\large\texttt{\char`\|}}\mskip1mu}}
\newcommand\porp{\ensuremath{p_{1} \pbar p_{2}}}
\newcommand\whenexpr{\ensuremath{\mathit{when} \; \expr}}
\newcommand\pcommap{\ensuremath{p_{1}, p_{2}}}
\newcommand\parrowe{\ensuremath{p \leftarrow \expr}}
\newcommand\caseabstract{\ensuremath{\mathit{case}\; \expr\; \bracketed{p\; \rightarrow\; \expr}}}

%%%%%%%%%% VMinus ABSTRACT SYNTAX %%%%%%%%%%

% Symbols 
\newcommand{\choice}{\,{\vrule width 1.5pt height 8pt}\,}
\newcommand{\vlambda}[1]{\lambda\ \langle #1 \rangle.}
\newcommand{\vexists}[1]{\ensuremath{\exists\, #1.}}

\newcommand\iffiabstract{\ensuremath{\mathit{if}\; \mathit{[}\; G\; \bracketed{[] G}\; \mathit{]}\; \mathit{fi}}}
\newcommand\gexpabstract{\ensuremath{[\vexists{\bracketed{x}}] \bracketed{g} \boldsymbol{\rightarrow}\expr}}
\newcommand\choiceabstract{\ensuremath{\choiceg{g \bracketed{; g}}{g \bracketed{; g}}}}

%%%%%%%%%% D ABSTRACT SYNTAX %%%%%%%%%%

\newcommand\decisiontreeabstract{\ensuremath{\mathit{test}\; x\; \bracketed{K\bracketed{x}\; \rightarrow\; \dt} [x\; \rightarrow \dt]}}
\newcommand\treeifabstract{\ensuremath{\mathit{if}\; x\; \mathit{then}\; \dt\; \mathit{else}\; \dt}}
\newcommand\treeletabstract{\ensuremath{\mathit{let}\; x\; \mathit{=}\; \expr\; \mathit{in}\; \dt}}

\newcommand\utable {%
  \begin{table}[ht]
    \centering
    \small
    \begin{tabular}{l l l}
        \textbf{Syntactic Forms} & \textbf{Cases} & \textbf{Unique to} \\
        \hline
        $P$ : Programs        & $\bracketed{d}$        & \\
        $d$ : Definitions     & \valabstract           & \\
        $\expr$ : Expressions & $\v$                   & \\
                              & $x, y, z$             & \\
                              & $K\bracketed{\expr}$  & \\
                              & $\lambda x.\; \expr$  & \\
                              & $\expr[1]\; \expr[2]$ & \\
                              & \caseabstract         & \PPlus \\
                              & \iffiabstract         & \VMinus \\
                              & $\dt$                 & \D \\
        $\v$ : Values          & $K\bracketed{\v}$     & \\
                              & $\lambda x.\; \expr$  & \\
        $p$ : Patterns         & $x$                   & \PPlus \\
                              & $\_$                  & \PPlus \\
                              & $K\; \bracketed{p}$   & \PPlus \\
                              & $\whenexpr$           & \PPlus \\
                              & $\pcommap$            & \PPlus \\
                              & $\parrowe$            & \PPlus \\
                              & $\porp$               & \PPlus \\
        $G$ : Guarded Expressions & \gexpabstract      & \VMinus \\
        $g$ : \textsf{Guards}  & $x = \expr$           & \VMinus \\
                              & $\expr$               & \VMinus \\
                              & \choiceabstract       & \VMinus \\
        \dt : Decision Trees   & \decisiontreeabstract & \D \\
                              & $\expr$               & \D \\
                              & \treeifabstract       & \D \\
                              & \treeletabstract      & \D \\
    \end{tabular}
    \caption{Abstract Syntax of all languages, 
             with deliniations in column \bf{Unique To}}
    \label{fig:unilang}
\end{table}}

%%%%%%%%%% VERSE CONCRETE SYNTAX %%%%%%%%%%

%%%%%%%%%% VMinus JUDGEMENT RULES %%%%%%%%%%


% Context 
\newcommand\rhohat{\ensuremath{\hat{\rho}}}
\newcommand\tempstuck[1][\bracketed{eq}]{\tt{?t.}\it{#1}}
\newcommand\context{\ensuremath{\mathcal{T}}}


% Symbols 
\newcommand\expr[1][]{\ensuremath{e_{#1}}}
\newcommand\guard[1][]{\ensuremath{g_{#1}}}
\newcommand\g[1][]{\ensuremath{g_{#1}}}

\renewcommand\v[1][]{\ensuremath{v_{#1}}}

\newcommand\fail{\bf{fail}}
\newcommand\reject{\bf{reject}}
\newcommand\valbar{\ensuremath{v^{\alpha}}}
\newcommand\result{\it{r}}
\newcommand\solution{\it{s}}
\newcommand\arrowe{\rightarrow e}

\newcommand\ttleftarrow{\tt{\char`\<-}}
\newcommand\ttrightarrow{\tt{-\char`\>}}
\newcommand\ttbackslash{\tt{\char`\\}}

\newcommand\galpha{\ensuremath{g_{\alpha}}}
\newcommand\ealpha[1][]{\ensuremath{e_{\alpha_{#1}}}}
\newcommand\ealphaone{\ensuremath{e_{\alpha_{1}}}}
\newcommand\ealphatwo{\ensuremath{e_{\alpha_{2}}}}
\newcommand\ealphan{\ensuremath{e_{\alpha_{n}}}}
\newcommand\ealphai{\ensuremath{e_{\alpha_{i}}}}
\newcommand\Dalpha{\ensuremath{\mathcal{D}_\alpha}}
\newcommand\valpha{\ensuremath{\vartheta}}


\makeatletter
\newcommand{\Rho}[1][\@nil]{%
\ensuremath{\rho
  \def\tmp{#1}%
   \ifx\tmp\@nnil
    \else
    \bracketed{#1}
    \fi}}
\makeatother

% \newcommand\Rho[1][]{\ensuremath{\rho}\bracketed{#1}}
\newcommand\Rhoprime{\ensuremath{\rho'}}

\newcommand\choiceg[2]{#1 \; \choice \; #2}

\newcommand\uppsidown{
    \raisebox{1.25ex}{
      \hspace{-0.75em}
      \begin{sideways}
        \ensuremath{\uppsi}
      \end{sideways}}
      }

% Wrapping forms 
\newcommand\iffi[1]{\textsc{if} \; [\; #1 \; ] \; \textsc{fi}}
\newcommand\iffitt[1]{\tt{if} \; #1 \; \tt{fi}}
\newcommand\TeqT[1]{\context \cdot #1 \cdot \context'}
\newcommand\eqTT[1]{#1 \cdot \context \cdot \context'}
\newcommand\TT{\context \cdot \context'}

% Shortcuts 

% Latex abbreviations 

%  Judgements 
\newcommand{\vtuple}[1]{%
  \let\c=\component%
  \ensuremath{\langle #1 \rangle}%
  }
  

\newcommand{\vjudgement}[2]{#1 \rightarrowtail{} #2}
  
\newcommand{\veval}[2]{REDO}
\newcommand{\vevalext}[3]{REDO}

% Quick display a v- judgement form
\newcommand{\showvjudgement}[3][Right]{%
  \[\inferrule*[#1=\textsc{ (#2) }]%
  {}      
  {#3}\]%
}
      
% Somewhat depricated 
\newcommand{\mkjudgementcmd}[3]{%
  \expandafter\newcommand\csname #1\endcsname{\vjudgement{#2}{#3}}%
  }

\newcommand{\mkevaljudgementcmd}[3]{%
  \expandafter\newcommand\csname #1\endcsname{\veval{#2}{#3}}%
  }

%%%%%%%%%% TRANSLATION %%%%%%%%%%
      
      % Translation rules with oxford brackets
\newcommand{\oxs}[1]{[\![#1]\!]}
\newcommand{\translate}[1]{ \mathcal{T} \oxs{#1}}
\newcommand{\desugar}[1]{ \mathcal{D} \oxs{#1}}

%%%%%%%%%% VANITY %%%%%%%%%%
\newcommand\nr[1]{\leavevmode\emph{NR: #1}}
\newcommand\rab[1]{\leavevmode\emph{rab: #1}}

%%%%%%%%%% OTHER %%%%%%%%%%

% Abbreviations 
\renewcommand{\tt}[1]{\texttt{#1}}
\renewcommand{\it}[1]{\textit{#1}}
\renewcommand{\bf}[1]{\textbf{#1}}
\renewcommand{\rm}[1]{\textrm{#1}}

% Fonts
\newcommand{\ppl}[1]{{\fontfamily{ppl}\selectfont #1}}

% Lists 
\newcommand\eq{\ensuremath{\mathit{eq}}}  % equation
\newcommand\xs{\ensuremath{\mathit{xs}}}
\newcommand\ys{\ensuremath{\mathit{ys}}}
\newcommand\zs{\ensuremath{\mathit{zs}}}
\newcommand\emptyseq{\ensuremath{\varepsilon}}


%%%%%%%%%% INFERENCE RULES %%%%%%%%%%


% Nice judgement and rule forms
\newcommand{\mono}[1]{%  Thanks Paul A. (Windfall Software)
\makeatletter
  {\@tempdima = \fontdimen2\font
   \frenchspacing
   \texttt{\spaceskip = 1.1\@tempdima{}#1}}}
\newcommand\xmono[2][1.1]
  {\@tempdima = \fontdimen2\font
   \frenchspacing
   \texttt{\spaceskip = #1\@tempdima{}#2}}
\makeatother
\newcommand*\monobox[2][1.1]{\mbox{\upshape\xmono[#1]{#2}}}

\newcommand\emptylist{\ensuremath{[\,]}}
\usepackage{keyval}


\makeatletter
\newcommand\defcomponent[2]{%
  \define@key{state}{#1}{\@nameuse{setmyval@#1}{##1}}%
  \@namedef{setmyval@#1}##1{\@namedef{myval@#1}{##1}}%
  \@nameuse{setmyval@#1}{\ensuremath{#2}}%
}

\newcommand\component[1]{\@nameuse{myval@#1}}

\makeatother

\defcomponent{env}{\rho}
\defcomponent{context}{\context}
\defcomponent{term}{\galpha}
\defcomponent{guard}{g}
\defcomponent{guards}{gs}
\defcomponent{exp}{e}
\defcomponent{pat}{p}
\defcomponent{value}{v}
\defcomponent{result}{\result}
\defcomponent{solution}{\solution}
\defcomponent{envext}{}
\defcomponent{tlp}{\tlp}
\defcomponent{newenv}{\rho'}
\defcomponent{newctx}{\context'}
\defcomponent{gsolveresult}{\langle\c{newctx},\c{newenv}\rangle}
\defcomponent{eq}{\eq}
\defcomponent{name}{x}
\defcomponent{tree}{\dt}


\newcommand\emptycontext{\varepsilon}
\newcommand\emptyenv{\mathord{\{\,\}}}

\newcommand\vmrun[1][]{%  run V-minus code
  {\setkeys{state}{#1}%
   \let\c=\component
   \ensuremath{\c{env}\c{envext}; \c{context} \vdash \c{term} \Downarrow \c{result}}}}
   
\newcommand\vmrung[1][]{%  run V-minus code with normal g
   {\setkeys{state}{#1}%
   \let\c=\component
   \ensuremath{\c{env}\c{envext}; \c{context} \vdash \c{guard} \Downarrow \c{solution}}}}

\newcommand\vmgs[1][]{% do a list of guards
  {\setkeys{state}{#1}%
  \let\c=\component
  \ensuremath{\c{env}\c{envext}; \c{context} \vdash \c{guards} \rightarrowtail \c{solution}}}}


\newcommand\vmeval[1][]{%  eval a vminus expression
  {\setkeys{state}{#1}%
  \let\c=\component
  \ensuremath{\langle \c{env}\c{envext}, \c{exp} \rangle \Downarrow \c{result}}}}

\newcommand\ppeval[1][]{%  eval a pplus expression
  {\setkeys{state}{#1}%
  \let\c=\component
  \ensuremath{\langle \c{env}\c{envext}, \c{exp} \rangle \Downarrow \c{result}}}}

\newcommand\deval[1][]{%  eval a d expression
  {\setkeys{state}{#1}%
  \let\c=\component
  \ensuremath{\langle \c{env}\c{envext}, \c{exp} \rangle \Downarrow \c{result}}}}

\newcommand\treeval[1][]{%  eval a decision tree
  {\setkeys{state}{#1}%
  \let\c=\component
  \ensuremath{\c{env}\c{envext} \vdash \c{tree} \Downarrow \c{result}}}}


\newcommand\eqrefine[1][]{%  equation refines environment
  {\setkeys{state}{#1}%
  \let\c=\component
  \ensuremath{\c{env}\c{envext} \vdash \c{eq} \rightarrowtail \c{newenv}}}}


\newcommand\eqfail{\eqrefine[newenv=\dagger]}

\newcommand\grefine[1][]{%  do many guards
  {\setkeys{state}{#1}%
  \let\c=\component
  \ensuremath{\c{env}\c{envext} \vdash \c{guard} \rightarrowtail \c{solution}}}}

\newcommand\gfail{\grefine[solution=\dagger]}


\newcommand\prun[1][]{%  run P-plus code
  {\setkeys{state}{#1}%
    \let\c=\component
    \ensuremath{\br{\c{env}\c{envext}, \c{exp}} \Downarrow \c{value}}}}

\newcommand\ptov[1][]{%  translate P-plus to V-minus
    {\setkeys{state}{#1}%
      \let\c=\component
      \ensuremath{\ptovtran{\c{exp}} \rightsquigarrow \c{result}}}}
  
  \newcommand\pattov[1][]{%   translate patterns to V-minus
    {\setkeys{state}{#1}%
      \let\c=\component
      \ensuremath{\ptran{\c{pat}}\c{name} \rightsquigarrow \c{result}}}}

  \newcommand\pmatch[1][]{%  pattern-matching judgement
  {\setkeys{state}{#1}%
    \let\c=\component
    \ensuremath{\br{\c{env}\c{envext}, \c{pat}, \c{value}} \rightarrowtail \c{newenv}}}}

  \newcommand\pfail{\pmatch[newenv=\dagger]}

  \newcommand\tlpmatch[1][]{%  top-level-pattern-matching judgement
  {\setkeys{state}{#1}%
    \let\c=\component
    \ensuremath{\br{\c{env}\c{envext}, \c{tlp}, v} \rightarrowtail \c{newenv}}}}

  \newcommand\tlpfail{\tlpmatch[newenv=\dagger]}


\defcomponent{vterm}{e}
\defcomponent{vresult}{e'}

\newcommand\vrun[1][]{% run Verse code
  {\setkeys{state}{#1}%
   \let\c=\component
   \ensuremath{\c{vterm} \mathrel{\rightarrow^{*}} \c{vresult}}}}

\newcommand\script[1]{\ensuremath{\mathcal{#1}}}

% \makeatletter
% \newcommand{\translation}[2][]{%
% \newcommand{\dx}[1][]{%
%    \ifthenelse{ \equal{#1}{} }
%       {\ensuremath{\;\mathrm{d}x}}
%       {\ensuremath{\;\mathrm{d}#1}}
% }
%   \ensuremath{\script{#1}%
%     \def\tmp{#2}%
%     \ifx\tmp\@empty
%     \else
%         [\!#2\!]    
%     \fi}}
% \makeatother

% lazy 
\newcommand\PtoVTran{\script{E}}
\newcommand\PTran{\script{P}}
\newcommand\DTran{\script{D}}

\newcommand\translation[2]{\ensuremath{#1\oxs{#2}}}
\newcommand\ptovtran[1]{\translation{\PtoVTran}{#1}}
\newcommand\ptran[1]{\translation{\PTran}{#1}}
\newcommand\dtran[1]{\translation{\DTran}{#1}}


\newcommand{\goesto}[1]{\xrightarrow{#1}} % {\stackrel{#1}{\longrightarrow}}

    % rough opsem-based stuff: to change
\newcommand{\br}[1]{\langle #1 \rangle}

% Listings color 
\definecolor{eclipseBlue}{RGB}{42,0.0,255}
\definecolor{eclipseGreen}{RGB}{63,127,95}

\newcommand\smllst
{\lstset {
  basicstyle=\small\ttfamily,
  captionpos=b,
  xleftmargin=100pt,
  tabsize=2,
  columns=fixed,
  breaklines=true,
  frame=l,
  numbers=left,
  numberstyle=\small\ttfamily,
  morekeywords= {
    EQUAL, GREATER, LESS, NONE, SOME, abstraction, abstype, and, andalso, array, as, before, bool, case, char, datatype, do, else, end, eqtype, exception, exn, false, fn, fun, functor, handle, if, in, include, infix, infixr, int, let, list, local, nil, nonfix, not, o, of, op, open, option, orelse, overload, print, raise, real, rec, ref, sharing, sig, signature, string, struct, structure, substring, then, true, type, unit, val, vector, where, while, with, withtype, word
  },
  morestring=[b]",
  morecomment=[s]{(*}{*)},
  stringstyle=\color{black},
  identifierstyle=\color{teal},
  keywordstyle=\color{orange},
  commentstyle=\color{eclipseGreen}
}}

\newcommand\pplst
{\lstset {
  basicstyle=\small\ttfamily,
  captionpos=b,
  % xleftmargin=10pt,
  tabsize=2,
  columns=fixed,
  breaklines=true,
  % frame=l,
  numbers=left,
  numberstyle=\small\ttfamily,
  morekeywords= {
    val, case, of, |, when, ->, <-
  },
  morestring=[b]",
  morecomment=[l]{;},
  stringstyle=\color{black},
  identifierstyle=\color{teal},
  keywordstyle=\color{orange},
  commentstyle=\color{eclipseGreen}
}}

\newcommand\vmlst
{\lstset {
  basicstyle=\small\ttfamily,
  captionpos=b,
  % xleftmargin=10pt,
  tabsize=2,
  columns=fixed,
  breaklines=true,
  % frame=l,
  numbers=left,
  numberstyle=\small\ttfamily,
  morekeywords= {
    val, if, fi, |, when, ->, <-
  },
  morestring=[b]",
  morecomment=[l]{\#},
  stringstyle=\color{black},
  identifierstyle=\color{teal},
  keywordstyle=\color{orange},
  commentstyle=\color{eclipseGreen}
}}

\newcommand\schemelst
{\lstset {
  basicstyle=\small\ttfamily,
  captionpos=b,
  tabsize=2,
  columns=fixed,
  breaklines=true,
  frame=l,
  numbers=left,
  numberstyle=\small\ttfamily,
  morekeywords= {
    car, cdr, cons, '()
  },
  morestring=[b]",
  morecomment=[s]{(*}{*)},
  stringstyle=\color{black},
  identifierstyle=\color{teal},
  keywordstyle=\color{orange},
  commentstyle=\color{eclipseGreen}
}}

\newcommand\verselst
{\lstset {
  basicstyle=\small\ttfamily,
  captionpos=b,
  tabsize=2,
  xleftmargin=100pt,
  columns=fixed,
  breaklines=true,
  % frame=l,
  numbers=left,
  numberstyle=\small\ttfamily,
  morekeywords= {
    EQUAL, GREATER, LESS, NONE, SOME, raise, $\exists$, if, then, else, =
  },
  morestring=[b]",
  morecomment=[s]{(*}{*)},
  stringstyle=\color{black},
  % identifierstyle=\color{teal},
  % keywordstyle=\color{orange},
  % commentstyle=\color{eclipseGreen},
  mathescape
}}

%  Bulk command definition
% \def\do#1{\expandafter\newcommand\csname#1\endcsname{\elem{#1}}}
% \docsvlist {fire,earth,air,ice,dark,light,wild}
% \let\frost\ice

% \newcommand\bulkdef[2]{% command arglist
%   \def\do##1{\expandafter\newcommand\csname##1\endcsname{#1{##1}}}%
%   \docsvlist{#2}}

% \bulkdef\gen{attack,jump,range,move,shield,loot,retaliate,teleport,xp,heal,target,damage}  
% \bulkdef\cond{push,pull,muddle,bane,poison,wound,invisible,immobilize,disarm,curse,stun,strengthen,pierce,brittle,bless,impair}
% \newcommand\eat{\consume}

% \bulkdef\icon{shuffle}

% \let\shuffleicon=\shuffle
% \def\shuffle{\hfill\shuffleicon\mbox{\hskip 0.5em}\parfillskip=0pt}


%%%%%%%%%%%%%%%%% SEMANTICS %%%%%%%%%%%%%%%%%
\newcommand\vmsemantics{% 

\subsection{Rules (Big-step Operational Semantics) for ${\VMinus}$:}
    
% \[
% \inferrule*[Left=\textsc{ (Eval-ArrowExpr) }]
%     {\vmrung[context=\emptyseq, guard=\expr]}
%     {\vmrung[context=\emptyseq, guard=\rightarrow \expr, result=\v]}
% \]

% \[
% \inferrule*[Left=\textsc{ (Eval-Exists) }]
%     {\vmrung[env=\rho\{x \mapsto \bot \}]}
%     {\vmrung[guard=\vexists{x}\; g]}
% \]


\subsubsection{Shifting a guard to the context}
\[
\inferrule*[Left=\textsc{ (Move-Guard-To-Ctx) }]
    {\inferrule*{\vmgs[context=g \cdot \context]}
    {}
    }
    {\vmgs[guards={gs \cdot g \cdot gs'}]}
\]

\subsubsection{Choosing and processing a guard}

\[
\inferrule*[Left=\textsc{ (Solve-Guard-Refine) }]
    {\grefine[solution=\Rhoprime]
    \and
    \vmgs[env=\Rhoprime,context=\;\TT]}
    {\vmgs[context=\TeqT{g}]}
\]

\[
\inferrule*[Left=\textsc{ (Solve-Guard-Reject) }]
    {\gfail}
    {\vmgs[context=\TeqT{g},solution=\dagger]}
\]
\subsubsection{Properties of guards}

% \[
% \inferrule*[Left=\textsc{ (Single-Eq-Assoc) }]
%     {\vmrung[context=\TeqT{\expr[2] = \expr[1]}]}
%     {\vmrung[context=\TeqT{\expr[1] = \expr[2]}]}
% \]

\[
\inferrule*[Left=\textsc{ (Multi-Guard-Assoc) }]
    {\vmgs[context=\TeqT{g_{1} \cdot g_{2}}]}
    {\vmgs[context=\TeqT{g_{2} \cdot g_{1}}]}
\]


% \[
% \inferrule*[Left=\textsc{ (Multi-Eq-Assoc) }]
%     {\vmrung[context=\TeqT{\expr[2] = \expr[1] \cdot \expr[1] = \expr[2]}]}
%     {\vmrung[context=\TeqT{\expr[1] = \expr[2] \cdot \expr[2] = \expr[1]}]}
% \]

% \subsubsection{Desugaring of Complex Equations}
% \[
% \inferrule*[Left=\textsc{ (Desugar-EqExps) }]
%     {\inferrule* {}
%     {
%     x,\; \; \rm{are distinct and fresh}
%     \\\\
%     \vmrung[envext=\bracketed{x \mapsto \bot,\; y \mapsto \bot},
%           context=\eqTT{x = \expr[1] \cdot y = \expr[2] \cdot x = y}]}}
%     {\vmrung[context=\TeqT{\expr[1] = \expr[2]}]}
% \]

% \[
% \inferrule*[Left=\textsc{ (Desugar-Vcon-Multi) }]
%     {
%     \vmrung[context=\TeqT{\lbrack \expr[i]=\expr[i]'\; 
%            \vert\; 1 \leq i \leq n \rbrack}]}
%     {\vmrung[context=\TeqT{K(\expr[1], \dots 
%             \expr[n]) = K(\expr[1]', \dots \expr[n]')}]}
% \]

\subsubsection{Refinement with different types of guards}


\[
\inferrule*[Left=\textsc{ (Guard-NameExp-Bot) }]
    {\inferrule* {}
    {
    x \in \dom \rho
    \\\\
    \vmeval[result=\v]
    \\\\
    \rho(x) = \bot
    }}
    {\eqrefine[eq={x = \expr},newenv={\Rho[x \mapsto \v]}]}
\]

\[
\inferrule*[Left=\textsc{ (Guard-NameExp-Eq) }]
    {\inferrule* {}
    {
    x \in \dom \rho
    \\\\
    \vmeval[result=\v]
    \\\\
    \rho(x) = \v
    }}
    {\eqrefine[eq={x = \expr},newenv={\Rho}]}
\]

\[
\inferrule*[Left=\textsc{ (Guard-NameExp-Fail) }]
    {\inferrule* {}
    {
    x \in \dom \rho
    \\\\
    \vmeval[result=\v]
    \\\\ 
    \rho(x) = \v'
    \\\\
    \v \neq \v'
    }}
    {\eqrefine[eq={x = \expr},newenv=\dagger]}
\]

% \[
% \inferrule*[Left=\textsc{ (Guard-NameNotFound-Fail) }]
%     {\inferrule* {}
%     {
%     x \not\in \dom \rho
%     }}
%     {\eqrefine[eq={x = \expr},newenv=\dagger]}
% \]

% \[
% \inferrule*[Left=\textsc{ (Guard-EqNames-Vals-Succ) }]
%     {\inferrule* {}
%     {
%     x,\;  \in \dom \rho
%     \\\\
%     \rho(x) = \v,\; \rho(y) = \v
%     }}
%     {\eqrefine[eq={x = y},newenv=\rho]}
% \]

% \[
% \inferrule*[Left=\textsc{ (Guard-EqNames-Vals-Fail) }]
%     {\inferrule* {}
%     {
%     x,\;  \in \dom \rho
%     \\\\
%     \rho(x) = \v,\; \rho(y) = \v'
%     \\\\
%     \v \neq \v'}}
%     {\eqrefine[eq={x = y},newenv=\dagger]}
% \]

% \[
% \inferrule*[Left=\textsc{ (Guard-EqNames-Bots-Fail) }]
%     {\inferrule* {}
%     {
%     x,\;  \in \dom \rho
%     \\\\
%     \rho(x) = \bot,\; \rho(y) = \bot
%     \\\\
%     x,\; \; \rm{do not appear in}\; \context,\; \context'}}
%     {\vmrung[context=\TeqT{x = y}] 
%     \rightsquigarrow \uppsidown}
% \]

\[
\inferrule*[Left=\textsc{ (Guard-Names-Bot-Succ) }]
    {\inferrule* {}
    {
    x, \;y  \in \dom \rho
    \\\\
    \rho(x) = \bot,\; \rho(y) = \v
    }}
    {\eqrefine[eq={x = y},newenv={\Rho[x \mapsto \v]}]}
\]

\[
\inferrule*[Left=\textsc{ (Guard-Names-Bot-Succ-Rev) }]
    {\inferrule* {}
    {
    x, \;y  \in \dom \rho
    \\\\
    \rho(x) = \v,\; \rho(y) = \bot
    }}
    {\eqrefine[eq={x = y},newenv={\Rho[y \mapsto \v]}]}
\]

\rab{The vcon success rule is being edited with a change in the semantics.}

% \[
%   \inferrule*[Left=\textsc{ (Guard-Vcon-Succ) }]
%       {\inferrule* {}
%       {
%       \pmatch[pat=p_{i}, value=v_{i}, newenv=\solution_{i}], \and 1 \leq i \leq m
%       \\\\
%       \solution = \solution_{1} \uplus \dots \uplus \solution_{m}
%       }}
%       {\pmatch[pat={K [p_{1} \dots 
%               p_{m}]}, value={K [v_{1}' \dots v_{m}']},
%               newenv=\solution]}
%   \]
  
  \[
  \inferrule*[Left=\textsc{ (Guard-Vcon-Fail) }]
      {x \in \dom \rho
      \\\\
      \rho{x} = \v
      \\\\        
      \v \rm{ does not have the form }  K [v_{1}', \dots v_{m}']}
      {\eqrefine[eq={x = K\; e_{1}, \dots e_{m}}, 
              newenv=\dagger]}
  \]

% \[
% \inferrule*[Left=\textsc{ (Guard-Vcon-Single-Succ) }]
%     {x \in \dom \rho
%     \\\\
%     \rho{x} = K []
%     \\\\
%     K \neq K'}
%     {\eqrefine[eq={x = K'}, newenv=\dagger]}
% \]

% \[
% \inferrule*[Left=\textsc{ (Guard-Vcon-Single-Fail) }]
%     {x \in \dom \rho
%     \\\\
%     \rho{x} = K'
%     \\\\
%     K \neq K'}
%     {\eqrefine[eq={x = K'}, newenv=\dagger]}
% \]


% \[
% \inferrule*[Left=\textsc{ (Guard-Vcon-Multi-Fail) }]
%     {K \neq K'}
%     {\eqrefine[eq={K(\expr[1], \dots 
%             \expr[n]) = K'(\expr[1]', \dots \expr[n]')},
%             newenv=\dagger]}
% \]

% \[
% \inferrule*[Left=\textsc{ (Guard-Vcon-Multi-Arity-Fail) }]
%     {n \neq m}
%     {\eqrefine[eq={K(\expr[1], \dots 
%             \expr[n]) = K(\expr[1]', \dots \expr[m]')},
%             newenv=\dagger]}
% \]

\[
\inferrule*[Left=\textsc{ (Guard-Expseq-Succ) }]
    {\inferrule* {}
    {
    \vmeval[result=\v]}}
    {\grefine[guard=\expr, solution=\bracketed{}]}
\]

\[
\inferrule*[Left=\textsc{ (Guard-Expseq-Fail) }]
    {\vmeval[result={\fail}]}
    {\grefine[guard=\expr, solution=\dagger]}
\]

\[
\inferrule*[Left=\textsc{ (Guard-Choice-First) }]
    {\vmgs[context=\emptyseq, solution=\rho']}
    {\grefine[guard={\choiceg{gs}{gs'}}, solution=\rho']}
\]

\[
\inferrule*[Left=\textsc{ (Guard-Choice-Second) }]
    {\vmgs[context=\emptyseq, solution=\dagger] 
    \and 
    \vmgs[context=\emptyseq, guards=gs']}
    {\grefine[guard={\choiceg{gs}{gs'}}]}
\]

\subsubsection{Evaluating General Expressions}

\[
\inferrule*[Left=\textsc{ (Eval-IfFi-Fail) }]
    {\ }
    {\vmeval[exp={\iffi{\ }}, result={\fail}]}
\]

\[
\inferrule*[Left=\textsc{ (Eval-IfFi-Success) }]
{\inferrule* {}
    {\rho' = \Rho[x_{1} \mapsto \bot \dots x_{n} \mapsto \bot]}
    \\\\
    {\vmgs[env=\rho', context=\emptyseq, solution=\rho'']}
    \\\\ 
    {\vmeval[env={\rho''}]}}
    {\vmeval[exp={\iffi{\vexists{x_{1} \dots x_{n}}\; gs \rightarrow e\; \square\; \dots}}]}
\]

\[
\inferrule*[Left=\textsc{ (Eval-IfFi-Reject) }]
{\inferrule* {}
    {\rho' = \Rho[x_{1} \mapsto \bot \dots x_{n} \mapsto \bot]}
    \\\\
    {\vmgs[env=\rho', context=\emptyseq, solution=\dagger]}
    \\\\
    \vmeval[exp={\iffi{\dots}}]}
    {\vmeval[exp={\iffi{\vexists{x_{1} \dots x_{n}}\; gs \rightarrow e\; \square\; \dots}}]}
\]


\[
\inferrule*[Left=\textsc{ (Eval-VconEmpty) }]
    {\ }
    {\vmeval[exp={K}, result={K}]}
\]

\[
\inferrule*[Left=\textsc{ (Eval-VconMulti) }]
    {\inferrule* {}
    {
    \vmeval[exp={\expr[i]}, result={v_{i}}]
    \and 
    1 \leq i \leq n
    }}
    {\vmeval[exp={K(\expr[1], \dots \expr[n])}, result={K(v_{1}, 
    \dots v_{i})}]}
\]

\[
\inferrule*[Left=\textsc{ (Eval-VconMulti-Fail) }]
    {\inferrule* {}
    {
    \exists e_{i}.\; 1 \leq i \leq n : \vmeval[exp={\expr[i]}, result={\fail}]
    }}
    {\vmeval[exp={K(\expr[1], \dots \expr[n])}, result={\fail}]}
\]


\[
\inferrule*[Left=\textsc{ (Eval-Name) }]
    {x \in \dom \rho 
    \\\\
    \rho(x) = \v}
    {\vmeval[exp={x}, result={\v}]}
\]

\[
\inferrule*[Left=\textsc{ (Eval-Name-Fail) }]
    {x \notin \dom \rho}
    {\vmeval[exp={x}, result={\fail}]}
\]

\[
\inferrule*[Left=\textsc{ (Eval-LambdaDecl) }]
    {\ }
    {\prun[exp={\lambda x.\expr}, value={\lambda x.\expr}]}
\]

% \[
% \inferrule*[Left=\textsc{ (Eval-Funapp-Fail) }]
%     {\vmeval[exp={\expr[1]}]
%     \\\\
%     r \rm{ does not have the form } {\lambda x.\expr}}
%     {\vmeval[exp={\expr[1]\; \expr[2]}, result=\fail]}
% \]

\[
\inferrule*[Left=\textsc{ (Eval-Funapp) }]
    {\vmeval[exp={\expr[1]}, result={\lambda x.\expr}]
    \\\\
    \vmeval[exp={\expr[2]}, result={\v'}]
    \\\\
    \vmeval[envext=\bracketed{x \mapsto \v'}]}
    {\vmeval[exp={\expr[1]\; \expr[2]}]}
\]

\[
\inferrule*[Left=\textsc{ (Eval-Literal) }]
    {\ }
    {\vmeval[exp={\v}, result={\v}]}
\]

}


\newcommand\ppsemantics {

\subsection{Rules (Big-step Operational Semantics) for {\PPlus}:}

      Some of these rules are a variation on the rules found in Ramsey~\cite{bpc}. 
      
      
      \subsubsection{Evaluating General Expressions}
      
      \[
      \inferrule*[Left=\textsc{ (Eval-VconEmpty) }]
          {\ }
          {\ppeval[exp={K}, result={K}]}
      \]
      
      \[
      \inferrule*[Left=\textsc{ (Eval-VconMulti) }]
          {\inferrule* {}
          {
          \ppeval[exp={\expr[i]}, result={v_{i}}]
          \and 
          1 \leq i \leq n
          }}
          {\ppeval[exp={K(\expr[1], \dots \expr[n])}, result={K(v_{1}, 
          \dots v_{i})}]}
      \]
      
      
      \[
      \inferrule*[Left=\textsc{ (Eval-Name) }]
          {x \in \dom \rho 
          \\\\
          \rho(x) = \v}
          {\ppeval[exp={x}, result={\v}]}
      \]
      
      \[
      \inferrule*[Left=\textsc{ (Eval-LambdaDecl) }]
          {\ }
          {\prun[exp={\lambda x.\expr}, value={\lambda x.\expr}]}
      \]
      
      \[
      \inferrule*[Left=\textsc{ (Eval-Funapp) }]
          {\ppeval[exp={\expr[1]}, result={\lambda x.\expr}]
          \\\\
          \ppeval[exp={\expr[2]}, result={\v'}]
          \\\\
          \ppeval[envext=\bracketed{x \mapsto \v'}]}
          {\ppeval[exp={\expr[1]\; \expr[2]}]}
      \]
      
      \[
      \inferrule*[Left=\textsc{ (Eval-Literal) }]
          {\ }
          {\ppeval[exp={\v}, result={\v}]}
      \]
      
      \[
      \inferrule*[Left=\textsc{ (Eval-CaseScrutinee) }]
          {\inferrule* {}
          {\prun[value=\v]}
          \and 
          \prun[exp=
              {\it{case}\; \v \;
              [p_{1}\; {\expr[1]}], \dots, [p_{n}\; {\expr[n]}]},
              value=\v']}    
          {\prun[exp=
          {\it{case}\; {\expr}\;
          [p_{1}\; {\expr[1]}], \dots, [p_{n}\; {\expr[n]}]},
          value=\v']}
      \]
      
      \[
      \inferrule*[Left=\textsc{ (Eval-CaseMatch) }]
          {\inferrule* {}
          {\pmatch[pat={p_{1}}, newenv=\rho']}
          \and
          {\prun[exp= {\expr[1]}, env=\rho + \rho']}}
          {\prun[exp=
          {\it{case}\; \v \; 
          [p_{1}\; \expr[1]], \dots, [p_{n}\; \expr[n]]},
          value=\v']}
      \]
      
      \[
      \inferrule*[Left=\textsc{ (Eval-CaseFail) }]
          {\inferrule* {}
          {\pmatch[pat={p_{1}}, newenv=\dagger]}
          \and 
          \prun[exp={\it{case}\; \v\;  
          [p_{2}\; \expr[2]], \dots, [p_{n}\; \expr[n]]},
          value=\v']}    
          {\prun[exp=
          {\it{case}\; \v \; 
          [p_{1}\; \expr[1]], \dots, [p_{n}\; \expr[n]]},
          value=\v']}
      \]
      
      
      
      \subsubsection{Rules for pattern matching}
      
      
      \[
      \inferrule*[Left=\textsc{ (Pat-MatchVcon) }]
          {\inferrule* {}
          {
          \pmatch[pat=p_{i}, value=v_{i}, newenv=\solution_{i}], \and 1 \leq i \leq m
          \\\\
          \solution = \solution_{1} \uplus \dots \uplus \solution_{m}
          }}
          {\pmatch[pat={K [p_{1} \dots 
                  p_{m}]}, value={K [v_{1}' \dots v_{m}']},
                  newenv=\solution]}
      \]
      
      \[
      \inferrule*[Left=\textsc{ (Pat-FailVcon) }]
          {\v \rm{ does not have the form }  K [v_{1}', \dots v_{m}']}
          {\pmatch[pat={K\; p_{1}, \dots p_{m}}, 
                  newenv=\dagger]}
      \]
      
      \[
      \inferrule*[Left=\textsc{ (Pat-MatchBareVcon) }]
          {\ }
          {\pmatch[pat={K}, value={K},
                  newenv=\bracketed{}]}
      \]
      
      \[
      \inferrule*[Left=\textsc{ (Pat-FailBareVcon) }]
          {\v \neq {K}}
          {\pmatch[pat={K},
                  newenv=\dagger]}
      \]
      
      \[
      \inferrule*[Left=\textsc{ (Pat-MatchVar) }]
          {\ }
          {\pmatch[pat={x},
                  newenv=\bracketed{x \mapsto \v}]}
      \]
      
      \[
      \inferrule*[Left=\textsc{ (Pat-MatchWhen) }]
          {\prun[value=\v'] \and \v' \neq \mathit{false}}
          {\pmatch[pat={\whenexpr},
                  newenv=\bracketed{}]}
      \]
      
      \[
        \inferrule*[Left=\textsc{ (Pat-MatchWildcard) }]
            {\ }
            {\pmatch[pat={_},
                    newenv=\bracketed{}]}
        \]

      \[
      \inferrule*[Left=\textsc{ (Pat-FailWhen) }]
      {\prun[value=\v'] \and \v' = \mathit{false}}
      {\pmatch[pat={\whenexpr},
                  newenv=\dagger]}
      \]
      
      
      \[
      \inferrule*[Left=\textsc{ (Pat-ArrowExp) }]
      {\prun[value=\v'] \and \pmatch[pat=p, value=\v', newenv=\solution]}
      {\pmatch[pat={\parrowe},
                  newenv=\solution]}
      \]
      
      
      \[
      \inferrule*[Left=\textsc{ (Pat-MultiFail) }]
      {\pmatch[pat=p, newenv=\dagger]}
      {\pmatch[pat={\pcommap},
                  newenv=\dagger]}
      \]
      
      
      \[
      \inferrule*[Left=\textsc{ (Pat-MultiSolution) }]
      {\inferrule* {}
      {\pmatch[pat={p_{1}}, newenv=\Rhoprime]}
      \\\\
      \pmatch[env=\Rho \uplus \Rhoprime, pat=p_{2}, newenv=\solution]}
      {\pmatch[pat={\pcommap}, newenv=\solution]}
      \]
      
      \[
      \inferrule*[Left=\textsc{ (Pat-OrFst) }]
          {\pmatch[pat={p_{1}}]}
          {\pmatch[pat={\porp}]}
      \]
      
      
      \[
      \inferrule*[Left=\textsc{ (Pat-OrSnd) }]
          {\pmatch[pat=p_{1}, newenv=\dagger]
          \and 
          \pmatch[pat={p_{2}}, newenv=\solution]}
          {\pmatch[pat={\porp}, newenv=\solution]}
      \]
      

}

\newcommand\dsemantics{% 

\subsection{Rules (Big-step Operational Semantics) for ${\D}$:}
    
% \subsubsection{Processing guards}

% \[
% \inferrule*[Left=\textsc{ (Eval-ArrowExpr) }]
%     {\vmrung[context=\emptyseq, guard=\expr]}
%     {\vmrung[context=\emptyseq, guard=\rightarrow \expr, result=\v]}
% \]

% \[
% \inferrule*[Left=\textsc{ (Eval-Exists) }]
%     {\vmrung[env=\rho\{x \mapsto \bot \}]}
%     {\vmrung[guard=\vexists{x}\; g]}
% \]


% \subsubsection{Shifting a guard to the context}
% \[
% \inferrule*[Left=\textsc{ (Guard-Move-To-Ctx) }]
%     {\inferrule*{\vmgs[context=g \cdot \context]}
%     {}
%     }
%     {\vmgs[guards={gs \cdot g \cdot gs'}]}
% \]

% \subsubsection{Choosing and processing a guard}

% \[
% \inferrule*[Left=\textsc{ (Solve-Guard-Refine) }]
%     {\grefine[result=\Rhoprime]
%     \and
%     \vmgs[env=\Rhoprime,context=\;\TT]}
%     {\vmgs[context=\TeqT{g}]}
% \]

% \[
% \inferrule*[Left=\textsc{ (Solve-Guard-Reject) }]
%     {\gfail}
%     {\vmgs[context=\TeqT{g},solution=\dagger]}
% \]
% \subsubsection{Properties of guards}

% \[
% \inferrule*[Left=\textsc{ (Single-Eq-Assoc) }]
%     {\vmrung[context=\TeqT{\expr[2] = \expr[1]}]}
%     {\vmrung[context=\TeqT{\expr[1] = \expr[2]}]}
% \]

% \[
% \inferrule*[Left=\textsc{ (Multi-Guard-Assoc) }]
%     {\vmgs[context=\TeqT{g_{1} \cdot g_{2}}]}
%     {\vmgs[context=\TeqT{g_{2} \cdot g_{1}}]}
% \]


% \[
% \inferrule*[Left=\textsc{ (Multi-Eq-Assoc) }]
%     {\vmrung[context=\TeqT{\expr[2] = \expr[1] \cdot \expr[1] = \expr[2]}]}
%     {\vmrung[context=\TeqT{\expr[1] = \expr[2] \cdot \expr[2] = \expr[1]}]}
% \]

% \subsubsection{Desugaring of Complex Equations}
% \[
% \inferrule*[Left=\textsc{ (Desugar-EqExps) }]
%     {\inferrule* {}
%     {
%     x,\; \; \rm{are distinct and fresh}
%     \\\\
%     \vmrung[envext=\bracketed{x \mapsto \bot,\; y \mapsto \bot},
%           context=\eqTT{x = \expr[1] \cdot y = \expr[2] \cdot x = y}]}}
%     {\vmrung[context=\TeqT{\expr[1] = \expr[2]}]}
% \]

% \[
% \inferrule*[Left=\textsc{ (Desugar-Vcon-Multi) }]
%     {
%     \vmrung[context=\TeqT{\lbrack \expr[i]=\expr[i]'\; 
%            \vert\; 1 \leq i \leq n \rbrack}]}
%     {\vmrung[context=\TeqT{K(\expr[1], \dots 
%             \expr[n]) = K(\expr[1]', \dots \expr[n]')}]}
% \]

% \subsubsection{Refinement with different types of guards}

% \[
% \inferrule*[Left=\textsc{ (Guard-NameExp-Bot) }]
%     {\inferrule* {}
%     {
%     x \in \dom \rho
%     \\\\
%     \vmeval[result=\v]
%     \\\\
%     \rho(x) = \bot
%     }}
%     {\eqrefine[eq={x = \expr},newenv={\Rho[x \mapsto \v]}]}
% \]


% \[
% \inferrule*[Left=\textsc{ (Guard-NameExp-Bot) }]
%     {\inferrule* {}
%     {
%     x \in \dom \rho
%     \\\\
%     \vmeval[result=\v]
%     \\\\
%     \rho(x) = \bot
%     }}
%     {\eqrefine[eq={x = \expr},newenv={\Rho[x \mapsto \v]}]}
% \]

% \[
% \inferrule*[Left=\textsc{ (Guard-NameExp-Eq) }]
%     {\inferrule* {}
%     {
%     x \in \dom \rho
%     \\\\
%     \vmeval[result=\v]
%     \\\\
%     \rho(x) = \v
%     }}
%     {\eqrefine[eq={x = \expr},newenv={\Rho[x \mapsto \v]}]}
% \]

% \[
% \inferrule*[Left=\textsc{ (Guard-NameExp-Fail) }]
%     {\inferrule* {}
%     {
%     x \in \dom \rho
%     \\\\
%     \vmeval[result=\v]
%     \\\\ 
%     \rho(x) = \v'
%     \\\\
%     \v \neq \v'
%     }}
%     {\eqrefine[eq={x = \expr},newenv=\dagger]}
% \]

% \[
% \inferrule*[Left=\textsc{ (Guard-NameNotFound-Fail) }]
%     {\inferrule* {}
%     {
%     x \not\in \dom \rho
%     }}
%     {\eqrefine[eq={x = \expr},newenv=\dagger]}
% \]

% \[
% \inferrule*[Left=\textsc{ (Guard-EqNames-Vals-Succ) }]
%     {\inferrule* {}
%     {
%     x,\;  \in \dom \rho
%     \\\\
%     \rho(x) = \v,\; \rho(y) = \v
%     }}
%     {\eqrefine[eq={x = y},newenv=\rho]}
% \]

% \[
% \inferrule*[Left=\textsc{ (Guard-EqNames-Vals-Fail) }]
%     {\inferrule* {}
%     {
%     x,\;  \in \dom \rho
%     \\\\
%     \rho(x) = \v,\; \rho(y) = \v'
%     \\\\
%     \v \neq \v'}}
%     {\eqrefine[eq={x = y},newenv=\dagger]}
% \]

% % \[
% % \inferrule*[Left=\textsc{ (Guard-EqNames-Bots-Fail) }]
% %     {\inferrule* {}
% %     {
% %     x,\;  \in \dom \rho
% %     \\\\
% %     \rho(x) = \bot,\; \rho(y) = \bot
% %     \\\\
% %     x,\; \; \rm{do not appear in}\; \context,\; \context'}}
% %     {\vmrung[context=\TeqT{x = y}] 
% %     \rightsquigarrow \uppsidown}
% % \]

% \[
% \inferrule*[Left=\textsc{ (Guard-EqNames-BotVal-Succ) }]
%     {\inferrule* {}
%     {
%     x,\;  \in \dom \rho
%     \\\\
%     \rho(x) = \bot,\; \rho(y) = \v
%     }}
%     {\eqrefine[eq={x = y},newenv={\Rho[x \mapsto \v]}]}
% \]

% \[
% \inferrule*[Left=\textsc{ (Guard-Vcon-Single-Fail) }]
%     {K \neq K'}
%     {\eqrefine[eq={K = K'}, newenv=\dagger]}
% \]

% \[
% \inferrule*[Left=\textsc{ (Guard-Vcon-Single-Succ) }]
%     {\ }
%     {\eqrefine[eq={K = K}, newenv=\bracketed{}]}
% \]


% \[
% \inferrule*[Left=\textsc{ (Guard-Vcon-Multi-Fail) }]
%     {K \neq K'}
%     {\eqrefine[eq={K(\expr[1], \dots 
%             \expr[n]) = K'(\expr[1]', \dots \expr[n]')},
%             newenv=\dagger]}
% \]

% \[
% \inferrule*[Left=\textsc{ (Guard-Vcon-Multi-Arity-Fail) }]
%     {n \neq m}
%     {\eqrefine[eq={K(\expr[1], \dots 
%             \expr[n]) = K(\expr[1]', \dots \expr[m]')},
%             newenv=\dagger]}
% \]

% \[
% \inferrule*[Left=\textsc{ (Guard-Expseq-Succ) }]
%     {\inferrule* {}
%     {
%     \vmeval[result=\v]}}
%     {\grefine[guard=\expr, solution=\bracketed{}]}
% \]

% \[
% \inferrule*[Left=\textsc{ (Guard-Expseq-Fail) }]
%     {\vmeval[result={\fail}]}
%     {\grefine[guard=\expr, solution=\dagger]}
% \]

% \[
% \inferrule*[Left=\textsc{ (Guard-Choice-First) }]
%     {\vmgs[context=\emptyseq, solution=\rho']}
%     {\grefine[guard={\choiceg{gs}{gs'}}, solution=\rho']}
% \]

% \[
% \inferrule*[Left=\textsc{ (Guard-Choice-Second) }]
%     {\vmgs[context=\emptyseq, solution=\dagger] 
%     \and 
%     \vmgs[context=\emptyseq, guards=gs']}
%     {\grefine[guard={\choiceg{gs}{gs'}}]}
% \]



\subsubsection{Evaluating General Expressions}


\[
\inferrule*[Left=\textsc{ (Eval-Test-Fail) }]
    {\ }
    {\treeval[tree={test({x, []})}, result={\fail}]}
\]

\[
\inferrule*[Left=\textsc{ (Eval-Test-Succeed) }]
    {\rho(x) = K vs
    \and len vs = i
    \\\\ 
    {\treeval[tree={t}, result={\result}]}
    }
    {\treeval[tree={test({x, (K/i, t) \cdot ts})}, result={\result}]}
\]

\[
\inferrule*[Left=\textsc{ (Eval-Test-Recurse) }]
    {\rho(x) = \v
    \v \rm{ does not have the form } K [v_{1} \dots v_{n}] \rm{ s.t. } n = i
    \\\\ 
    {\treeval[tree={test({x, ts}), result={\result}}]}
    }
    {\treeval[tree={test({x, (K/i, t) \cdot ts})}, result={\result}]}
\]

% \[
% \inferrule*[Left=\textsc{ (If-First) }]
%     {\rho(x) = K vs
%     \and len vs = i
%     \\\\ 
%     {\treeval[tree={t}, result={\result}]}
%     }
%     {\treeval[tree={ifx, (K/i, t) \cdot ts}}, result={\result}]}
% \]

% \[
% \inferrule*[Left=\textsc{ (If-Second) }]
%     {\rho(x) = \v
%     \v \rm{ does not have the form } K [v_{1} \dots v_{n}] \rm{ s.t. } n = i
%     \\\\ 
%     {\treeval[tree={test{x, ts}, result={\result}]}
%     }
%     {\treeval[tree={test{x, (K/i, t) \cdot ts}}, result={\result}]}
% \]


% \[
% \inferrule*[Left=\textsc{ (If-Fi-Fail) }]
%     {\ }
%     {\vmeval[exp={\iffi{\ }}, result={\fail}]}
% \]

% \[
% \inferrule*[Left=\textsc{ (If-Fi-Success) }]
% {\inferrule* {}
%     {\rho' = \Rho[x_{1} \mapsto \bot \dots x_{n} \mapsto \bot]}
%     \\\\
%     {\vmgs[env=\rho', context=\emptyseq, solution=\rho'']}
%     \\\\ 
%     {\vmeval[env={\rho''}]}}
%     {\vmeval[exp={\iffi{\vexists{x_{1} \dots x_{n}}\; gs \rightarrow e\; \square\; \dots}}]}
% \]

% \[
% \inferrule*[Left=\textsc{ (If-Fi-Reject) }]
% {\inferrule* {}
%     {\rho' = \Rho[x_{1} \mapsto \bot \dots x_{n} \mapsto \bot]}
%     \\\\
%     {\vmgs[env=\rho', context=\emptyseq, solution=\dagger]}
%     \\\\
%     \vmeval[exp={\iffi{\dots}}]}
%     {\vmeval[exp={\iffi{\vexists{x_{1} \dots x_{n}}\; gs \rightarrow e\; \square\; \dots}}]}
% \]


\[
\inferrule*[Left=\textsc{ (Eval-VconEmpty) }]
    {\ }
    {\vmeval[exp={K}, result={K}]}
\]

\[
\inferrule*[Left=\textsc{ (Eval-VconMulti) }]
    {\inferrule* {}
    {
    \vmeval[exp={\expr[i]}, result={v_{i}}]
    \and 
    1 \leq i \leq n
    }}
    {\vmeval[exp={K(\expr[1], \dots \expr[n])}, result={K(v_{1}, 
    \dots v_{i})}]}
\]

\[
\inferrule*[Left=\textsc{ (Eval-VconMulti-Fail) }]
    {\inferrule* {}
    {
    \exists e_{i}.\; 1 \leq i \leq n : \vmeval[exp={\expr[i]}, result={\fail}]
    }}
    {\vmeval[exp={K(\expr[1], \dots \expr[n])}, result={\fail}]}
\]


\[
\inferrule*[Left=\textsc{ (Eval-Name) }]
    {x \in \dom \rho 
    \\\\
    \rho(x) = \v}
    {\vmeval[exp={x}, result={\v}]}
\]

\[
\inferrule*[Left=\textsc{ (Eval-Name-Fail) }]
    {x \notin \dom \rho}
    {\vmeval[exp={x}, result={\fail}]}
\]

\[
\inferrule*[Left=\textsc{ (Eval-LambdaDecl) }]
    {\ }
    {\prun[exp={\lambda x.\expr}, value={\lambda x.\expr}]}
\]

% \[
% \inferrule*[Left=\textsc{ (Eval-Funapp-Fail) }]
%     {\vmeval[exp={\expr[1]}]
%     \\\\
%     r \rm{ does not have the form } {\lambda x.\expr}}
%     {\vmeval[exp={\expr[1]\; \expr[2]}, result=\fail]}
% \]

\[
\inferrule*[Left=\textsc{ (Eval-Funapp) }]
    {\vmeval[exp={\expr[1]}, result={\lambda x.\expr}]
    \\\\
    \vmeval[exp={\expr[2]}, result={\v'}]
    \\\\
    \vmeval[envext=\bracketed{x \mapsto \v'}]}
    {\vmeval[exp={\expr[1]\; \expr[2]}]}
\]

\[
\inferrule*[Left=\textsc{ (Eval-Literal) }]
    {\ }
    {\vmeval[exp={\v}, result={\v}]}
\]

}
