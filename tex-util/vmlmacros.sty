\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{vmlmacros}[2011/02/23 v1.0 Custom VML macros.]
% Thank you Norman Ramsey and Cheng Shao for the foundation needed for these!
\RequirePackage{amsmath}
\RequirePackage{geometry}
\RequirePackage{amsthm}
\RequirePackage{amssymb}
\RequirePackage{verbatim}
\RequirePackage{hyperref}
\RequirePackage{graphicx}
\RequirePackage{amsmath}
\RequirePackage{mathpartir}
\RequirePackage[anticlockwise]{rotating}
\RequirePackage{upgreek}
\RequirePackage{listings}
\RequirePackage{color}
\RequirePackage{simplebnf}
\RequirePackage{cleveref}
\RequirePackage{caption}
\RequirePackage{subcaption}
\RequirePackage{hyperref}
\RequirePackage{xspace}
\RequirePackage{enumitem}
\RequirePackage{tikz}
\RequirePackage{extarrows}
\RequirePackage{xcolor}
\RequirePackage{stmaryrd}
\RequirePackage[utf8]{inputenc}
\RequirePackage[noEnd=true]{algpseudocodex}
% TODO remove if unused 
% \RequirePackage{tikz}
% \RequirePackage{ebproof}
% \RequirePackage{alltt}
% \RequirePackage{qtree}
% \RequirePackage{semantic}



%%%%%%%%%% LANGUAGES %%%%%%%%%%
\newcommand\VMinus{\ensuremath{V^{-}}\xspace}
\newcommand\PPlus{\ensuremath{P^{+}}\xspace}
\newcommand\D{\ensuremath{D}\xspace}
\newcommand\dt{\ensuremath{t}\xspace}
\newcommand\U{\ensuremath{U}\xspace}
\newcommand\VC{\ensuremath{\mathcal{VC}}\xspace}

%%%%%%%%%% GENERAL MATH %%%%%%%%%%
\DeclareMathOperator{\dom}{dom}
\newcommand\gt{\mathrel{>}}
\newcommand\lt{\mathrel{<}}

\newcommand{\bracketed}[1]{\{#1\}}
\newcommand{\ttbraced}[1]{\tt{(}#1\tt{)}}
\newcommand{\ttsqbraced}[1]{\tt{[}#1\tt{]}}
\newcommand{\sqbraced}[1]{[#1]}


%%%%%%%%%% FORMATTING %%%%%%%%%%
\newcommand\vfilbreak[1][1in]{\vskip 0pt plus #1\penalty-200 \vskip 0pt plus -#1}

%%%%%%%%%% PPlus ABBREV. %%%%%%%%%%
\newcommand\Tlp{\it{Top-level Pattern}}

%%%%%%%%%% GENERAL ABSTRACT SYNTAX %%%%%%%%%%
\newcommand\valabstract{\ensuremath{\bf{val}\; x\; \mathit{=}\; \expr}}

%%%%%%%%%% PPlus ABSTRACT SYNTAX %%%%%%%%%%
\newcommand\tlp{\ensuremath{p^{t}}}
\newcommand\pbar{\ensuremath{\text{\large\texttt{\char`\|}}\mskip1mu}}
\newcommand\porp{\ensuremath{p_{1} \pbar p_{2}}}
\newcommand\whenexpr{\ensuremath{\mathit{when} \; \expr}}
\newcommand\pcommap{\ensuremath{p_{1}, p_{2}}}
\newcommand\parrowe{\ensuremath{p \leftarrow \expr}}
\newcommand\caseabstract{\ensuremath{\bf{case}\; \expr\; \bracketed{p\; \boldsymbol{\rightarrow}\expr}}}
\newcommand\wildcard{\ensuremath{\_}}

%%%%%%%%%% VMinus ABSTRACT SYNTAX %%%%%%%%%%

% Symbols 
\newcommand\ybar[1][]{\ensuremath{{\overline{y}}_{#1}}}
\newcommand\vbar[1][]{\ensuremath{{\overline{v}}_{#1}}}
\newcommand\xbar[1][]{\ensuremath{{\overline{x}}_{#1}}}
\newcommand\tbar[1][]{\ensuremath{{\overline{t}}_{#1}}}
\newcommand\gbar[1][]{\ensuremath{\gs_{#1}}}

\newcommand{\choice}{\,{\vrule width 1.5pt height 8pt}\,}
\newcommand{\vlambda}[1]{\lambda\ \langle #1 \rangle.}
\newcommand{\vexists}[1]{\ensuremath{\exists\, #1.}}

\newcommand\iffiabstract{\ensuremath{\bf{if}\; \Gs\; \bf{fi}}}
\newcommand\branchabstract{\ensuremath{\Gs}}
\newcommand\gexpabstract{\ensuremath{[\vexists{\xbar}]\; \gs \boldsymbol{\rightarrow}\expr}}
\newcommand\choiceabstract{\ensuremath{\choiceg{\gs}{\gs\,'}}}

%%%%%%%%%% D ABSTRACT SYNTAX %%%%%%%%%%

\newcommand\treetestabstract{\ensuremath{\mathit{test}\; x\; \bracketed{K_{i}/\ybar[i]\; \Rightarrow\; \dt}}\; [else\; \dt]}
% \newcommand\treeifabstract{\ensuremath{\mathit{if}\; x\; \mathit{then}\; \dt\; \mathit{else}\; \dt}}
\newcommand\treetryletabstract{\ensuremath{\mathit{let}\; x\; \mathit{=}\; \expr\; \mathit{in}\; \dt[; \mathit{unless}\; \bf{fail} \Rightarrow \; \dt]}}
\newcommand\treeifabstract{\ensuremath{\mathit{if}\; x\; \mathit{\xlongequal{\;}}\; \expr\; \mathit{then}\; \dt\; \mathit{else}\;  \dt}}
\newcommand\treeextractabstract{\ensuremath{\mathit{extract}\; x\; \bracketed{y}\; \expr\; \mathit{ in }\; \dt}}
\newcommand\treefailabstract{\ensuremath{\bf{fail}}}

\newcommand\red[1]{\textcolor{red}{#1}}
\newcommand\blue[1]{\textcolor{blue}{#1}}

\newcommand\utable {%
\centering
\small
\begin{tabular}{l l}
    \textbf{Syntactic Forms} & \textbf{Cases} \\
    \hline
    $P$ : Programs        & $\bracketed{d}$       \\
    $d$ : Definitions     & \valabstract          \\
    \v : Values          & $K\bracketed{\v}$     \\
                          & $\lambda x.\; \expr$  \\
    \\
    $\expr$ : Expressions & \v                  \\
                          & $x, y, z$             \\
                          & $K\bracketed{\expr}$  \\
                          & $\lambda x.\; \expr$  \\
                          & $\expr[1]\; \expr[2]$ \\
                          % & \caseabstract         \\
                          & \red{\iffiabstract}         \\
                          & \blue{\dt}         \\
    \\
    \red{\G} : \red{Guarded Expressions} & \red{\gexpabstract}      \\
    \red{\g} : \red{\textsf{Guards}}  & \red{$x = \expr$}           \\
                          & \red{\expr}               \\
                          & \red{\choiceabstract}       \\
                          % need raisebox here 0.5\baselineskip from "one below middle"
    \\                            
    \blue{\dt} : \blue{Decision Trees} &   $\blue{\treetestabstract}$ \\
                           & \blue{\expr}                    \\
                           & \blue{\vexists{x} \dt}                    \\
                           & \blue{\treetryletabstract}        \\
                           & \blue{\treeifabstract}           \\
                           % & \treeextractabstract       \\
                           & \blue{\treefailabstract}          \\
    \\
\end{tabular}
}

\newcommand\ppcsyntax {% 
\begin{bnf}
  $P$ : \textsf{Programs} ::=
  $\bracketed{d}$ : definition
  ;;
  $d$ : \textsf{Definitions} ::=
  | $\tt{val}\; x\; \tt{=}\; \expr$ : bind name to expression
  ;;
  $\expr$ : Expressions ::= 
  | $v$ : literal values 
  | $x, y, z$ : names
  | $K\bracketed{\expr}$ : value constructor application 
  | $\ttbackslash x.\; \expr$ : lambda declaration  
  | $\expr[1]\; \expr[2]$ : function application 
  | $\tt{case}\; \expr\; \bracketed{p\; \ttrightarrow\; \expr}$ : \it{case} expression 
  | \ttbraced{$\expr$}
  ;;
  $p$ : \textsf{Patterns} ::= $p_{1}\pbar p_{2}$ : or-pattern
  | $p \tt{,} p'$ : pattern guard 
  | $p\; \tt{<-}\; \expr$ : pattern from explicit expression  
  | $x$ : name 
  | $\tt{\_}$ : wildcard 
  | $K\; \bracketed{p}$ : value constructor application 
  | $\tt{when}\; \expr$
  | \ttbraced{$p$}
  ;;
  $\v$ : Values ::= $K\bracketed{\v}$ : value constructor application 
  | $\ttbackslash x.\; \expr$ : lambda value 
  ;;
  $K$ : \textsf{Value Constructors} ::=
  | $\tt{true}\; \vert\; \tt{false}$ : booleans
  | $\tt{A-Z}x$ : name beginning with capital letter
  % | $[\tt{-}\vert\tt{+}](\tt{0}-\tt{9})+$ : signed integer literal 
  \end{bnf}

}

\newcommand\dcsyntax {% 

\begin{bnf}
  $P$ :~\textsf{Programs} ::=
  $\bracketed{d}$ : definition
  ;;
  $d$ :~\textsf{Definitions} ::=
  | $\it{val}\; x\;~\it{=}\;~\expr$ : bind name to expression
  ;;
  $\expr$ :~\textsf{Expressions} ::=
  | $\v$ : literal values 
  | $x, y, z$ : names
  | $\dt$ : decision tree
  | $K~\bracketed{\expr}$ : value constructor application 
  | $\expr[1]\;~\expr[2]$ : function application 
  | $\lambda x.\;~\expr$ : lambda declaration 
  ;;
  $\dt$ : Decision Trees ::= 
  {\ensuremath{\it{test}\; x\; {\bracketed{K\bracketed{y} \; \Rightarrow\; \dt}} [\it{else}\; \dt]}} : test node
  | {\ensuremath{\it{let}\; x\; \it{=}\; \expr\; \it{in}\; \dt[\it{ unless fail => } \; \dt]}} : let-unless node
  | {\ensuremath{\it{if}\; x\; \it{=}\; \expr\; \it{then} \; \dt\; \it {else}\; \dt}} : comparison node
  | {\ensuremath{\exists\; x\it{.}\; \dt}} : exists node
  | {\ensuremath{\fail}} : fail node
  ;;
  $\v$ : Values ::= $K\bracketed{\v}$ : value constructor application 
  | $\lambda x.\;~\expr$ : lambda value
  ;;
  \end{bnf}
}

%%%%%%%%%% VERSE CONCRETE SYNTAX %%%%%%%%%%

%%%%%%%%%% VMinus JUDGEMENT RULES %%%%%%%%%%


% Context 
\newcommand\rhohat{\ensuremath{\hat{\rho}}}
\newcommand\tempstuck[1][\bracketed{eq}]{\tt{?t.}\it{#1}}
\newcommand\context{\ensuremath{\mathcal{T}}}


% Symbols 
\newcommand\expr[1][]{\ensuremath{e_{#1}}\xspace}
\newcommand\pat[1][]{\ensuremath{p_{#1}}\xspace}
\newcommand\guard[1][]{\ensuremath{g_{#1}}\xspace}
\newcommand\g[1][]{\ensuremath{g_{#1}}\xspace}
\newcommand\gs[1][]{\ensuremath{\overline{g_{#1}}}\xspace}
\newcommand\gsp[1][]{\ensuremath{\gs_{#1}\,'}\xspace}
\newcommand\Gsp[1][]{\ensuremath{\Gs_{#1}\,'}\xspace}

\newcommand\G[1][]{\ensuremath{G_{#1}}\xspace}
\newcommand\B[1][]{\ensuremath{B_{#1}}\xspace}
\newcommand\Gs[1][]{\ensuremath{\overline{G_{#1}}}\xspace}
\newcommand\name[1][]{\ensuremath{x_{#1}}\xspace}

\newcommand\one{\bf{\tt{one}}\xspace}
% \newcommand\dbar{\ensuremath{\square}}
\newfontfamily\dys{OpenDyslexic}[Scale=2.0]
\newcommand\dbar{\raisebox{-4pt}{\dys â–¯}}

\renewcommand\v[1][]{\ensuremath{v_{#1}}\xspace}

\newcommand\fail{\bf{fail}\xspace}
\newcommand\reject{\bf{reject}\xspace}
\newcommand\result[1][]{\ensuremath{r_{#1}}\xspace}
\newcommand\solution[1][]{\ensuremath{s_{#1}}\xspace}
\newcommand\arrowe{\ensuremath{\rightarrow \expr}\xspace}

\newcommand\ttleftarrow{\tt{\char`\<-}}
\newcommand\ttrightarrow{\tt{-\char`\>}}
\newcommand\ttbackslash{\tt{\char`\\}}

% Alphas, largely unused now 
\newcommand\valbar{\ensuremath{v^{\alpha}}}
\newcommand\galpha{\ensuremath{g_{\alpha}}}
\newcommand\ealpha[1][]{\ensuremath{e_{\alpha_{#1}}}}
\newcommand\ealphaone{\ensuremath{e_{\alpha_{1}}}}
\newcommand\ealphatwo{\ensuremath{e_{\alpha_{2}}}}
\newcommand\ealphan{\ensuremath{e_{\alpha_{n}}}}
\newcommand\ealphai{\ensuremath{e_{\alpha_{i}}}}
\newcommand\Dalpha{\ensuremath{\mathcal{D}_\alpha}}
\newcommand\valpha{\ensuremath{\vartheta}}


\makeatletter
\newcommand{\Rho}[1][\@nil]{%
\ensuremath{\rho
  \def\tmp{#1}%
   \ifx\tmp\@nnil
    \else
    \bracketed{#1}
    \fi}}
\makeatother

% \newcommand\Rho[1][]{\ensuremath{\rho}\bracketed{#1}}
\newcommand\Rhoprime{\ensuremath{\rho'}}

\newcommand\choiceg[2]{#1 \; \choice \; #2}

\newcommand\uppsidown{
    \raisebox{1.25ex}{
      \hspace{-0.75em}
      \begin{sideways}
        \ensuremath{\uppsi}
      \end{sideways}}
      }

% Wrapping forms 
\newcommand\iffi[1]{\bf{if} \;  #1  \; \bf{fi}}
\newcommand\iffitt[1]{\tt{if} \; #1 \; \tt{fi}}
\newcommand\iffibf{\bf{if-fi}\xspace}
\newcommand\TeqT[1]{\context \cdot #1 \cdot \context'}
\newcommand\gseqgs[1]{\gs \cdot #1 \cdot \gsp}
\newcommand\eqTT[1]{#1 \cdot \context \cdot \context'}
\newcommand\TT{\context \cdot \context'}
\newcommand\gsgs{\gs \cdot \gsp}
\newcommand\GsgsGs[1]{\Gs\; \dbar\; #1\; \dbar\; \Gsp}
\newcommand\GsGs{\Gs\; \dbar\; \Gsp}

% Shortcuts 

% Latex abbreviations 

%  Judgements 
\newcommand{\vtuple}[1]{%
  \let\c=\component%
  \ensuremath{\langle #1 \rangle}%
  }
  

\newcommand{\vjudgement}[2]{#1 \rightarrowtail{} #2}
  
\newcommand{\veval}[2]{REDO}
\newcommand{\vevalext}[3]{REDO}

% Quick display a v- judgement form
\newcommand{\showvjudgement}[3][Right]{%
  \[\inferrule*[#1=\textsc{ (#2) }]%
  {}      
  {#3}\]%
}
      
% Somewhat depricated 
\newcommand{\mkjudgementcmd}[3]{%
  \expandafter\newcommand\csname #1\endcsname{\vjudgement{#2}{#3}}%
  }

\newcommand{\mkevaljudgementcmd}[3]{%
  \expandafter\newcommand\csname #1\endcsname{\veval{#2}{#3}}%
  }

%%%%%%%%%% TRANSLATION %%%%%%%%%%
      
      % Translation rules with oxford brackets
\newcommand{\oxs}[1]{[\![#1]\!]}
\newcommand{\translate}[1]{ \mathcal{T} \oxs{#1}}
\newcommand{\desugar}[1]{ \mathcal{D} \oxs{#1}}

%%%%%%%%%% VANITY %%%%%%%%%%
\newcommand\nr[1]{\leavevmode\emph{NR: #1}}
\newcommand\rab[1]{\leavevmode\emph{rab: #1}}

%%%%%%%%%% OTHER %%%%%%%%%%

% Abbreviations 
\renewcommand{\tt}[1]{\texttt{#1}}
\renewcommand{\it}[1]{\textit{#1}}
\renewcommand{\bf}[1]{\textbf{#1}}
\renewcommand{\rm}[1]{\textrm{#1}}

% Fonts
\newcommand{\ppl}[1]{{\fontfamily{ppl}\selectfont #1}}

% Lists 
\newcommand\eq{\ensuremath{\mathit{eq}}}  % equation
\newcommand\xs{\ensuremath{\mathit{xs}}}
\newcommand\ys{\ensuremath{\mathit{ys}}}
\newcommand\zs{\ensuremath{\mathit{zs}}}
\newcommand\emptyseq{\ensuremath{\varepsilon}}

% Script letters, translation

\newcommand\script[1]{\ensuremath{\mathcal{#1}}}

% Failed attempt at parameterization 

% \makeatletter
% \newcommand{\translation}[2][]{%
% \newcommand{\dx}[1][]{%
%    \ifthenelse{ \equal{#1}{} }
%       {\ensuremath{\;\mathrm{d}x}}
%       {\ensuremath{\;\mathrm{d}#1}}
% }
%   \ensuremath{\script{#1}%
%     \def\tmp{#2}%
%     \ifx\tmp\@empty
%     \else
%         [\!#2\!]    
%     \fi}}
% \makeatother

% just names, lazy 
\newcommand\PtoVTran{\script{E}\xspace}
\newcommand\PTran{\script{P}\xspace}
\newcommand\DTran{\script{D}\xspace}
\newcommand\ITran{\script{I}\xspace}
\newcommand\Compile{\ensuremath{\mathit{compile}}\xspace}

% with bracketed parameter
\newcommand\translation[2]{\ensuremath{#1\oxs{#2}}}
\newcommand\ptovtran[1]{\translation{\PtoVTran}{#1}}
\newcommand\ptran[1]{\translation{\PTran}{#1}}
\newcommand\dtran[1]{\translation{\DTran}{#1}}
\newcommand\itran[1]{\translation{\ITran}{#1}}
\newcommand\compiletran[1]{\translation{\Compile}{#1}}

\newcommand\subst[3]{#1\left[#2/#3\right]}

\newcommand\known{\ensuremath{known}}
\newcommand\unknown{\ensuremath{unknown}}

\newcommand\ctx{\script{C}}

\newcommand\hookdoubleheadrightarrow{%
  \hookrightarrow\mathrel{\mspace{-15mu}}\rightarrow
}

\newcommand\compilesto{\hookdoubleheadrightarrow}

\newcommand{\goesto}[1]{\xrightarrow{#1}} % {\stackrel{#1}{\longrightarrow}}

    % rough opsem-based stuff: to change
\newcommand{\br}[1]{\langle #1 \rangle}


%%%%%%%%%% INFERENCE RULES %%%%%%%%%%


% Nice judgement and rule forms
\newcommand{\mono}[1]{%  Thanks Paul A. (Windfall Software)
\makeatletter
  {\@tempdima = \fontdimen2\font
   \frenchspacing
   \texttt{\spaceskip = 1.1\@tempdima{}#1}}}
\newcommand\xmono[2][1.1]
  {\@tempdima = \fontdimen2\font
   \frenchspacing
   \texttt{\spaceskip = #1\@tempdima{}#2}}
\makeatother
\newcommand*\monobox[2][1.1]{\mbox{\upshape\xmono[#1]{#2}}}

\newcommand\emptylist{\ensuremath{[\,]}}
\usepackage{keyval}


\makeatletter
\newcommand\defcomponent[2]{%
  \define@key{state}{#1}{\@nameuse{setmyval@#1}{##1}}%
  \@namedef{setmyval@#1}##1{\@namedef{myval@#1}{##1}}%
  \@nameuse{setmyval@#1}{\ensuremath{#2}}%
}

\newcommand\component[1]{\@nameuse{myval@#1}}

\makeatother

\defcomponent{env}{\rho}
\defcomponent{context}{\context}
\defcomponent{newcontext}{\context'}
% For translation where context and rho are analagous
\defcomponent{ctx}{\ctx}
\defcomponent{ctxext}{}
\defcomponent{newctx}{\ctx'}
\defcomponent{term}{\galpha}
\defcomponent{guard}{\g}
\defcomponent{guards}{\gs}
\defcomponent{gexp}{\G}
\defcomponent{gexps}{\Gs}
\defcomponent{exp}{\expr}
\defcomponent{pat}{\pat}
\defcomponent{value}{\v}
\defcomponent{result}{\result}
\defcomponent{compiled}{\expr}
\defcomponent{solution}{\solution}
\defcomponent{envext}{}
\defcomponent{tlp}{\tlp}
\defcomponent{newenv}{\rho'}
\defcomponent{gsolveresult}{\langle\c{newctx},\c{newenv}\rangle}
\defcomponent{eq}{\eq}
\defcomponent{name}{\name}
\defcomponent{tree}{\dt}
\defcomponent{eas}{}
\defcomponent{iffi}{\bf{if}\; \c{gexps}\; \bf{fi}}
\defcomponent{status}{\known}



\newcommand\emptycontext{\varepsilon}
\newcommand\emptyenv{\mathord{\{\,\}}}



\newcommand\vmrun[1][]{%  run V-minus code
  {\setkeys{state}{#1}%
   \let\c=\component
   \ensuremath{\c{env}\c{envext}; \c{context} \vdash \c{term} \Downarrow \c{result}}}}
   
\newcommand\vmrung[1][]{%  run V-minus code with normal g
   {\setkeys{state}{#1}%
   \let\c=\component
   \ensuremath{\c{env}\c{envext}; \c{context} \vdash \c{guard} \Downarrow \c{solution}}}}

\newcommand\vmgs[1][]{% do a list of guards
  {\setkeys{state}{#1}%
  \let\c=\component
  \ensuremath{\c{env}\c{envext} \vdash \c{guards} \rightarrowtail \c{solution}}}}


\newcommand\vmeval[1][]{%  eval a vminus expression
  {\setkeys{state}{#1}%
  \let\c=\component
  \ensuremath{\langle \c{env}\c{envext}, \c{exp} \rangle \Downarrow \c{result}}}}

\newcommand\ppeval[1][]{%  eval a pplus expression
  {\setkeys{state}{#1}%
  \let\c=\component
  \ensuremath{\langle \c{env}\c{envext}, \c{exp} \rangle \Downarrow \c{result}}}}

\newcommand\deval[1][]{%  eval a d expression
  {\setkeys{state}{#1}%
  \let\c=\component
  \ensuremath{\langle \c{env}\c{envext}, \c{exp} \rangle \Downarrow \c{result}}}}

\newcommand\treeval[1][]{%  eval a decision tree
  {\setkeys{state}{#1}%
  \let\c=\component
  \ensuremath{\c{env}\c{envext} \vdash \c{tree} \Downarrow \c{result}}}}


\newcommand\eqrefine[1][]{%  equation refines environment
  {\setkeys{state}{#1}%
  \let\c=\component
  \ensuremath{\c{env}\c{envext} \vdash \c{eq} \rightarrowtail \c{newenv}}}}


\newcommand\eqfail{\eqrefine[newenv=\dagger]}

\newcommand\grefine[1][]{%  do many guards
  {\setkeys{state}{#1}%
  \let\c=\component
  \ensuremath{\c{env}\c{envext} \vdash \c{guard} \rightarrowtail \c{solution}}}}

\newcommand\gfail{\grefine[solution=\dagger]}


\newcommand\prun[1][]{%  run P-plus code
  {\setkeys{state}{#1}%
    \let\c=\component
    \ensuremath{\br{\c{env}\c{envext}, \c{exp}} \Downarrow \c{value}}}}

\newcommand\ptov[1][]{%  translate P-plus to V-minus
    {\setkeys{state}{#1}%
      \let\c=\component
      \ensuremath{\ptovtran{\c{exp}} \rightsquigarrow \c{result}}}}
  
  \newcommand\pattov[1][]{%   translate patterns to V-minus
    {\setkeys{state}{#1}%
      \let\c=\component
      \ensuremath{\ptran{\c{pat}}\c{name} \rightsquigarrow \c{result}}}}

  \newcommand\pmatch[1][]{%  pattern-matching judgement
  {\setkeys{state}{#1}%
    \let\c=\component
    \ensuremath{\br{\c{env}\c{envext}, \c{pat}, \c{value}} \rightarrowtail \c{newenv}}}}

  \newcommand\pfail{\pmatch[newenv=\dagger]}

  \newcommand\tlpmatch[1][]{%  top-level-pattern-matching judgement
  {\setkeys{state}{#1}%
    \let\c=\component
    \ensuremath{\br{\c{env}\c{envext}, \c{tlp}, v} \rightarrowtail \c{newenv}}}}

  \newcommand\tlpfail{\tlpmatch[newenv=\dagger]}


\defcomponent{vterm}{\expr}
\defcomponent{vresult}{\expr'}

\newcommand\vrun[1][]{% run Verse code
  {\setkeys{state}{#1}%
   \let\c=\component
   \ensuremath{\c{vterm} \mathrel{\rightarrow^{*}} \c{vresult}}}}


\newcommand\vtod[1][]{%   translate V-minus to D
    {\setkeys{state}{#1}%
      \let\c=\component
      \ensuremath{\dtran{\c{exp}} \rightsquigarrow \c{result}}}}

\newcommand\knownj[1][]{%   compile an if-fi on a large level
  {\setkeys{state}{#1}%
    \let\c=\component
    \ensuremath{\c{ctx}\c{ctxext} \vdash \c{exp}\; :\; \c{status}}}}


\newcommand\compilebig[1][]{%   compile an if-fi on a large level
  {\setkeys{state}{#1}%
    \let\c=\component
    \ensuremath{\c{ctx}\c{ctxext} \vdash \c{iffi} \compilesto \c{compiled}}}}

      
\newcommand\compile[1][]{%   compile an if-fi
  {\setkeys{state}{#1}%
    \let\c=\component
    \ensuremath{\c{ctx}\c{ctxext} \vdash\; \c{eas}\; \bf{if}\; \Gs\; \dbar\; 
                \gs;\; \c{guard} \rightarrow \c{exp}';\; \gsp\; 
                \dbar\; \Gsp\; \bf{fi} \compilesto \c{compiled}}}}


% Listings color 
\definecolor{eclipseBlue}{RGB}{42,0.0,255}
\definecolor{eclipseGreen}{RGB}{63,127,95}

\newcommand\smllst
{\lstset {
  basicstyle=\small\ttfamily,
  captionpos=b,
  xleftmargin=100pt,
  tabsize=2,
  columns=fixed,
  breaklines=true,
  frame=l,
  numbers=left,
  numberstyle=\small\ttfamily,
  morekeywords= {
    EQUAL, GREATER, LESS, NONE, SOME, abstraction, abstype, and, andalso, array, as, before, bool, case, char, datatype, do, else, end, eqtype, exception, exn, false, fn, fun, functor, handle, if, in, include, infix, infixr, int, let, list, local, nil, nonfix, not, o, of, op, open, option, orelse, overload, print, raise, real, rec, ref, sharing, sig, signature, string, struct, structure, substring, then, true, type, unit, val, vector, where, while, with, withtype, word
  },
  morestring=[b]",
  morecomment=[s]{(*}{*)},
  stringstyle=\color{black},
  identifierstyle=\color{teal},
  keywordstyle=\color{orange},
  commentstyle=\color{eclipseGreen}
}}

\newcommand\pplst
{\lstset {
  basicstyle=\small\ttfamily,
  captionpos=b,
  % xleftmargin=10pt,
  tabsize=2,
  columns=fixed,
  breaklines=true,
  % frame=l,
  numbers=left,
  numberstyle=\small\ttfamily,
  morekeywords= {
    val, case, of, |, when, ->, <-
  },
  morestring=[b]",
  morecomment=[l]{;},
  stringstyle=\color{black},
  identifierstyle=\color{teal},
  keywordstyle=\color{orange},
  commentstyle=\color{eclipseGreen}
}}

\newcommand\vmlst
{\lstset {
  basicstyle=\small\ttfamily,
  captionpos=b,
  % xleftmargin=10pt,
  tabsize=2,
  columns=fixed,
  breaklines=true,
  % frame=l,
  numbers=left,
  numberstyle=\small\ttfamily,
  morekeywords= {
    val, if, fi, |, when, ->, <-
  },
  morestring=[b]",
  morecomment=[l]{\#},
  stringstyle=\color{black},
  identifierstyle=\color{teal},
  keywordstyle=\color{orange},
  commentstyle=\color{eclipseGreen}
}}

\newcommand\schemelst
{\lstset {
  basicstyle=\small\ttfamily,
  captionpos=b,
  tabsize=2,
  columns=fixed,
  breaklines=true,
  frame=l,
  numbers=left,
  numberstyle=\small\ttfamily,
  morekeywords= {
    car, cdr, cons, '()
  },
  morestring=[b]",
  morecomment=[s]{(*}{*)},
  stringstyle=\color{black},
  identifierstyle=\color{teal},
  keywordstyle=\color{orange},
  commentstyle=\color{eclipseGreen}
}}

\newcommand\verselst
{\lstset {
  basicstyle=\small\ttfamily,
  captionpos=b,
  tabsize=2,
  xleftmargin=100pt,
  columns=fixed,
  breaklines=true,
  % frame=l,
  numbers=left,
  numberstyle=\small\ttfamily,
  morekeywords= {
    one, all, $\exists$, if, then, else, =
  },
  morestring=[b]",
  morecomment=[s]{(*}{*)},
  stringstyle=\color{black},
  % identifierstyle=\color{teal},
  % keywordstyle=\color{orange},
  % commentstyle=\color{eclipseGreen},
  mathescape
}}

%  Bulk command definition
% \def\do#1{\expandafter\newcommand\csname#1\endcsname{\elem{#1}}}
% \docsvlist {fire,earth,air,ice,dark,light,wild}
% \let\frost\ice

% \newcommand\bulkdef[2]{% command arglist
%   \def\do##1{\expandafter\newcommand\csname##1\endcsname{#1{##1}}}%
%   \docsvlist{#2}}

% \bulkdef\gen{attack,jump,range,move,shield,loot,retaliate,teleport,xp,heal,target,damage}  
% \bulkdef\cond{push,pull,muddle,bane,poison,wound,invisible,immobilize,disarm,curse,stun,strengthen,pierce,brittle,bless,impair}
% \newcommand\eat{\consume}

% \bulkdef\icon{shuffle}

% \let\shuffleicon=\shuffle
% \def\shuffle{\hfill\shuffleicon\mbox{\hskip 0.5em}\parfillskip=0pt}


%%%%%%%%%%%%%%%%% SEMANTICS %%%%%%%%%%%%%%%%%
\newcommand\usemantics{%
\subsubsection{Judgement forms for \U}

In both \VMinus and \D, an expression evaluates to produce a single \it{result}. 
A result is either a single value \v or \fail. 

\showvjudgement{Eval}{\vmeval}

\subsection{Evaluating general expressions in \U}

Here, I show all the rules which are shared by \VMinus and \D under \U. 

\[
\inferrule*[Left=\textsc{ (Eval-Vcon) }]
    {\inferrule* {}
    {
    \vmeval[exp={\expr[i]}, result={v_{i}}]
    \and 
    1 \leq i \leq n
    }}
    {\vmeval[exp={K(\expr[1], \dots \expr[n])}, result={K(v_{1}, 
    \dots v_{i})}]}
\]

\[
\inferrule*[Left=\textsc{ (Eval-Vcon-Fail) }]
    {\inferrule* {}
    {
    \exists e_{i}.\; 1 \leq i \leq n : \vmeval[exp={\expr[i]}, result={\fail}]
    }}
    {\vmeval[exp={K(\expr[1], \dots \expr[n])}, result={\fail}]}
\]


\[
\inferrule*[Left=\textsc{ (Eval-Name) }]
    {x \in \dom \rho 
    \\\\
    \rho(x) = \v}
    {\vmeval[exp={x}, result={\v}]}
\]

\[
\inferrule*[Left=\textsc{ (Eval-LambdaDecl-MkClosure)}]
    {\ }
    {\prun[exp={\lambda x.\expr}, value={\llparenthesis \lambda x.\expr, \rho \rrparenthesis}]}
\]


\[
\inferrule*[Left=\textsc{ (Eval-Funapp-WithClosure) }]
    {\vmeval[exp={\expr[1]}, result={\llparenthesis \lambda x.\expr, \rho' \rrparenthesis}]
    \\\\
    \vmeval[exp={\expr[2]}, result={\v}]
    \\\\
    \vmeval[env= {(\rho + \rho')}, envext=\bracketed{x \mapsto \v}]}
    {\vmeval[exp={\expr[1]\; \expr[2]}]}
\]

\[
\inferrule*[Left=\textsc{ (Eval-Funapp-Fail) }]
    {\vmeval[exp={\expr[1]}, result={\llparenthesis \lambda x.\expr, \rho' \rrparenthesis}]
    \\\\
    \vmeval[exp={\expr[2]}, result={\fail}]}
    {\vmeval[exp={\expr[1]\; \expr[2]}, result=\fail]}
\]

\[
\inferrule*[Left=\textsc{ (Eval-Literal) }]
    {\ }
    {\vmeval[exp={\v}, result={\v}]}
\]
}

\newcommand\guardnameexpbot{%
\[
\inferrule*[Left=\textsc{ (Guard-NameExp-Bot) }]
    {\inferrule* {}
    {
    x \in \dom \rho
    \\\\
    \vmeval[result=\v]
    \\\\
    \rho(x) = \bot
    }}
    {\eqrefine[eq={x = \expr},newenv={\Rho[x \mapsto \v]}]}
\]
}

\newcommand\guardnameexpeq{%
\[
\inferrule*[Left=\textsc{ (Guard-NameExp-Eq) }]
    {\inferrule* {}
    {
    x \in \dom \rho
    \\\\
    \vmeval[result=\v]
    \\\\
    \rho(x) = \v
    }}
    {\eqrefine[eq={x = \expr},newenv={\Rho}]}
\]
}

\newcommand\guardnameexpfail{%
\[
\inferrule*[Left=\textsc{ (Guard-NameExp-Fail) }]
    {\inferrule* {}
    {
    x \in \dom \rho
    \\\\
    \vmeval[result=\v]
    \\\\ 
    \rho(x) = \v'
    \\\\
    \v \neq \v'
    }}
    {\eqrefine[eq={x = \expr},newenv=\dagger]}
\]
}

\newcommand\guardnamesbotsucc{%
\[
\inferrule*[Left=\textsc{ (Guard-Names-Bot-Succ) }]
    {\inferrule* {}
    {
    x, \;y  \in \dom \rho
    \\\\
    \rho(x) = \v,\; \rho(y) = \bot
    }}
    {\eqrefine[eq={x = y},newenv={\Rho[y \mapsto \v]}]}
\]
}


\newcommand\guardnamesbotsuccrev{%
\[
\inferrule*[Left=\textsc{ (Guard-Names-Bot-Succ-Rev) }]
    {\inferrule* {}
    {
    x, \;y  \in \dom \rho
    \\\\
    \rho(x) = \bot,\; \rho(y) = \v
    }}
    {\eqrefine[eq={x = y},newenv={\Rho[x \mapsto \v]}]}
\]
}

\newcommand\vmsemantics{% 

These judgement forms and rules are specific to \VMinus. 

\subsubsection{Judgement forms for \VMinus}

\showvjudgement{Guard-Refine}{\grefine[solution=\rho']}
\showvjudgement{Guard-reject}\gfail

\subsubsection{Choosing and solving a guard}

\[
\inferrule*[Left=\textsc{ (Solve-Guard-Refine) }]
    {\grefine[solution=\Rhoprime]
    \and
    \vmgs[env=\Rhoprime,guards=\;\gsgs]}
    {\vmgs[guards=\gseqgs{\g}]}
\]

\[
\inferrule*[Left=\textsc{ (Solve-Guard-Reject) }]
    {\gfail}
    {\vmgs[guards=\gseqgs{\g},solution=\dagger]}
\]
\subsubsection{Properties of guards}

\[
\inferrule*[Left=\textsc{ (Multi-Guard-Commut) }]
    {\vmgs[guards=\gseqgs{g_{1} \cdot g_{2}}]}
    {\vmgs[guards=\gseqgs{g_{2} \cdot g_{1}}]}
\]


% \[
% \inferrule*[Left=\textsc{ (Multi-Eq-Assoc) }]
%     {\vmrung[context=\TeqT{\expr[2] = \expr[1] \cdot \expr[1] = \expr[2]}]}
%     {\vmrung[context=\TeqT{\expr[1] = \expr[2] \cdot \expr[2] = \expr[1]}]}
% \]

\subsubsection{Desugaring of Complex Equations}
\[
\inferrule*[Left=\textsc{ (Desugar-EqExps) }]
    {\inferrule* {}
    {
    x \rm{ fresh}
    \\\\
    \vmrung[envext=\bracketed{x \mapsto \bot},
          guards=\gseqgs{x = \expr[1] \cdot x = \expr[2]}]}}
    {\vmgs[guards=\gseqgs{\expr[1] = \expr[2]}]}
\]

% \[
% \inferrule*[Left=\textsc{ (Desugar-Vcon-Multi) }]
%     {
%     \vmrung[context=\TeqT{\lbrack \expr[i]=\expr[i]'\; 
%            \vert\; 1 \leq i \leq n \rbrack}]}
%     {\vmrung[context=\TeqT{K(\expr[1], \dots 
%             \expr[n]) = K(\expr[1]', \dots \expr[n]')}]}
% \]

\subsubsection{Refinement with different types of guards}

\guardnameexpbot

\guardnameexpeq

\guardnameexpfail

\guardnamesbotsucc

\guardnamesbotsuccrev


% \rab{The vcon success rule is being edited with a change in the semantics.}

\[
  \inferrule*[Left=\textsc{ (Guard-Vcon-Succ) }]
      {\inferrule* {}
      {x \in \dom \rho 
        \\\\
        \rho(x) = K\; v_{1}, \dots v_{n}
        \\\\
        \eqrefine[eq={y_{1} = e_{1}; \cdot \dots \cdot y_{n} = e_{n}}, 
              newenv=\solution], \text{ where}
        \\\\
        y_{i} \text{ fresh, } \rho(y_{i}) = v_{i} \and 1 \leq i \leq n
      }}
      {\eqrefine[eq={x = K\; e_{1} \dots e_{n}}, 
              newenv=\solution]}
  \]
  
  \[
  \inferrule*[Left=\textsc{ (Guard-Vcon-Fail) }]
      {x \in \dom \rho
      \\\\
      \rho(x) = \v
      \\\\        
      \v \rm{ does not have the form }  K [v_{1}', \dots v_{n}']}
      {\eqrefine[eq={x = K\; e_{1}, \dots e_{n}}, 
              newenv=\dagger]}
  \]

\[
\inferrule*[Left=\textsc{ (Guard-Expseq-Succ) }]
    {\inferrule* {}
    {
    \vmeval[result=\v]}}
    {\grefine[guard=\expr, solution=\rho]}
\]

\[
\inferrule*[Left=\textsc{ (Guard-Expseq-Fail) }]
    {\vmeval[result={\fail}]}
    {\grefine[guard=\expr, solution=\dagger]}
\]

\[
\inferrule*[Left=\textsc{ (Guard-Choice-First) }]
    {\vmgs[context=\emptyseq, solution=\rho']}
    {\grefine[guard={\choiceg{\gs}{\gs'}}, solution=\rho']}
\]

\[
\inferrule*[Left=\textsc{ (Guard-Choice-Second) }]
    {\vmgs[context=\emptyseq, solution=\dagger] 
    \and 
    \vmgs[context=\emptyseq, guards=\gs']}
    {\grefine[guard={\choiceg{\gs}{\gs'}}]}
\]

\subsubsection{Evaluating \bf{if-fi}}

\[
\inferrule*[Left=\textsc{ (Eval-IfFi-Fail) }]
    {\ }
    {\vmeval[exp={\iffi{\ }}, result={\fail}]}
\]

\[
\inferrule*[Left=\textsc{ (Eval-IfFi-Success) }]
{\inferrule* {}
    {\rho' = \Rho[x_{1} \mapsto \bot \dots x_{n} \mapsto \bot]}
    \\\\
    {\vmgs[env=\rho', context=\emptyseq, solution=\rho'']}
    \\\\ 
    {\vmeval[env={\rho''}]}}
    {\vmeval[exp={\iffi{\vexists{x_{1} \dots x_{n}}\; \gs \rightarrow \expr\; \dbar; \Gs}}]}
\]

\[
\inferrule*[Left=\textsc{ (Eval-IfFi-Reject) }]
{\inferrule* {}
    {\rho' = \Rho[x_{1} \mapsto \bot \dots x_{n} \mapsto \bot]}
    \\\\
    {\vmgs[env=\rho', context=\emptyseq, solution=\dagger]}
    \\\\
    \vmeval[exp={\iffi{\Gs}}]}
    {\vmeval[exp={\iffi{\vexists{x_{1} \dots x_{n}}\; \gs \rightarrow \expr\; \dbar\; \Gs}}]}
\]
}


\newcommand\ppsemantics {      

      \subsubsection{Judgement forms for \PPlus}

      \showvjudgement{Eval}{\ppeval}
      \showvjudgement{Match-Success}{\pmatch}
      \showvjudgement{Match-Fail}{\pfail}

      \subsubsection{Evaluating General Expressions}
      
      \[
      \inferrule*[Left=\textsc{ (Eval-VconEmpty) }]
          {\ }
          {\ppeval[exp={K}, result={K}]}
      \]
      
      \[
      \inferrule*[Left=\textsc{ (Eval-VconMulti) }]
          {\inferrule* {}
          {
          \ppeval[exp={\expr[i]}, result={v_{i}}]
          \and 
          1 \leq i \leq n
          }}
          {\ppeval[exp={K(\expr[1], \dots \expr[n])}, result={K(v_{1}, 
          \dots v_{i})}]}
      \]
      
      
      \[
      \inferrule*[Left=\textsc{ (Eval-Name) }]
          {x \in \dom \rho 
          \\\\
          \rho(x) = \v}
          {\ppeval[exp={x}, result={\v}]}
      \]
      
      \[
      \inferrule*[Left=\textsc{ (Eval-LambdaDecl) }]
          {\ }
          {\prun[exp={\lambda x.\expr}, value={\lambda x.\expr}]}
      \]
      
      \[
      \inferrule*[Left=\textsc{ (Eval-Funapp) }]
          {\ppeval[exp={\expr[1]}, result={\lambda x.\expr}]
          \\\\
          \ppeval[exp={\expr[2]}, result={\v'}]
          \\\\
          \ppeval[envext=\bracketed{x \mapsto \v'}]}
          {\ppeval[exp={\expr[1]\; \expr[2]}]}
      \]
      
      \[
      \inferrule*[Left=\textsc{ (Eval-Literal) }]
          {\ }
          {\ppeval[exp={\v}, result={\v}]}
      \]
      
      \[
      \inferrule*[Left=\textsc{ (Eval-CaseScrutinee) }]
          {\inferrule* {}
          {\prun[value=\v]}
          \and 
          \prun[exp=
              {\it{case}\; \v \;
              [p_{1}\; {\expr[1]}], \dots, [p_{n}\; {\expr[n]}]},
              value=\v']}    
          {\prun[exp=
          {\it{case}\; {\expr}\;
          [p_{1}\; {\expr[1]}], \dots, [p_{n}\; {\expr[n]}]},
          value=\v']}
      \]
      
      \[
      \inferrule*[Left=\textsc{ (Eval-CaseMatch) }]
          {\inferrule* {}
          {\pmatch[pat={p_{1}}, newenv=\rho']}
          \and
          {\prun[exp= {\expr[1]}, env=\rho + \rho']}}
          {\prun[exp=
          {\it{case}\; \v \; 
          [p_{1}\; \expr[1]], \dots, [p_{n}\; \expr[n]]},
          value=\v']}
      \]
      
      \[
      \inferrule*[Left=\textsc{ (Eval-CaseFail) }]
          {\inferrule* {}
          {\pmatch[pat={p_{1}}, newenv=\dagger]}
          \and 
          \prun[exp={\it{case}\; \v\;  
          [p_{2}\; \expr[2]], \dots, [p_{n}\; \expr[n]]},
          value=\v']}    
          {\prun[exp=
          {\it{case}\; \v \; 
          [p_{1}\; \expr[1]], \dots, [p_{n}\; \expr[n]]},
          value=\v']}
      \]
      
      
      
      \subsubsection{Rules for pattern matching}
      
      
      \[
      \inferrule*[Left=\textsc{ (Pat-MatchVcon) }]
          {\inferrule* {}
          {
          \pmatch[pat=p_{i}, value=v_{i}, newenv=\solution{i}], \and 1 \leq i \leq n
          \\\\
          \solution = \solution{1} \uplus \dots \uplus \solution{n}
          }}
          {\pmatch[pat={K [p_{1} \dots 
                  p_{n}]}, value={K [v_{1}' \dots v_{n}']},
                  newenv=\solution]}
      \]
      
      \[
      \inferrule*[Left=\textsc{ (Pat-FailVcon) }]
          {\v \rm{ does not have the form }  K [v_{1}', \dots v_{n}']}
          {\pmatch[pat={K\; p_{1}, \dots p_{n}}, 
                  newenv=\dagger]}
      \]
      
      \[
      \inferrule*[Left=\textsc{ (Pat-MatchBareVcon) }]
          {\ }
          {\pmatch[pat={K}, value={K},
                  newenv=\bracketed{}]}
      \]
      
      \[
      \inferrule*[Left=\textsc{ (Pat-FailBareVcon) }]
          {\v \neq {K}}
          {\pmatch[pat={K},
                  newenv=\dagger]}
      \]
      
      \[
      \inferrule*[Left=\textsc{ (Pat-MatchVar) }]
          {\ }
          {\pmatch[pat={x},
                  newenv=\bracketed{x \mapsto \v}]}
      \]
      
      \[
      \inferrule*[Left=\textsc{ (Pat-MatchWhen) }]
          {\prun[value=\v'] \and \v' \neq \mathit{false}}
          {\pmatch[pat={\whenexpr},
                  newenv=\bracketed{}]}
      \]
      
      \[
        \inferrule*[Left=\textsc{ (Pat-MatchWildcard) }]
            {\ }
            {\pmatch[pat={_},
                    newenv=\bracketed{}]}
        \]

      \[
      \inferrule*[Left=\textsc{ (Pat-FailWhen) }]
      {\prun[value=\v'] \and \v' = \mathit{false}}
      {\pmatch[pat={\whenexpr},
                  newenv=\dagger]}
      \]
      
      
      \[
      \inferrule*[Left=\textsc{ (Pat-ArrowExp) }]
      {\prun[value=\v'] \and \pmatch[pat=p, value=\v', newenv=\solution]}
      {\pmatch[pat={\parrowe},
                  newenv=\solution]}
      \]
      
      
      \[
      \inferrule*[Left=\textsc{ (Pat-MultiFail) }]
      {\pmatch[pat=p, newenv=\dagger]}
      {\pmatch[pat={\pcommap},
                  newenv=\dagger]}
      \]
      
      
      \[
      \inferrule*[Left=\textsc{ (Pat-MultiSolution) }]
      {\inferrule* {}
      {\pmatch[pat={p_{1}}, newenv=\Rhoprime]}
      \\\\
      \pmatch[env=\Rho \uplus \Rhoprime, pat=p_{2}, newenv=\solution]}
      {\pmatch[pat={\pcommap}, newenv=\solution]}
      \]
      
      \[
      \inferrule*[Left=\textsc{ (Pat-OrFst) }]
          {\pmatch[pat={p_{1}}]}
          {\pmatch[pat={\porp}]}
      \]
      
      
      \[
      \inferrule*[Left=\textsc{ (Pat-OrSnd) }]
          {\pmatch[pat=p_{1}, newenv=\dagger]
          \and 
          \pmatch[pat={p_{2}}, newenv=\solution]}
          {\pmatch[pat={\porp}, newenv=\solution]}
      \]
      

}

\newcommand\dsemantics{% 

\subsection{Rules (Big-step Operational Semantics) for ${\D}$:}
\label{dsemantics}

\subsubsection{Evaluating Decision Trees}

\[
\inferrule*[Left=\textsc{ (Eval-Test-Fail) }]
    {\ }
    {\treeval[tree={test({x, []})}, result={\fail}]}
\]

\[
\inferrule*[Left=\textsc{ (Eval-Test-Succeed) }]
    {\rho(x) = K\; \vbar
    \and len\; \vbar = i
    \\\\ 
    {\treeval[tree={t}, result={\result}]}
    }
    {\treeval[tree={test({x, (K\; \ybar, t) \cdot ts})}, result={\result}]}
\]

\[
\inferrule*[Left=\textsc{ (Eval-Test-Recurse) }]
    {\rho(x) = \v
    \\\\
    \v \rm{ does not have the form } K\; \vbar \rm{ s.t. } len\; \vbar  = len\; \ybar
    \\\\ 
    {\treeval[tree={test({x, ts}), result={\result}}]}
    }
    {\treeval[tree={test({x, (K\; \ybar, t) \cdot ts})}, result={\result}]}
\]

\[
\inferrule*[Left=\textsc{ (If-First) }]
    {\treeval[tree=e, result=\v]
    \\\\ 
    \rho(x) = \v
    \\\\
    {\treeval[tree={\dt_{1}}, result={\result}]}
    }
    {\treeval[tree={if\; x = e\; then\; \dt_{1}\; else \dt_{2}\; unless\; \fail \Rightarrow \dt_{3}}, result={\result}]}
\]

\[
\inferrule*[Left=\textsc{ (If-Second) }]
    {\treeval[tree=e, result=\v]
    \\\\ 
    \rho(x) \neq \v
    \\\\
    {\treeval[tree={\dt_{2}}, result={\result}]}
    }
    {\treeval[tree={if\; x = e\; then\; \dt_{1}\; else \dt_{2}\; unless\; \fail \Rightarrow \dt_{3}}, result={\result}]}
\]

\[
\inferrule*[Left=\textsc{ (If-Unless) }]
    {\treeval[tree=e, result=\fail]
    \\\\ 
    {\treeval[tree={\dt_{3}}, result={\result}]}
    }
    {\treeval[tree={if\; x = e\; then\; \dt_{1}\; else \dt_{2}\; unless\; \fail \Rightarrow \dt_{3}}, result={\result}]}
\]

\[
\inferrule*[Left=\textsc{ (Let-Succeed) }]
    {\treeval[tree=e, result=\v]
    \\\\ 
    {\treeval[envext={\bracketed{x \mapsto \v}}, tree={\dt_{1}}, result={\result}]}
    }
    {\treeval[tree={let\; x = e\; in\; \dt_{1}\; unless\; \fail \Rightarrow \dt_{2}}, result={\result}]}
\]


\[
\inferrule*[Left=\textsc{ (Let-Unless) }]
    {\treeval[tree=e, result=\fail]
    \\\\ 
    {\treeval[tree={\dt_{2}}, result={\result}]}
    }
    {\treeval[tree={let\; x = e\; in\; \dt_{1}\; unless\; \fail \Rightarrow \dt_{2}}, result={\result}]}
\]

\[
\inferrule*[Left=\textsc{ (Fail) }]
    {\ }
    {\treeval[tree={\fail}, result={\fail}]}
\]

\[
\inferrule*[Left=\textsc{ (Exists) }]
    {\treeval[envext={\bracketed{x \mapsto \bot}}, tree={\dt}, result={\result}]
    }
    {\treeval[tree={\vexists{x}\; \dt}, result={\result}]}
\]


}

\newcommand\compiler{%
\label{compiler}

The judgement form for the compiler is: 

\showvjudgement{Compile}{\compilebig}

\subsection{Rules (Big-step Translation) for compiling \iffibf}

These rules in a nondeterministic order by the compiler. 

\[
\inferrule*[Left=\textsc{ (Exists) }]
    {\compilebig[ctxext={\bracketed{x_1 \mapsto unknown}}, gexps={\GsgsGs{\vexists{\dots x_{n}}\; \gs \rightarrow \expr'}}]}
    {\compilebig[gexps={\GsgsGs{\vexists{x_{1} \dots x_{n}}\; \gs \rightarrow \expr'}}]}
\]

If the compiler finds one or more names introduced by $\exists$, it strips a
name from the $\exists$ list and adds it to~\ctx as~\it{unknown}. This is the
rule that grows the context with new names, along with lambda, which 
introduces its argument as \it{known}. 

\[
\inferrule*[Left=\textsc{ (Fail) }]
    {\compilebig[gexps=\GsGs]}
    {\compile[guard={\fail}]}
\]

If the compiler finds a guarded expression \G which contains~\fail, it stops
compiling \G altogether. 

\[
\inferrule*[Left=\textsc{ (Match) }]
    {\ }
    {\compilebig[gexps={\GsgsGs{}}]}
\]

If the compiler finds an ungarded right-hand side expression~\expr', it inserts
a~\it{match} node containing~\expr'.

\[
\inferrule*[Left=\textsc{ (Test) }]
    {\rho(x) = known
    \\\\
    \compilebig[ctxext={ + \overline{\bracketed{y_{i} \mapsto known}}}, 
             iffi=\subst{\expr}{K_{i}\; {\ybar[i]}}{x}, compiled={\expr[i]}]
    \\\\
    \tbar = \sum_{i} K_{i}\; \ybar[i] \Rightarrow \expr[i]
    \\\\
    \expr[0] = \subst{\expr}{K_{0}}{x} \and K_{0} \text{ does not appear in } e
    }
    {\compile[eas={\expr \text{ as }}, guard={x = K\; \expr[1] \dots \expr[n]},
    compiled={test(x, \tbar, \expr[0])}]}
\]

If the compiler finds a known name $x$ equated to the application of a value
constructor~\it{K}, it assembles a set of branches that correspond to varying
value constructors. The only requirement of the set is that it contain~\it{K}.
With substiution of~$\subst{}{K_{i}{\ybar[i]}}{x}$, the compiler ensures that
$x$ will never be tested again, and also allows for rules~\textsc{Elim-Vcon}
and~\textsc{Expand-Vcon} to make progress. 

\[
\inferrule*[Left=\textsc{ (Elim-Vcon) }]
    {
    \compilebig[gexps=\GsGs]
    \\\\
    \expr[lhs] \text{ does not have the form } K\; \expr'[1] \dots \expr'[n]
    }
    {\compile[guard={\expr[lhs] = K\; \expr[1] \dots \expr[n]}]}
\]

If the compiler finds two equated expressions where one is an application of a
value constructor to $n$ arguments and the other isn't, the compiler skips over
that branch, like in \textsc{Fail}.

\[
\inferrule*[Right=\textsc{ (Expand-Vcon) }]
    {
    \compile[guard={{\expr[1]}' = \expr[1];\; \dots;\; {\expr[n]}' = \expr[n]}]
    }
    {\compile[guard={K\; {\expr[1]}' \dots {\expr[n]}' = K\; \expr[1] \dots \expr[n]}]}
\]

If the compiler finds two equated expressions where each is an application of a
value constructor to $n$ arguments, the compiler expands the single equation
into a list of equations between the arguments. 

\[
\inferrule*[Right=\textsc{ (Let-Unless) }]
    {\rho(x) = unknown \and \knownj[exp=\expr']
    \\\\
    \compilebig[ctxext={\bracketed{x \mapsto known}}, iffi=\subst{\expr}{x}{\expr'}, compiled=\dt_{1}]
    \\\\
    \dt_{2} = \subst{\expr}{\fail}{\expr'}
    }
    {\compile[eas={\expr \text{ as }}, guard={x = e}, 
              compiled={let\; x = \expr'\; in \; \dt_{1}\; unless\; \fail\; \Rightarrow\; \dt_{2}}]}
\]

If the compiler finds an opportunity to bind a name to an expression \expr', it
creates a~\it{let-unless} node and substitutes $x$ for all instances of \expr',
making $x$ known in the new context. In the \it{unless \fail} branch, \fail is
substituted for \expr' so that \textsc{Fail} can eliminate guarded expressions
containing it. 

\[
\inferrule*[Right=\textsc{ (Let-If) }]
    {\rho(x) = known \and \knownj[exp=\expr'] 
    \\\\
    \dt_{1} = \subst{\expr}{x}{\expr'}
    \\\\
    \compilebig[ctxext={\bracketed{y \mapsto known}}, iffi=\subst{\subst{\expr}{\fail}{x = \expr'}}{y}{\expr'}, compiled=\dt_{2}] \and y \text{ fresh}
    \\\\
    \dt_{3} = \subst{\expr}{\fail}{\expr'}
    \\\\
    \dt_{if} = {if\; x = y\; then\; \dt_{1}\; else\; \dt_{2}}
    }
    {\compile[eas={\expr \text{ as }}, guard={y = e}, 
              compiled={let\; x = \expr'\; in \;{\dt_{if}}\; unless\; \fail\; \Rightarrow\; \dt_{3}}]}
\]

If the compiler finds two expressions being compared \expr', it creates
an~\it{if} node within a~\it{let-unless} node, binding a fresh name $y$ to
\expr' and using it for substitution to ensure \expr' is never evaluated again.
Like in \textsc{Let-Unless}, in the \it{unless \fail} branch, \fail is
substituted for \expr' so that \textsc{Fail} can eliminate guarded expressions
containing it. 

}