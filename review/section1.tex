\documentclass[manuscript,screen,review, 12pt, nonacm]{acmart}
\let\Bbbk\relax % Fix for amssymb clash 
\usepackage{vmlmacros}

\begin{document}

\section{Introduction}
% Subjects: Pattern matching and Equations 

Pattern matching is a beloved tool among functional programmers for examining
and deconstructing data. 
% It does so implicitly by matching constructed data
% directly against a number of possible forms.
% Maybe combine? 
It is also an established and well-researched topic in
academy~\cite{burton1993pattern, palao1996new, wadler1987views, macqueen1985tree,
bpc}. Pattern matching is appreciated by programmers and researchers alike for
two main reasons: It enables \it{implicit} data deconstruction, and it has a
desirable cost model. Specifically (regarding the latter), pattern matching can
be compiled to a \it{decision tree}, a data structure that enforces linear
runtime performance by guaranteeing no part of the data will be examined more
than once.~\cite{maranget}

However, pattern matching cannot succinctly express certain common computations,
so designers of popular programming languages have introduced \it{extensions} to
pattern matching (Section~\ref{extensions}). Without extensions, programmers who
wish to express these computations in these languages are forced to duplicate
code, nest \it{case} expressions, and create multiple points of truth. 

Extensions strengthen pattern matching, but they aren't unified across
programming languages. Rather than continuing to extend pattern matching in
different directions \it{ad infinitum}, it might be nice to find an alternative
to pattern matching that doesn't need extensions to succinctly solve the
problems programmers face. Last year, Verse~\cite{verse} introduced
a tempting possibility for an such an alternative. Verse shed light on a
different way to implicitly deconstruct data without pattern matching:
\it{equations}. Equations look expressive, and it appears at a glance that they
can express everything that pattern matching can, including with popular
extensions. 

But a full implementation of Verse is complicated, cost-wise. Verse is a
functional logic programming language, and that can mean expressions can
backtrack at runtime and return multiple results, both of which are
hard to predict in their costs. 

A worthwhile goal could be to harmonize the expressive quality of Verse's
equations with the decision tree property of patterns.

\bf{My central contribution in this thesis} is to show that \VMinus, a language
that uses Verse's equations with some restrictions, can be compiled to a
decision tree. I also demonstrate how \VMinus\ subsumes pattern matching with
popular extensions. 

In order to achieve this, I also made the following contributions: I formalized
a subset of Verse into a core language \VMinus with a big-step operational
semantics (Section~\ref{vminus}), I formalized pattern matching in a core
language \PPlus with a big-step operational semantics (Section~\ref{pplus}), I
formalized decision trees into a core language \D\ with a big-step operational
semantics (Section~\ref{d}), I formalized a translation between the languages
(Sections \ref{vminustod} and~\ref{pplustovminus}), and I implemented each
language in Standard ML. 

\end{document}